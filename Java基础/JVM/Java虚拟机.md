
## JVM基础概念

​	Java源文件通过编译器产生class文件，字节码文件再通过Java虚拟机中的解释器，编译成特定机器上的机器码。这也是Java跨平台的原因。

### JVM内存区域

​	Java内存模型分为两大类，线程私有和共享数据。线程私有：程序计数器、虚拟机栈、本地方法栈。共享数据有：常量池（方法区的一部分）、方法区、Java堆。如下图：

![IMG_21E692D0E9A8-1](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_21E692D0E9A8-1.jpeg)

* 程序计数器：当前线程执行的字节码行号指示器。
* 虚拟机栈：Java方法执行的内存模型，生命周期和线程一致。栈帧是进行方法执行的数据结构。虚拟机栈主要有两种异常：堆栈异常和内存超出异常。
* 本地方法栈：虚拟机使用到的native方法的内存空间。抛出的异常也是堆栈异常和内存超出异常。
* 堆：主要存放着对象的实例和数组的数据。抛出的异常为内存溢出异常。

![IMG_A22B848C2C43-1](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A22B848C2C43-1.jpeg)

* 方法区：主要存放虚拟机加载的类信息、常量、静态变量、编译后的代码。主要抛出内存溢出异常。
* 运行时常量池：属于方法区的一部分，主要存放编译器生成的各种字面量和符号的引用。不会抛出内存溢出异常。

### 垃圾回收算法

* 标记清除算法：将存活的对象标记，然后将为标记的对象的内存空间进行回收。
* 复制算法：将内存空间分为两块，一块用满后，将存活对象复制到另外一块，然后直接将之前的内存空间清理掉。
* 标记整理算法：将存活对象进行标记，然后将存活的对象都移动到一端，再将边界后面的内存空间清理。
* 分代收集算法：将内存分为两个区域：新年代和老年代。比例为1:2.新年代又分为Eden、From、To三个区域，比例为：8:1:1.每次进行回收时，将Eden和From存活对象复制到To中，然后将Eden和From清理。老年代因为对象存活时间久，执行的是标记整理算法。
  * 当标记对象达到15次时，就会移动到老年代。
  * 当To的空间不足时，会将对象移动到老年代。
  * 当老年代也满了或者空间不够了，会触发新年代和老年代的GC，两者分别为：MinorGC和FullGC。

### 标记算法

* 引用计数法：有地方引用这个对象，计数器久加一，引用失效久减一。但是不能解决相互引用的问题。
* 可达性分析算法：以根作为起始点，沿着节点向下搜索，如果一个对象没有可以搜索到的路径，认为该对象不可达，即该对象不可用，可以回收。

### 四种引用类型

​	通过new关键字创建的引用就是强引用，强引用就算内存不足，gc也不会删除它。软引用可以和ReferenceQueue一块使用，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。弱引用通过WeakReference类实现，弱引用的生命周期比软引用短，无论当前内存空间是否足够，弱引用都会被删除。虚引用也叫幻象引用，通过PhantomReference类来实现。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

### 垃圾收集器的种类

* Serial垃圾收集器：单线程、复制算法。进行垃圾回收的同时，必须暂停其他所有工作线程。
* ParNew垃圾收集器：Serial收集器的多线程版本。也是需要暂停其他线程，在垃圾回收过程中。
* Paraller Scavenge垃圾收集器：多线程复制算法、高效。
* Serial Old垃圾收集器：单线程标记整理算法。主要回收老年代。
* Paraller Old垃圾收集器：多线程标记整理算法。
* CMS收集器：多线程标记清楚算法。有四个阶段：1）初始标记。2）并发标记。3）重新标记。4）并发清楚。
* G1垃圾收集器：基于标记整理算法，不产生内存碎片。可以精确控制停顿时间，在不牺牲吞吐量的情况下实现低停顿垃圾回收。

### JVM调优的工具

* jconsole：对jvm中的内存、线程和类进行监控
* jvisualvm：可以分析内存快照、线程快照、程序死锁、监控内存变化、gc等

### 类加载过程

​	类加载机制分为五个部分：加载-验证-准备-解析-初始化。

![IMG_B2026A3771A2-1](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_B2026A3771A2-1.jpeg)

* 加载：生成该类的Class对象。

* 验证：主要是确保Class文件是否符合要求。

* 准备：为类变量分配内存空间。

* 解析：虚拟机将常量池中的符号引用替换为直接引用的过程。

* 初始化：执行类中定义的Java代码。

#### 类加载器

​	对于任意一个类，需要加载它的类加载器和这个类本身一同确立这个类在JVM中的唯一性，每一个类加载器都有一个独立的类名称空间。类加载器就是通过完全限定名将class文件加载到jvm中，再转换为class对象。

  类加载器有三种：启动类加载器、扩展类加载器、应用类加载器。

  * 双亲委派模型：类加载器接收到类加载任务时，会交给父类加载器完成，这样，所有的加载请求都会传递到启动类加载器，只有当父类无法完成加载请求，子加载器才会去尝试加载类。好处就是无论哪个类加载器进行加载，最后得到的都是jvm中唯一的class对象。

### 其他

* 对于两个类的情况，即一个父类和一个子类，执行顺序如下。执行父类的静态初始化块。执行子类的静态初始化块。执行父类的非静态初始化块。执行父类的构造器。执行子类的非静态初始化块。执行子类的构造器。
* 编译是javac test.java。运行是java test。
* 静态域,main(),构造代码块,构造方法。
* Java通过垃圾回收回收不再引用的变量，垃圾回收时对象的finallize（）不一定会得到执行。
* 判断对象是否可以回收有两个算法，引用计数算法和根搜索算法。垃圾回收算法则有四种，标记清楚算法、复制算法、标记整理算法、分代收集算法Minor GC 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会频繁执行，一般回收速度也比较快。Full GC 也称 Major GC，指发生在老年代的垃圾回收操作。出现了 Full GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。优先在新生代区存放对象，大对象直接放在老年代区，新生代区的对象经历15次GC后就会进入老年代区。