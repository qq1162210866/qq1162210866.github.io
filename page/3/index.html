<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-qq1162210866.github.io/博客/数据结构/冒泡排序学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.197Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    冒泡排序是非常基础的排序算法之一，也很容易理解。过程简单来说就是：每次比较相邻的两个元素，如果前一个元素大于后一个元素就交换这两个元素的位置（不一定大于，小于也可以）。一直重复这个操作，知道数组中所有的元素排序正确后，即所有的元素都不需要交换位置。</p>
<p>​    也可以看看动图去理解。动图这里放上一个链接，菜鸟教程的：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/bubble-sort.html">菜鸟教程冒泡排序</a><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡算法动图链接"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>​    实现起来也是比较简单的：代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) BaseSort.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>​    当然，这个算法还有一些可以优化的点，但是对于算法的总体效果来说，作用不大，当作一个了解吧。</p>
<h3 id="优化进入排序的条件"><a href="#优化进入排序的条件" class="headerlink" title="优化进入排序的条件"></a>优化进入排序的条件</h3><p>​    通过一些特殊的例子，我们可以看到，某些情况下，当数组内没有进行交换后，循环还是会继续，这个时候其实可以中断循环，这个优化的思路就是这样：当发现某次循环后元素没有进行交换，就退出循环，因为当前数组已经有序了。需要增加一个变量记录当前循环是否交换变量。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> swaped = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//如果没有发生交换，代表当前数组有序，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (!swaped) <span class="keyword">break</span>;</span><br><span class="line">        swaped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                BaseSort.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swaped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记录最近一次交换的数组下标"><a href="#记录最近一次交换的数组下标" class="headerlink" title="记录最近一次交换的数组下标"></a>记录最近一次交换的数组下标</h3><p>​    如果在一次循环中，数组前几次排序进行了交换，但是后面没有交换位置，其实我们这里可以在下一次循环时，只循环到最后一次交换的下标，因为后面的元素没有交换过，代表已经有序了。这个优化的思路就是如此。这里也可以结合前一个优化，都添加进来。具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  当前循环是否交换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> swaped = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前循环的最后一个index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> lastIndex = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后交换的数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> swapedIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swaped) &#123;</span><br><span class="line">        swaped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//因为第一次的循环，交换的index只会到arr.length - 2,所以这里用小于</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                BaseSort.swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                swaped = <span class="keyword">true</span>;</span><br><span class="line">                swapedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastIndex = swapedIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    注释写的也比较清楚了，这里就不再详细讲解了。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​    力扣上面其实也有相关的题，可以练手。下面就写两道题。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></li>
</ul>
<p>​    思路不是很容易想到，最主要的就是想明白排序的依据，即决定数组元素位置的依据。规则已经写在题目中了。剩下就没有什么需要注意的了。送上代码，使用的是冒泡，效率不是很高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.offer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * offer45.java</span></span><br><span class="line"><span class="comment"> * Description: 把数组排成最小的数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">offer45</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String result = <span class="keyword">new</span> offer45().minNumber(nums);</span><br><span class="line">        System.err.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                String tmp1 = nums[j] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                String tmp2 = nums[j + <span class="number">1</span>] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">              <span class="comment">//排序的依据，即题目里面的意思。tmp1+tmp2&gt;tmp2+tmp1  tmp1&quot;&gt;&quot;tmp2</span></span><br><span class="line">                <span class="keyword">if</span> (Long.parseLong(tmp1 + tmp2) &gt; Long.parseLong(tmp2 + tmp1)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            stringBuilder.append(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></li>
</ul>
<p>​    这个思路就比较简单了，因为冒泡排序不会影响数组中原有元素的位置顺序，所以直接冒泡即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LeetCode283.java</span></span><br><span class="line"><span class="comment"> * Description: 移动零</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode283</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> LeetCode283().moveZeroes(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.err.print(num + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/" data-id="ckupl1rrf001j6rup7m9h8n7w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/数据结构/堆的了解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E7%9A%84%E4%BA%86%E8%A7%A3/" class="article-date">
  <time datetime="2021-10-13T13:28:21.197Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><ul>
<li><p>堆是一个完全二叉树，这样的堆也被称为二叉堆。（之前了解过相关知识，但是现在大部分忘记了。后续博客上会补充上去）</p>
</li>
<li><p>子节点大于如果大于节点，这样的堆称为小顶堆。子节点小于节点的堆称为大顶堆。</p>
<p>堆的基本操作有插入、删除堆顶元素。</p>
</li>
</ul>
<h2 id="堆的操作图解"><a href="#堆的操作图解" class="headerlink" title="堆的操作图解"></a>堆的操作图解</h2><ul>
<li>堆化。将堆中的元素重新按照堆的结构插入，类似于排序。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_DC4BB8DB8C61-1.jpeg" alt="IMG_DC4BB8DB8C61-1"></p>
<ul>
<li><p>删除堆顶元素。将堆顶的元素删除，再将堆进行堆化。（其中，如果出现了数组空洞，可以将最后一个元素覆盖堆顶元素，再执行堆化）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A1368FA8ADD6-1.jpeg" alt="IMG_A1368FA8ADD6-1"></p>
</li>
</ul>
<h2 id="在平时代码中的应用"><a href="#在平时代码中的应用" class="headerlink" title="在平时代码中的应用"></a>在平时代码中的应用</h2><p>可能是因为我了解的太少，感觉用处不是很大，因为基础的工具对于这些数据的操作大部分都已经封装好了，只需要知道怎么调用就可以了。但是作为程序员来说，知道其内部原理还是比较好的。</p>
<p>因为很长时间没有学习数据结构了，所以这个写着相当费力，后面陆续会写相关博客，但是可能不是很多。。。</p>
<p>代码在下面。注释中对于代码的解释已经很详细了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> arraytrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HeapTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 堆的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆内当前堆元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆内最大堆元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description:初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapTrain</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        capacity = count;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            System.err.print(<span class="string">&quot;[&quot;</span> + arr[i] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 换位方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> swap = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = swap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description:向堆中插入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">        arr[n] = value;</span><br><span class="line">        <span class="keyword">int</span> i = n;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 两个判断条件，一个是i是不是标号最小的元素、节点是不是大于子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (i / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; arr[i / <span class="number">2</span>] &lt; arr[i]) &#123;</span><br><span class="line">            swap(i / <span class="number">2</span>, i);</span><br><span class="line">            i = i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description:删除堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 堆内可以放负数，如果arr[1]=0,负数就没法比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将最后的元素放到跟节点，防止数组空洞。同时将两步堆化合并为一步</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        arr[<span class="number">1</span>] = arr[count];</span><br><span class="line">        n--;</span><br><span class="line">        heaply(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 堆化处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heaply</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 默认当前节点是最大节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> maxValueIndex = index;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  先计算左节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (maxValueIndex * <span class="number">2</span> &lt;= n &amp;&amp; arr[maxValueIndex] &lt; arr[maxValueIndex * <span class="number">2</span>]) &#123;</span><br><span class="line">                maxValueIndex = maxValueIndex * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 计算右节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (maxValueIndex * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; arr[maxValueIndex] &lt; arr[maxValueIndex * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                maxValueIndex = maxValueIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 经过比较确实是最大节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (maxValueIndex == index) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(index, maxValueIndex);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 把最大节点给到当前节点的子节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            index = maxValueIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeapTrain heapTrain = <span class="keyword">new</span> HeapTrain(<span class="number">10</span>);</span><br><span class="line">        heapTrain.insert(<span class="number">3</span>);</span><br><span class="line">        heapTrain.insert(<span class="number">1</span>);</span><br><span class="line">        heapTrain.insert(<span class="number">9</span>);</span><br><span class="line">        heapTrain.heapPrint();</span><br><span class="line">        System.err.println();</span><br><span class="line">        heapTrain.deleteMax();</span><br><span class="line">        heapTrain.heapPrint();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E7%9A%84%E4%BA%86%E8%A7%A3/" data-id="ckupl1rrg001k6ruphud17hel" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/数据结构/算法复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.197Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法复习"><a href="#算法复习" class="headerlink" title="算法复习"></a>算法复习</h2><p>把想法转换成代码也是很困难的</p>
<p>先把几个排序算法都写写博客，最好找几个题练习一下</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>​    动态规划适用的问题：原问题的解可以用子问题的答案回答。他也有两个重要的点：1）找到最优解子结构，即原问题和子问题的关系。2）子问题之间的联系（不是必须），主要是防止解答重复的子问题。</p>
<ul>
<li>将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。（核心）</li>
<li>分治法和动态规划的区别主要就是有无子问题重复的情况。</li>
</ul>
<h4 id="线性动态规划"><a href="#线性动态规划" class="headerlink" title="线性动态规划"></a>线性动态规划</h4><p>​    线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。</p>
<h3 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h3><p>广度优先搜索算法（Breadth-First-Search，缩写为 BFS），是一种利用队列实现的搜索算法。简单来说，其搜索过程和 “湖面丢进一块石头激起层层涟漪” 类似。</p>
<p>深度优先搜索算法（Depth-First-Search，缩写为 DFS），是一种利用递归实现的搜索算法。简单来说，其搜索过程和 “不撞南墙不回头” 类似。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>​    冒泡排序是比较基础的排序，就是将数组中的元素两两比较，如果前一个元素大于后一个元素，就将其交换。大的放在数组后面，直到元素循环完毕。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。选择排序是不稳定的。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序的思想就是，将数组分为两个部分，后面部分的元素循环和前一部分的元素比较，直到找到自己合适的位置。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>插入排序的优化版：思想就是：将数组分为间隔不同的字数组，分别为这些字数组进行插入排序。然后将间隔缩小，再进行排序，最好间隔为1，就是插入排序。主要是利用了排序中间产生的多个逆序对来缩小排序时间。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>从数组中取出一个基数，比这个基数大的放右边，小的放左边。这样在递归的调用两边的数组。直到排序完成</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>将两个有序的数组进行组合排序就是归并排序，将数组分为两个字数组，分别递归让字数组有序，再比较两个数组头部元素的大小。分别插入到新的数组中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/" data-id="ckupl1rrg001l6rup8frl7a4w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/数据结构/选择排序学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.197Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    前面学习了冒泡排序，其实我一直将冒泡和选择搞混淆，因为冒泡也是每次循环找到最大或者最小的元素，但是冒泡多了一步交换。选择排序就不同，每次循环找到最大值或者最小值，最后才将其放到队尾或者队首。</p>
<p>​    说这这里，选择排序的概念就很清楚了，有两个循环，外循环遍历所有的元素，内循环遍历找到最大值，内循环完成后，将当前循环的最大值移动到队尾。外循环完成后，排序也就完成了。示意图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8c42ffa5ab7186aa7f09e4ce68e338b9.png" alt="img"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​    代码来说就比较简单了，甚至比冒泡排序还要简单。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环到数组到前一个元素即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        BaseSort.swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看代码也能看出来，选择排序对于数组中元素的位置有破坏，即大家常说的选择排序不稳定。（如果数组中两个元素的位置经过排序后发生了变化，这种算法就是不稳定的）冒泡排序因为每次比较都可能交换了位置，所以冒泡排序后的数组元素的位置仍然能够保持之前的位置。（相同的元素）这也是选择排序的一个缺点吧。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>​    选择排序的优化思路也比较好想，就是在比较多过程中同时找到最大值和最小值。这样会比原有的写法快一点。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        minIndex = maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[maxIndex]) maxIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        BaseSort.swap(arr, i, minIndex);</span><br><span class="line">        <span class="comment">//防止最大值为i的情况。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) &#123;</span><br><span class="line">            BaseSort.swap(arr, length - <span class="number">1</span> - i, minIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BaseSort.swap(arr, length - <span class="number">1</span> - i, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码中间唯一需要注意的地方也写了注释了，其他就没有什么可讲的了。代码我自己测试了几个用例，没有发现什么问题，但是测试较少，怀疑还是存在一些没有考虑到的情况。这里也欢迎大家指正。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​    还是把选择排序练习一下。这里上两个题目。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></li>
</ul>
<p>​    思路比较简单，利用选择排序，找最大值，如果是第k大大元素，就返回，否则继续排序。优化的点其实也有：可以判断k是否大于数组中间长度，然后决定是找最大还是最小，能一定程度减少一些运算。但是因为时间问题，我实现的代码并没有做这个优化。具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">int</span> maxIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[maxIndex]) maxIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == k) <span class="keyword">return</span> nums[maxIndex];</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[maxIndex];</span><br><span class="line">        nums[maxIndex] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a></li>
</ul>
<p>​    这个也很简单，思路是直接用选择排序，可以用二元选择排序。没有什么可讲的点，但是因为力扣的时间限制，该代码没有通过。思路是正确的，后面这道题也可以选择其他时间复杂度较低的排序算法，例如：快速排序，归并排序等。选择排序思路如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        minIndex = maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) minIndex = j;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[maxIndex]) maxIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        swap(nums, i, minIndex);</span><br><span class="line">        <span class="comment">//防止最大值为i的情况。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) &#123;</span><br><span class="line">            swap(nums, length - <span class="number">1</span> - i, minIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(nums, length - <span class="number">1</span> - i, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    至此，选择排序基本讲完了，也欢迎大家补充、指正。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/" data-id="ckupl1rrh001m6rupbzlje0v2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/杂项/JAVA代码优化的35个细节" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/JAVA%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%9A%8435%E4%B8%AA%E7%BB%86%E8%8A%82/" class="article-date">
  <time datetime="2021-10-13T13:28:21.197Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JAVA代码优化的35个细节"><a href="#JAVA代码优化的35个细节" class="headerlink" title="JAVA代码优化的35个细节"></a>JAVA代码优化的35个细节</h1><ul>
<li><p>1、尽量指定类、方法的final修饰符<br>  为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程就是内联。</p>
</li>
<li><p>2、尽量重用对象<br>新建对象不仅仅要花时间去生成，还要花时间去回收。对于字符串的操作最好是使用StringBuilder/StringBuffer。</p>
<pre><code>  /**
   * 不正确的方式，会新建多个String对象
   */
  String s = &quot;a&quot; + &quot;b&quot;;
  System.out.println(s);
  /**
   * 使用StringBuilder/StringBuffer的方法来拼接字符串
   */
  StringBuilder stringBuilder = new StringBuilder();
  stringBuilder.append(&quot;a&quot;).append(&quot;b&quot;);
  System.out.println(stringBuilder);
  
</code></pre>
</li>
<li><p>3、尽可能使用局部变量<br>  调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p>
<ul>
<li>栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。  </li>
<li> 堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。  </li>
</ul>
<pre><code> int [] arr=new int [3];
</code></pre>
<p>  这样先在栈中创建一个arr变量，再给这个变量赋值，发现右边是一个实体，所以在堆中创建一个实体空间。</p>
</li>
<li><p>4、及时关闭流<br>  对流的操作结束了，要及时关闭以释放资源。</p>
</li>
<li><p>5、尽量减少对变量的重复计算<br>  调用方法，哪怕只有一行，也是有消耗的。</p>
<pre><code>  for (int i = 0; i &lt; arr.length; i++) &#123;
      //频繁调用了arr.length方法
  &#125;
  int length = arr.length;
  for (int i = 0; i &lt; length; i++) &#123;
      //比上一个少调用了length方法
  &#125;
</code></pre>
</li>
<li><p>6、尽量采用懒加载的策略，即在需要的时候才创建<br>  判断创建对象时，尽量在if语句里面创建对象，采用懒加载方式。</p>
</li>
<li><p>7、慎用异常<br>  异常只能用于错误处理，不应该用来控制程序流程。</p>
</li>
<li><p>8、不要在循环中使用try…catch…，应该把其放在最外层</p>
</li>
<li><p>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度    如果初始容量为5000，默认初始长度为16（StringBuilder），这样就会一直在扩展和复制数组，造成资源浪费。</p>
</li>
<li><p>10、当复制大量数据时，使用System.arraycopy命令</p>
</li>
<li><p>11、乘法和除法使用移位操作<br>  最好加上注释，方便别人理解</p>
<pre><code>  for (int var = 0; var &lt; 100; var += 5) &#123;
      int a = var * 8;
      int b = var / 2;
      System.err.println(&quot;a=&quot;+a+&quot;: b=&quot;+b);
  &#125;
  for (int var = 0; var &lt; 100; var += 5) &#123;
      int a = var &lt;&lt; 3;
      int b = var &gt;&gt; 1;
      System.err.println(&quot;a=&quot;+a+&quot;: b=&quot;+b);
  &#125;
  
  &lt;&lt;      :    左移运算符，num &lt;&lt;1,相当于num乘以2
  &gt;&gt;      :    右移运算符，num &gt;&gt;1,相当于num除以2
  &gt;&gt;&gt;    :    无符号右移，忽略符号位，空位都以0补齐，（计算机中数字以补码存储，首位为符号位）。
</code></pre>
</li>
<li><p>12、循环内不要不断创建对象引用<br>  这样导致内存中有循环次数个对象。建议在循环外声明，在循环内重新赋值。</p>
</li>
<li><p>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</p>
</li>
<li><p>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</p>
</li>
<li><p>15、不要将数组声明为public static final<br>  将数组声明为static和final没有意义，因为数组的内容还是可以改变。</p>
</li>
<li><p>16、尽量在合适的场合使用单例<br>单例适用的范围。</p>
<ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
</li>
<li><p>17、尽量避免随意使用静态变量<br>  如果某个对象被静态变量引用，除非静态变量所在的类被卸载，否则这个对象是不会被gc回收的。</p>
</li>
<li><p>18、及时清除不再需要的会话<br>  当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。</p>
</li>
<li><p>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历<br>  实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；</p>
<pre><code>  ArrayList arrayList = new ArrayList&lt;String&gt;(100);
  if (arrayList instanceof RandomAccess) &#123;
      /**
       *  先判断list是不是RandomAccess的实现类，如果是使用for循环，否则使用迭代器
       */
      int listLength = arrayList.size();
      for (int i = 0; i &lt; listLength; i++) &#123;
      &#125;
  &#125; else &#123;
      Iterator&lt;String&gt; stringIterator = arrayList.iterator();
      while (stringIterator.hasNext()) &#123;
          stringIterator.next();
      &#125;
  &#125;
  
</code></pre>
</li>
<li><p>20、使用同步代码块替代同步方法<br>  除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p>
</li>
<li><p>21、将常量声明为static final，并以大写命名</p>
</li>
<li><p>22、不要创建一些不使用的对象，不要导入一些不使用的类</p>
</li>
<li><p>23、程序运行过程中避免使用反射<br>  将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存</p>
</li>
<li><p>24、使用数据库连接池和线程池</p>
</li>
<li><p>25、使用带缓冲的输入输出流进行IO操作</p>
</li>
<li><p>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList<br>ArrayList从名字上来讲是数组列表，表面上是动态大小，其底层实现原理其实还是一个数组。LinkedList实际上是用双向循环链表实现的。因为ArrayList有索引，所以顺序插入使用ArrayList比较快。中间插入使用LinkedList比较快，因为只需要修改两个引用就可以了。</p>
</li>
<li><p>27、不要让public方法中有太多的形参<br>  形参太多不符合java万物皆对象的理念，多个形参可以封装为一个实体对象。</p>
</li>
<li><p>28、字符串变量和字符串常量equals的时候将字符串常量写在前面<br>避免空指针异常。</p>
</li>
<li><p>29、在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</p>
</li>
<li><p>30、不要对数组使用toString方法<br>数组的toString方法会打印出数组引用对象的地址，有可能产生空指针异常。集合的toString可以打印所有元素，因为它重写了父类的toString方法。</p>
</li>
<li><p>31、不要对超出范围的基本数据类型做向下强制转型<br>超出范围的基本数据强转的1话会导致数据变化，并且很难得到想要的数据。</p>
<pre><code>  Long aLong = 123456789012345L;
  int i = (int) aLong;
  System.out.println(i);
</code></pre>
</li>
<li><p>32、公用的集合类中不使用的数据一定要及时remove掉<br>公用集合（也就是说不是方法里面的属性）中的数据不及时remove掉会有内存泄漏的危险。</p>
</li>
<li><p>33、把一个基本数据类型转为字符串，基本数据类型.toString是最快的方式、String.valueOf次之、数据+””最慢        </p>
<ul>
<li>1、String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断</li>
<li>2、Integer.toString方法就不说了，直接调用了</li>
<li>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符 这个暂时不知道原因，现在也没法得出结论，有大佬知道的可以指点一下。    </li>
</ul>
</li>
<li><p>34、使用最有效率的方式去遍历Map    </p>
<pre><code>  HashMap&lt;String, String&gt; stringStringHashMap = new HashMap&lt;&gt;();
  stringStringHashMap.put(&quot;aaa&quot;, &quot;111&quot;);
  /**
   * 先获取map中各个键值对映射关系的集合，再使用迭代器来遍历这个集合达到遍历map的作用
   * 如果只是想遍历一下这个Map的key值，可以使用 Set keySet = hm.keySet;
   */
  Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = stringStringHashMap.entrySet();
  Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entrySet.iterator();
  while (iterator.hasNext()) &#123;
      Map.Entry&lt;String, String&gt; stringStringEntry = iterator.next();
      System.out.println(stringStringEntry.getKey() + &quot;\t&quot; + stringStringEntry.getValue());
  &#125;
</code></pre>
</li>
<li><p>35、对资源的close建议分开操作<br>这样操作是为了避免一个资源关闭异常导致下一个资源无法关闭的情况。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/JAVA%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%9A%8435%E4%B8%AA%E7%BB%86%E8%8A%82/" data-id="ckupl1rrh001n6rup0q9p0tg0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/杂项/Maven学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/Maven%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.197Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    又是工作中遇到了一个Maven的问题，解决了好久都是迷迷糊糊的，这次记录下来防止自己再次忘记。</p>
<h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><p>​    Maven 是一个意第绪语单词，意思是知识的积累，最初是为了简化 Jakarta Turbine 项目中的构建过程。每个项目都有自己的 Ant 构建文件，都略有不同。我们想要一种构建项目的标准方法、对项目组成的清晰定义、一种发布项目信息的简单方法以及一种在多个项目之间共享 JAR 的方法。</p>
<p>​    结果是现在可以用于构建和管理任何基于 Java 的项目的工具。我们希望我们已经创建了一些东西，使 Java 开发人员的日常工作更容易，并且通常有助于理解任何基于 Java 的项目。</p>
<p>​    这个是Maven官网上对于Maven是什么的一个介绍。也可以看出Maven这个工具的用处，就是简单的管理项目依赖的jar包，但是随着Maven的发展，后续也增加了许多有用的功能。想我们使用的话，也就是简单的管理jar包或者依赖。</p>
<h2 id="配置Maven环境"><a href="#配置Maven环境" class="headerlink" title="配置Maven环境"></a>配置Maven环境</h2><p>​     配置Maven环境不是本篇博客的重点，所以不在这里详细的介绍，只是说一下大致的环节。</p>
<p>​     安装Java环境，将Java的安装地址配置到系统的环境变量里面。下载Maven压缩包，解压到你指定的目录，配置Maven的系统环境变量即可。最后修改一下settings文件，修改镜像地址和本地仓库地址即可。</p>
<p>​    执行<code>mvn -version</code>出现以下画面就代表安装成功。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902214851086.png" alt="image-20210902214851086"></p>
<h2 id="简单使用Maven"><a href="#简单使用Maven" class="headerlink" title="简单使用Maven"></a>简单使用Maven</h2><p>​    Maven安装完毕，下面就可以搞一个简单的小Demo，看到成功的画面才有学下去的动力，这个Demo也是官方的例子，具体的地址如下： <a target="_blank" rel="noopener" href="https://maven.apache.org/guides/getting-started/Maven-in-five-minutes.html">Maven简单Demo</a></p>
<p>​    在目录下执行如下命令：</p>
<p><code>mvn archetype:generate -DgroupId=com.psq.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false</code></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902215259888.png" alt="image-20210902215259888"></p>
<p>​    这个命令就是依据你选定的原型创建了一个Maven结构的项目，项目名称为<code>my-app</code>。项目的结构如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902215525898.png" alt="image-20210902215525898"></p>
<p>​    可以看到和我们平时的SpringBoot应用相差不多，其实SpringBoot应用也是按照Maven的原型修改了一下。</p>
<p>​    下面执行<code>mvn package</code>，可以看到</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902215723521.png" alt="image-20210902215723521"></p>
<p>​    这里因为我依赖都下载过了，所以很快，第一次执行会稍微慢一些。能够看到项目目录中多了一些东西，多出来的东西就是Maven编译和打包产生的文件，还有一些其他的文件，目前暂时不清楚。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902215910039.png" alt="image-20210902215910039"></p>
<p>​    我们再执行命令<code>java -cp ./target/my-app-1.0-SNAPSHOT.jar com.psq.app.App </code>就能够看到一个输出了。到此，Maven的简单Demo就结束了。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902220047445.png" alt="image-20210902220047445"></p>
<p>​    这个例子完成是不是对于Maven的使用更加的清晰了。下面就介绍一下涉及到的点，当然目前肯定不全，后续遇到其他的知识点也会慢慢补齐。</p>
<h2 id="一些关于Maven的知识点"><a href="#一些关于Maven的知识点" class="headerlink" title="一些关于Maven的知识点"></a>一些关于Maven的知识点</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>​    Maven将构建和分发项目的过程进行了明确的定义，这个就是Maven中的生命周期。一般默认的有以下几种：</p>
<ul>
<li><code>validate</code> 验证项目正确，并获取所有必要信息</li>
<li><code>compile</code>编译项目源代码</li>
<li><code>test</code>使用合适的单元测试框架测试编译后的源代码。这些测试不应要求打包或部署代码</li>
<li><code>package</code> 取编译后的代码，并以可分发格式打包，例如JAR</li>
<li><code>verify</code>对集成测试结果进行任何检查，以确保满足质量标准</li>
<li><code>install</code>将软件包安装到本地存储库中，用于本地其他项目中的依赖项</li>
<li><code>deploy</code>在构建环境中完成，将最终的软件包复制到远程存储库中，以便与其他开发人员和项目共享</li>
</ul>
<p>​    看着是不是特别熟悉，Idea中的Maven也有类似的。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902220700371.png" alt="image-20210902220700371"></p>
<p>​    是不是也知道了Idea中这些按钮的含义。也知道了自己以后应该在什么步骤执行点击什么按钮了吧。</p>
<h3 id="Maven文件结构介绍"><a href="#Maven文件结构介绍" class="headerlink" title="Maven文件结构介绍"></a>Maven文件结构介绍</h3><p>​    这一部分就是Maven对于项目各种文件的一种限制，不一定非要你完全执行，只是一个建议，和我们平时的项目结构差不多，和我上面的截图类似。具体含义如下：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>存放文件类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>src/main/java</code></td>
<td>应用程序代码</td>
</tr>
<tr>
<td><code>src/main/resources</code></td>
<td>资源库资源</td>
</tr>
<tr>
<td><code>src/main/filters</code></td>
<td>资源筛选文件</td>
</tr>
<tr>
<td><code>src/main/webapp</code></td>
<td>网络应用程序资源</td>
</tr>
<tr>
<td><code>src/test/java</code></td>
<td>测试代码</td>
</tr>
<tr>
<td><code>src/test/resources</code></td>
<td>测试需要资源</td>
</tr>
<tr>
<td><code>src/test/filters</code></td>
<td>测试资源筛选文件</td>
</tr>
<tr>
<td><code>src/it</code></td>
<td>集成测试（主要用于插件）</td>
</tr>
<tr>
<td><code>src/assembly</code></td>
<td>汇编描述符</td>
</tr>
<tr>
<td><code>src/site</code></td>
<td>站点</td>
</tr>
<tr>
<td><code>LICENSE.txt</code></td>
<td>项目许可证</td>
</tr>
<tr>
<td><code>NOTICE.txt</code></td>
<td>项目所依赖的库需要的通知和归属</td>
</tr>
<tr>
<td><code>README.txt</code></td>
<td>项目介绍</td>
</tr>
</tbody></table>
<p>​    还有一些文件没有列出来，例如git、svn的文件，但是大致的结构都差不多。现在是不是清楚了为什么GitHub上下载的代码都是一个结构了吧。</p>
<h3 id="原型简单介绍"><a href="#原型简单介绍" class="headerlink" title="原型简单介绍"></a>原型简单介绍</h3><p>​    上面简单Demo中使用到了一个原型，原型就是Maven为了方便我们创建项目而创建的基础项目。我们按照这个原型创建自己的项目。Maven的原型挺多的，当然，我们也可以自己定制自己的原型。</p>
<table>
<thead>
<tr>
<th align="center">原型工件</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Maven-archetype-archetype</td>
<td align="center">生成示例原型项目的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-j2ee-simple</td>
<td align="center">生成简单示例J2EE应用程序的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-mojo</td>
<td align="center">用于生成示例Maven插件示例的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-plugin</td>
<td align="center">生成示例 Maven 插件的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-plugin-site</td>
<td align="center">生成Maven插件站点示例的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-portlet</td>
<td align="center">生成JSR-268 Portlet样本的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-quickstart</td>
<td align="center">生成Maven项目示例的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-simple</td>
<td align="center">生成简单 Maven 项目的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-site</td>
<td align="center">一个原型，用于生成Maven站点示例，演示一些受支持的文档类型，如APT、XDoc和FML，并演示如何i18n您的站点。</td>
</tr>
<tr>
<td align="center">Maven-archetype-site-simple</td>
<td align="center">生成Maven站点样本的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-webapp</td>
<td align="center">生成Maven Webapp项目示例的原型。</td>
</tr>
</tbody></table>
<p>​    可以按照自己的需求下载对应的原型，然后进行改造和开发。具体的介绍地址在这里：<a target="_blank" rel="noopener" href="https://maven.apache.org/guides/introduction/introduction-to-archetypes.html">Maven原型介绍</a></p>
<h3 id="pom文件介绍"><a href="#pom文件介绍" class="headerlink" title="pom文件介绍"></a>pom文件介绍</h3><p>​    Maven项目最重要的就是Pom文件，但是Pom文件里面的内容实在太多了，我一篇博客很难讲完，这里偷个懒，讲Maven的介绍和参考链接放上来，也算是防止自己忘记吧。还是要说一句，任何的教程和文档都没有官方文档讲的详细。</p>
<p><a target="_blank" rel="noopener" href="https://maven.apache.org/pom.html">Maven官方Pom文件参考</a></p>
<p>​    其实我们常用的就是本项目的坐标配置和项目需要的依赖。再顶多配置一下远程仓库、插件。细看这些配置就可以满足日常开发需求了。</p>
<h2 id="开发中常用的功能"><a href="#开发中常用的功能" class="headerlink" title="开发中常用的功能"></a>开发中常用的功能</h2><p>​    最后一个环节介绍一下平时开发中会用到的功能。也算比较常见吧。</p>
<h3 id="配置私服地址-从私服下载依赖"><a href="#配置私服地址-从私服下载依赖" class="headerlink" title="配置私服地址,从私服下载依赖"></a>配置私服地址,从私服下载依赖</h3><p>​    大部分公司都搭建了私服，也就是边缘端端中心仓库。你的项目要想从这些仓库下载地址也很简单，有以下办法。</p>
<ul>
<li>修改你的Maven的配置文件settings.xml,如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>myprofile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>your custom repo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jarsm2.dyndns.dk<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>myprofile<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改你的项目文件（会覆盖上一步的配置，所以是常用做法）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>your custom repo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jarsm2.dyndns.dk<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>your custom repo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jarsm2.dyndns.dk<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="pom中增加构建配置"><a href="#pom中增加构建配置" class="headerlink" title="pom中增加构建配置"></a>pom中增加构建配置</h3><p>​    通过配置profiles标签，来达到选定打包文件的操作，idea中的显示也比较方便，如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902223704130.png" alt="image-20210902223704130"></p>
<p>​    具体的代码看自己项目定。    </p>
<h3 id="上传jar包到私服"><a href="#上传jar包到私服" class="headerlink" title="上传jar包到私服"></a>上传jar包到私服</h3><p>​    这个步骤也是简单，首先在项目增加配置，你要上传的仓库的地址。再在你的Maven全局配置文件里面配置私服的用户名和地址，也可以配置其他验证方式。配置完成后，执行deploy命令即可。这里就不再详细的展示步骤了，不清楚的可以看看官网的介绍。</p>
<p><a target="_blank" rel="noopener" href="https://maven.apache.org/guides/getting-started/index.html#How_do_I_deploy_my_jar_in_my_remote_repository">部署到远程仓库</a></p>
<p>​    但是需要注意，开发版本和稳定版本是有区别的，有时某些远程仓库是只能上传开发版本的，有些是只能上传稳定版本的。需要你上传时注意。</p>
<h3 id="打包到本地仓库"><a href="#打包到本地仓库" class="headerlink" title="打包到本地仓库"></a>打包到本地仓库</h3><p>​    这个就更加简单了，就是本地install命令即可，在仓库中寻找对应目录的jar即可。我这里也不演示了。</p>
<p>​    至此，Maven的介绍和一些我能想到的点就全部介绍完毕了。后续有机会还是会继续更新的。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/Maven%E5%AD%A6%E4%B9%A0/" data-id="ckupl1rri001o6ruphkyz0lb1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/杂项/RESTful风格了解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/RESTful%E9%A3%8E%E6%A0%BC%E4%BA%86%E8%A7%A3/" class="article-date">
  <time datetime="2021-10-13T13:28:21.197Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RESTful风格了解"><a href="#RESTful风格了解" class="headerlink" title="RESTful风格了解"></a>RESTful风格了解</h2><p>​    又一次工作中要求接口的形式需要按照RESTful风格，由于第一次听到这个名词，所以来了解一下。</p>
<p>​    RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。</p>
<p>​    其实RESTful不是一个新技术，是原有的技术添加了一些规则或者重新定义了使用方法。下面就介绍RESTful风格的重要的一些概念。</p>
<p>​    RESTful的特点。（来自百度百科）</p>
<ul>
<li>每一个URI代表1种资源；</li>
<li>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li>
<li>通过操作资源的表现形式来操作资源；</li>
<li>资源的表现形式是XML或者HTML；</li>
<li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li>
</ul>
<p>​    其实看到这里就发现了RESTful并没有添加了什么新的概念，只是将所有的操作定义为对资源的操作。它的优点也显而易见，<em>扩展性强、结构清晰</em>。但是缺点也是有的，当项目很小，使用这种风格就显得没有必要甚至比较繁琐。剩下就没有什么需要说的了，然后就是列出一下比较好的例子。</p>
<ul>
<li>从账户a转账到账户b里面100元</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /accounts/a/transfer/100/to/b</span><br></pre></td></tr></table></figure>

<p>可以修改为这样。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /transaction HTTP/1.1</span><br><span class="line">from=a&amp;to=b&amp;money=100</span><br></pre></td></tr></table></figure>

<p>​    需要注意的地方（这个东西感觉还是使用过程中慢慢去了解，后面也会慢慢补充）：</p>
<ul>
<li>版本号应该是放在HTTP请求头信息的Accept字段中，而不是放在URL中。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/RESTful%E9%A3%8E%E6%A0%BC%E4%BA%86%E8%A7%A3/" data-id="ckupl1rri001p6rup1jsfam7g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/协议/HTTP/HTTP图解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E5%8D%8F%E8%AE%AE/HTTP/HTTP%E5%9B%BE%E8%A7%A3/" class="article-date">
  <time datetime="2021-10-13T13:28:21.197Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近工作中用到了HTTP，想了解一下，所以看了《图解HTTP》，下面的内容相当于读书笔记。作为记录，省的后面又忘记，先后顺序按照阅读顺序。</p>
<ul>
<li><p>1.三项构建WWW的技术。</p>
<ul>
<li>“把SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；</li>
<li>作为文档传递协议的 HTTP ；</li>
<li>指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）”</li>
</ul>
</li>
<li><p>2.“TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。” </p>
<ul>
<li>“应用层决定了向用户提供应用服务时通信的活动。”  </li>
<li>“传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。”  </li>
<li>“网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。”    </li>
<li>“链路层用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。”</li>
</ul>
</li>
<li><p>3.三次握手<br>  “发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。”</p>
</li>
<li><p>4.DNS服务<br>“DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。”</p>
</li>
<li><p>5.URI和URL的区别<br>  “URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。”</p>
</li>
<li><p>6.HTTP/1.1中的方法</p>
<ul>
<li>“GET ：获取资源” “GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。”</li>
<li>“POST：传输实体主体” “POST 方法用来传输实体的主体。”</li>
<li>PUT：传输文件 “PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。”</li>
<li>“HEAD：获得报文首部” “HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。”</li>
<li>DELETE：删除文件 “DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。”</li>
<li>“OPTIONS：询问支持的方法”  “OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。”</li>
<li>TRACE：追踪路径 “TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。”</li>
<li> “CONNECT：要求用隧道协议连接代理” “CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。”</li>
</ul>
</li>
<li><p>7.“持久连接节省通信量”</p>
<ul>
<li>持久连接 “为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。”</li>
<li>管线化 “持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。”</li>
</ul>
</li>
<li><p>8.cookie<br>  “HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。”<br>  “Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。”</p>
</li>
<li><p>9.报文首部结构</p>
<ul>
<li>“请求行 包含用于请求的方法，请求 URI 和 HTTP 版本。</li>
<li>状态行 包含表明响应结果的状态码，原因短语和 HTTP 版本。    </li>
<li>首部字段 包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li>
<li>其他 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。”</li>
</ul>
</li>
<li><p>10.报文主体和实体主体的区别</p>
<ul>
<li>“报文（message）是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。</li>
<li>实体（entity）作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。”</li>
<li>“HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。”</li>
<li>报文主体相当于实际内容，实体主体相当于01数据，实体主体因为传输问题有可能被压缩，所以当编码操作后，实体主体可能会和报文主体不一致。</li>
</ul>
</li>
<li><p>11.“多部分对象集合包含的对象”</p>
<ul>
<li>multipart/form-data 在 Web 表单文件上传时使用。</li>
<li>multipart/byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。</li>
</ul>
</li>
<li><p>12.常用的14种状态码</p>
<ul>
<li>200 OK “表示从客户端发来的请求在服务器端被正常处理了。”</li>
<li>204 No Content “该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。”</li>
<li>206 Partial Content “该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。”</li>
<li>301 Moved Permanently “永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。”</li>
<li>302 Found “临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。”</li>
<li>303 See Other “该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。”</li>
<li>304 Not Modified “该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。”</li>
<li>307 Temporary Redirect “临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。”</li>
<li>400 Bad Request “该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。”</li>
<li>401 Unauthorized “该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。”</li>
<li>403 Forbidden “该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。”</li>
<li>404 Not Found “该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。” </li>
<li>500 Internal Server Error “该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。”</li>
<li>503 Service Unavailable “该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。”</li>
</ul>
</li>
<li><p>13.通信数据转发程序</p>
<ul>
<li>“代理。代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。”</li>
<li>“网关。网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。”</li>
<li>“隧道。隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。”</li>
</ul>
</li>
<li><p>14.“4 种 HTTP 首部字段类型”</p>
<ul>
<li>“通用首部字段（General Header Fields）请求报文和响应报文两方都会使用的首部。”</li>
<li>“请求首部字段（Request Header Fields）从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。”</li>
<li>“响应首部字段（Response Header Fields）从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。”</li>
<li>“实体首部字段（Entity Header Fields）针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。”</li>
</ul>
</li>
<li><p>15.HTTP/1.1 首部字段</p>
<ul>
<li>通用首部字段<ul>
<li>“Cache-Control通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。”<ul>
<li> “public 指令。当指定使用 public 指令时，则明确表明其他用户也可利用缓存。”</li>
<li> “private指令。当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。”</li>
<li> “no-cache指令。使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。”</li>
<li> “no-store 指令。当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。”</li>
<li> “s-maxage 指令。s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。”</li>
<li> “max-age指令。当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。”</li>
<li> “min-fresh指令。min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。”</li>
<li> “max-stale 指令。使用 max-stale 可指示缓存资源，即使过期也照常接收。”</li>
<li> “only-if-cached 指令。使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。”</li>
<li> “must-revalidate 指令。使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。”</li>
<li> “proxy-revalidate 指令。proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。”</li>
<li> no-transform 指令。“使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。”</li>
</ul>
</li>
<li>Connection 首部字段具备如下两个作用。<ul>
<li>控制不再转发给代理的首部字段。“在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。”</li>
<li>管理持久连接。“HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。”</li>
</ul>
</li>
<li>“Datte首部字段,Date表明创建HTTP报文的日期和时间。”</li>
<li>“Pragma首部字段。Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。”</li>
<li>“Trailer首部字段。Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。”</li>
<li>“Transfer-Encoding首部字段 。Transfer-Encoding 规定了传输报文主体时采用的编码方式。”</li>
<li>“Upgrade首部字段。Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。”</li>
<li>“Via首部字段。Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。”</li>
<li>“Warning首部字段。HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。”<ul>
<li>“110    Response is stale（响应已过期）代理返回已过期的资源</li>
<li>111    Revalidation failed（再验证失败）代理再验证资源有效性时失败（服务器无法到达等原因）</li>
<li>112    Disconnection operation（断开连接操作）代理与互联网连接被故意切断</li>
<li>113    Heuristic expiration（试探性过期）响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</li>
<li>199    Miscellaneous warning（杂项警告）任意的警告内容</li>
<li>214    Transformation applied（使用了转换）代理对内容编码或媒体类型等执行了某些处理时</li>
<li>299    Miscellaneous persistent warning（持久杂项警告）任意的警告内容”</li>
</ul>
</li>
</ul>
</li>
<li><pre><code>请求首部字段      * Accept首部字段。“Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。”      * Accept-Charset首部字段。“Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。”      * Accept-Encoding首部字段。“Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。”      * Accept-Language首部字段。“首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。”      * Authorization首部字段。“首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。”      * Expect首部字段。“客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。”      * From首部字段。“首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。”      * Host首部字段。“首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。”      * If-Match首部字段。“形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。”      * If-Modified-Since首部字段。“首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。”      * If-None-Match首部字段。“首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。”      * If-Range首部字段。“首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。”      * If-Unmodified-Since首部字段。“首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。”      * Max-Forwards首部字段。“通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。”      * Proxy-Authorization首部字段。“接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。”      * “Range首部字段。对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。”      * Referer首部字段。“首部字段 Referer 会告知服务器请求的原始资源的 URI。”      * “TE首部字段。首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。”      * User-Agent首部字段。“首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。”
</code></pre>
</li>
<li>响应首部字段<ul>
<li>Accept-Ranges首部字段。“首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。”</li>
<li>Age首部字段。“首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。”</li>
<li>ETag首部字段。“首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。”</li>
<li>Location首部字段。“使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。”</li>
<li>“Proxy-Authenticate首部字段。首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。”</li>
<li>Retry-After首部字段。“首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。”</li>
<li>Server首部字段。“首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。”</li>
<li>Vary首部字段。“首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。”</li>
<li>WWW-Authenticate首部字段。“首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。”</li>
</ul>
</li>
<li>实体首部字段<ul>
<li>Allow首部字段。“首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。”</li>
<li>Content-Encoding首部字段。“首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。”</li>
<li>Content-Language首部字段。“首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。”</li>
<li>Content-Length首部字段。“首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。”</li>
<li>Content-Location首部字段。“首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。”</li>
<li>Content-MD5首部字段。“首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。”</li>
<li>Content-Range首部字段。“针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。”</li>
<li>Content-Type首部字段。“首部字段 Content-Type 说明了实体主体内对象的媒体类型。”</li>
<li>Expires首部字段。“首部字段 Expires 会将资源失效的日期告知客户端。”</li>
<li>Last-Modified首部字段。“首部字段 Last-Modified 指明资源最终修改的时间。”</li>
</ul>
</li>
<li>为 Cookie 服务的首部字段<ul>
<li>Set-Cookie首部字段。“开始状态管理所使用的Cookie信息”，属于响应首部字段。<ul>
<li>“expires 属性。Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。”</li>
<li>“path 属性。Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。”</li>
<li>“domain 属性。通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。”</li>
<li>“secure 属性。Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。”</li>
<li>“HttpOnly 属性。Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。”</li>
</ul>
</li>
<li>Cookie首部字段。“服务器接收到的Cookie信息”，属于请求首部字段。<ul>
<li>Cookie首部字段。“首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。”</li>
</ul>
</li>
</ul>
</li>
<li>其他首部字段<ul>
<li>X-Frame-Options首部字段。“首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。”<ul>
<li>“DENY ：拒绝</li>
<li>SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。”</li>
</ul>
</li>
<li>“X-XSS-Protection首部字段。首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。”<ul>
<li>0 ：将 XSS 过滤设置成无效状态</li>
<li>1 ：将 XSS 过滤设置成有效状态</li>
</ul>
</li>
<li>“DNT首部字段。首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。”<ul>
<li>0 ：同意被追踪</li>
<li>1 ：拒绝被追踪</li>
</ul>
</li>
<li>“P3P首部字段。首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。”</li>
</ul>
</li>
</ul>
</li>
<li><p>16.HTTPS</p>
<ul>
<li>“HTTP+ 加密 + 认证 + 完整性保护 =HTTPS”</li>
<li>“HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。”</li>
<li>“使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。”（公钥进行加密，收到数据的一方使用自己的私钥将加密的数据解密。客户端使用公钥加密数据，服务器使用私钥解密。）</li>
<li>“HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。”</li>
</ul>
</li>
<li><p>17.HTTPS通信步骤  </p>
<ul>
<li>“步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li>
<li>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li>
<li>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li>
<li>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</li>
<li>“步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li>
<li>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</li>
<li>步骤 7：客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li>
<li>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</li>
<li>步骤 9： 服务器同样发送 Finished 报文。</li>
<li>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</li>
<li>步骤 11： 应用层协议通信，即发送 HTTP 响应。</li>
<li>“步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。”</li>
</ul>
</li>
<li><p>18.“Cookie 来管理 Session”</p>
<ul>
<li>步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li>
<li>步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。</li>
<li>“步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。”</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E5%8D%8F%E8%AE%AE/HTTP/HTTP%E5%9B%BE%E8%A7%A3/" data-id="ckupl1rs500256ruphaxf5r4u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/中间件/MySQL/MySQL事务了解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E4%BA%86%E8%A7%A3/" class="article-date">
  <time datetime="2021-10-13T13:28:21.196Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MySQL事务了解"><a href="#MySQL事务了解" class="headerlink" title="MySQL事务了解"></a>MySQL事务了解</h2><p>​    上次使用了最基本的MySQL，只是简单的查询一个表中的数据，这次练习一下事务。开始。</p>
<p>​    MySQL有四层架构，分别为：<strong>连接层</strong>、<strong>服务层</strong>、<strong>引擎层</strong>、<strong>存储层</strong>。这四层的作用如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200608233609217.png" alt="image-20200608233609217"></p>
<p>​    需要注意的是，事务的执行是在引擎层，并不是服务层。目前使用最广泛的就是InnoDB，其他的引擎很少有支持事务的。</p>
<p>​    事务的特性有四个。<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>、<strong>持久性</strong>。四个特性简称为<strong>ACID</strong>，其含义和解释如下：</p>
<ul>
<li>原子性：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。</li>
<li>一致性：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。</li>
<li>隔离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
<li>持久性：当事务正确完成后，它对于数据的改变是永久性的。</li>
</ul>
<p>​    MySQL中的事务为了保证原子性，通过undo log日志来进行事务的撤销和数据的回滚。一致性则是MySQL中最终追求的目标，需要其他三个特性的支持。为了保持隔离性，MySQL中使用锁来对数据进行保护和同步。持久性则是使用InnoDB存储引擎中的redo log日志来实现的。下面分别介绍。</p>
<ul>
<li><p>undo log 日志。回滚日志的作用就是对数据进行回滚，属于逻辑日志。它对SQL语句执行相关的信息进行记录。当发生回滚时，InnoDB引擎会根据undo log日志中的记录做与之前相反的工作。比如对于每个数据插入操作（insert），回滚时会执行数据删除操作（delete）。</p>
</li>
<li><p>说锁之前先说一下MySQL中的数据存储形式，分为：数据库、数据表、数据页、行。各个形式如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612170140499.png" alt="image-20200612170140499"></p>
<p>MySQL中的锁有下面几种：行锁、表锁、页锁。粒度分别如下：</p>
<ul>
<li><p>行锁：粒度最小的锁，表示只针对当前操作的行进行加锁；</p>
</li>
<li><p>表锁：粒度最大的锁，表示当前的操作对整张表加锁；</p>
</li>
<li><p>页锁：粒度介于行级锁和表级锁中间的一种锁，表示对页进行加锁；</p>
</li>
</ul>
<p>表锁因为锁定的是整张表，所以并发性比较差，行锁如果过多，占用的资源比较多。</p>
<p>涉及到锁了，就要提及数据的读写问题了，读写问题有三类：脏读、不可重复读、幻读。</p>
<ul>
<li><p>脏读。当前事务中读到其他事务未提交的数据，也就是脏数据。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202259136.png" alt="image-20200612202259136"></p>
</li>
<li><p>不可重复读。在事务A中先后两次读取同一个数据，但是两次读取的结果不一样。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202326662.png" alt="image-20200612202326662"></p>
</li>
<li><p>幻读。在事务A中按照某个条件先后两次查询数据库，两次查询结果的行数不同，这种现象称为幻读。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202505995.png" alt="image-20200612202505995"></p>
</li>
</ul>
<p>根据这些问题产生了四种隔离级别，如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202611299.png" alt="image-20200612202611299"></p>
<p>然后就是MVCC（多版本的并发控制协议）相当于git，这个可以解决脏读和不可重复读读问题。这个放在后面讲吧。</p>
</li>
<li><p>redo log日志。重做日志是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。InnoDB引擎对数据的更新，是先将更新记录写入redo log日志，然后会在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的<strong>预写式技术（Write Ahead logging）</strong>。这种技术可以大大减少IO操作的频率，提升数据刷新的效率。redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑，比如”给ID=2这一行的a字段加1 “。binlog日志中的内容是二进制的，根据日记格式参数的不同，可能基于SQL语句、基于数据本身或者二者的混合。一般常用记录的都是SQL语句。详细执行步骤如下：（在对redo log写入时有两个阶段的提交，一是binlog写入之前<code>prepare</code>状态的写入，二是binlog写入之后<code>commit</code>状态的写入。）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612212946695.png" alt="image-20200612212946695"></p>
<p>其实是看了一篇博客，详细了了解了事务的原理和关于MySQL的一些信息。链接如下：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HQh_HpbtvJv6Y5k3OAlfsQ">https://mp.weixin.qq.com/s/HQh_HpbtvJv6Y5k3OAlfsQ</a></p>
<p>后面也回简单写一个demo，具体把这些概念了解一下。就这样吧，结束。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E4%BA%86%E8%A7%A3/" data-id="ckupl1rs1001y6rup958pd2xx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/中间件/MySQL/MySQL相关知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2021-10-13T13:28:21.196Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL知识点"><a href="#MySQL知识点" class="headerlink" title="MySQL知识点"></a>MySQL知识点</h1><h2 id="MySQL基础知识"><a href="#MySQL基础知识" class="headerlink" title="MySQL基础知识"></a>MySQL基础知识</h2><h3 id="MySQL查询流程"><a href="#MySQL查询流程" class="headerlink" title="MySQL查询流程"></a>MySQL查询流程</h3><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210719230933044.png" alt="image-20210719230933044"></p>
<p>​    分为server层和存储层，innodb就是位于存储层，主要负责对于磁盘的读写。server层主要就是mysql的一些基础服务，以查询sql为例，先是连接器管理连接，然后分析器分析语法是否有错误，没有错误查询缓存，缓存不存在将sql优化，最后调用执行器查询结果。</p>
<h3 id="MySQL中锁的相关知识点"><a href="#MySQL中锁的相关知识点" class="headerlink" title="MySQL中锁的相关知识点"></a>MySQL中锁的相关知识点</h3><p>​    数据库中分为三种情况</p>
<p>​    读-读：没有对数据进行影响，不需要操作。</p>
<p>​    写-写：需要对操作加锁。</p>
<p>​    读-写：会出现脏读、幻读。所以要对写操作加锁。</p>
<ul>
<li>表级锁：开销小，加锁快。不会出现死锁，锁颗粒度大，也就导致发生冲突概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢。会出现死锁，锁颗粒度小，锁的冲突比较低，并发度最高。</li>
<li>页面锁（BDB引擎）：开销介于表级锁和行级锁之间，会出现死锁，锁颗粒度一般，并发度一般。</li>
<li>共享锁(Shared Locks)：简称S锁，在事务要读取一条记录时，需要先获取该记录的S锁。S锁可以在同一时刻被多个事务同时持有。</li>
<li>排他锁(Exclusive Locks)：简称X锁，在事务要改动一条记录时，需要先获取该记录的X锁。X锁在同一时刻最多只能被一个事务持有。</li>
</ul>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul>
<li><p>意向共享锁(IS锁)：当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加一个意向共享锁(IS锁)，主要是快速查询表中记录有没有被上锁，提升效率。</p>
</li>
<li><p>意向排他锁(IX锁)：和上面的类似，只不过是排他锁。</p>
</li>
<li><p>自增锁(AUTO-INC锁)：在执行插入语句的时先加上表级别的AUTO-INC锁，插入执行完成后立即释放锁。无法确定插入多少记录时使用。</p>
</li>
<li><p>轻量级锁：在插入语句生成AUTO_INCREMENT值时先才获取这个轻量级锁，然后在AUTO_INCREMENT值生成之后就释放轻量级锁。确定插入多少列时使用。</p>
</li>
</ul>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614213241155.png" alt="image-20210614213241155"></p>
<ul>
<li>记录锁(Record Locks) 所谓记录，就是指聚簇索引中真实存放的数据，比如上面的1、4、7、10都是记录。</li>
<li>间隙锁(Gap Locks) 间隙指的是两个记录之间逻辑上尚未填入数据的部分，比如上述的(1,4)、(4,7)等。</li>
<li>临键锁(Next-Key Locks) 临键指的是间隙加上它右边的记录组成的左开右闭区间。比如上述的(1,4]、(4,7]等。</li>
</ul>
<h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><p>​    数据引擎常用的四种</p>
<ul>
<li>InnoDB：InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。<ul>
<li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。</li>
<li>InnoDB是为处理巨大数据量的最大性能设计。</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。</li>
<li>InnoDB被用在众多需要高性能的大型数据库站点上。</li>
</ul>
</li>
<li>MyISAM：MyISAM基于ISAM存储引擎，并对其进行扩展。MyISAM拥有较高的插入、查询速度，但不支持事物。<ul>
<li>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持。</li>
<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。</li>
<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>
<li>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</li>
</ul>
</li>
</ul>
<h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><p>​    事务包含四大特性，即<strong>原子性（Atomicity）</strong>、<strong>一致性（Consistency）</strong>、<strong>隔离性（Isolation）</strong>和<strong>持久性（Durability）</strong>(ACID)。</p>
<ul>
<li>原子性（Atomicity） 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的。 </li>
<li>一致性（Consistency） 一致性是指数据库的完整性约束没有被破坏，在事务执行前后都是合法的数据状态。这里的一致可以表示数据库自身的约束没有被破坏，比如某些字段的唯一性约束、字段长度约束等等；还可以表示各种实际场景下的业务约束，比如上面转账操作，一个账户减少的金额和另一个账户增加的金额一定是一样的。应用系统从一个正确的状态到另一个正确的状态。</li>
<li> 隔离性（Isolation） 隔离性指的是多个事务彼此之间是完全隔离、互不干扰的。隔离性的最终目的也是为了保证一致性。</li>
<li> 持久性（Durability） 持久性是指只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态。</li>
</ul>
<h4 id="关于事务的其他知识点"><a href="#关于事务的其他知识点" class="headerlink" title="关于事务的其他知识点"></a>关于事务的其他知识点</h4><ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 insert,update,delete 语句</li>
<li>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</li>
</ul>
<h3 id="MySQL中的隔离级别"><a href="#MySQL中的隔离级别" class="headerlink" title="MySQL中的隔离级别"></a>MySQL中的隔离级别</h3><h4 id="出现数据错乱的情况"><a href="#出现数据错乱的情况" class="headerlink" title="出现数据错乱的情况"></a>出现数据错乱的情况</h4><ul>
<li>脏写：脏写是指一个事务修改了其它事务未提交的数据。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614201951702.png" alt="image-20210614201951702"></p>
<ul>
<li>脏读：脏读是指一个事务读到了其它事务未提交的数据。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202018063.png" alt="image-20210614202018063"></p>
<ul>
<li>不可重复读：不可重复读指的是在一个事务执行过程中，读取到其它事务已提交的数据，导致两次读取的结果不一致。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202120848.png" alt="image-20210614202120848"></p>
<ul>
<li>幻读：幻读是指的是在一个事务执行过程中，读取到了其他事务新插入数据，导致两次读取的结果不一致。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202228292.png" alt="image-20210614202228292"></p>
<h4 id="MySQL中的隔离级别-1"><a href="#MySQL中的隔离级别-1" class="headerlink" title="MySQL中的隔离级别"></a>MySQL中的隔离级别</h4><p>​    SQL中隔离级别有四种：</p>
<ul>
<li>READ UNCOMMITTED：未提交读。 就是一个事务可以读取另一个未提交事务的数据。</li>
<li>READ COMMITTED：已提交读。 就是事务要等另一个事物提交后才能读取数据</li>
<li>REPEATABLE READ：可重复读。 就是在开始读取数据（事务开启）时，不再允许修改操作</li>
<li>SERIALIZABLE：串行化。事务串行化顺序执行，可以避免脏读，不可重复读与幻读。（但是效率低）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读（READ UNCOMMITTED）</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">已提交读（READ COMMITTED）</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">可重复读（REPEATABLE READ）</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">false（InnoDB为true）</td>
</tr>
<tr>
<td align="center">串行化（SERIALIZABLE）</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
</tbody></table>
<h4 id="MySQL的处理办法（MVCC）"><a href="#MySQL的处理办法（MVCC）" class="headerlink" title="MySQL的处理办法（MVCC）"></a>MySQL的处理办法（MVCC）</h4><p>​    MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。主要实现有两个手段：版本链和ReadView。</p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>​    对每条记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。修改一行记录时，都会将本次的事务ID和undo日志记录下来。undo日志里面则是存放的旧值。</p>
<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><p>​    ReadView包含四个内容：</p>
<ul>
<li>m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</li>
<li>min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。</li>
<li>max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。</li>
<li>creator_trx_id：表示生成该ReadView的事务的事务id。</li>
</ul>
<p>流程：</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
<p>​    READ COMMITTED（读提交）在每次读取数据前都会生成一个ReadView，这样就能保证每次都能读到其它事务已提交的数据。</p>
<p>​    REPEATABLE READ （可重复读）只在第一次读取数据时生成一个ReadView，这样就能保证后续读取的结果完全一致。</p>
<h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>​    MySQL中日志有二进制日志（binlog）、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种日志：redo log（重做日志）和undo log（回滚日志）。</p>
<h4 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h4><p>​    重做日志（redo log）是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。</p>
<p>​    InnoDB引擎对数据的更新，是先将更新记录写入redo log日志，然后会在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的预写式技术（Write Ahead logging）。</p>
<p>​    redo log日志的大小是固定的，为了能够持续不断的对更新记录进行写入，在redo log日志中设置了两个标志位置，checkpoint和write_pos，分别表示记录擦除的位置和记录写入的位置。</p>
<p>​    当write_pos标志到了日志结尾时，会从结尾跳至日志头部进行重新循环写入。所以redo log的逻辑结构并不是线性的，而是可看作一个圆周运动。write_pos与checkpoint中间的空间可用于写入新数据，写入和擦除都是往后推移，循环往复的。</p>
<p>​    缓冲池<code>buffer pool</code>是在内存中分配的一个区域，包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当数据修改时，除了修改buffer pool中的数据，还会在redo log中记录这次操作；当事务提交时，会根据redo log的记录对数据进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复，从而保证了事务的持久性，使得数据库获得crash-safe能力。</p>
<p>​    redo log日志可分为两个部分，一是存在易失性内存中的缓存日志redo log buff，二是保存在磁盘上的redo log日志文件redo log file。</p>
<p>​    为了确保每次记录都能够写入到磁盘中的日志中，每次将redo log buffer中的日志写入redo log file的过程中都会调用一次操作系统的fsync操作。（和redis中AOF备份类似）</p>
<h4 id="binlog（二进制日志）"><a href="#binlog（二进制日志）" class="headerlink" title="binlog（二进制日志）"></a>binlog（二进制日志）</h4><p>​    二进制日志binlog是服务层的日志，还被称为归档日志。binlog主要记录数据库的变化情况，内容包括数据库所有的更新操作。所有涉及数据变动的操作，都要记录进二进制日志中。因此有了binlog可以很方便的对数据进行复制和备份，因而也常用作主从库的同步。二进制日志的文件大小不固定，写完会切换下一个文件。</p>
<p>​    和redo log的区别：redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑。redo log是基于crash recovery，保证MySQL宕机后的数据恢复；而binlog是基于point-in-time recovery，保证服务器可以基于时间点对数据进行恢复，或者对数据进行备份。binlog是服务层的日志，因此所有引擎都能够使用。redo log是引擎层的日志，是InnoDB引擎持有。</p>
<p>​    MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。不仅如此，在对redo log写入时有两个阶段的提交，一是binlog写入之前<code>prepare</code>状态的写入，二是binlog写入之后<code>commit</code>状态的写入。</p>
<h4 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h4><p>​    回滚日志同样也是InnoDB引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。但是undo log不redo log不一样，它属于逻辑日志。它对SQL语句执行相关的信息进行记录。</p>
<h4 id="什么是双阶段提交"><a href="#什么是双阶段提交" class="headerlink" title="什么是双阶段提交"></a>什么是双阶段提交</h4><p>​    修改一条数据时，以innodb为例，innodb在内存中修改完毕后，将其写入redolog，状态标记为准备，然后返回结果，服务层将这次的修改写入binlog，标记事务完成，然后redolog将状态标记为提交，等待将其写入磁盘中。双阶段提交是为了保证两个日志中逻辑上的一致，同一条数据不会因为宕机出现混乱。</p>
<h3 id="MySQL中数据类型"><a href="#MySQL中数据类型" class="headerlink" title="MySQL中数据类型"></a>MySQL中数据类型</h3><p>​    MySQL中数据类型分为三大块，数值类型、日期和时间类型、字符串类型。</p>
<p>​    数值类型：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180123419.png" alt="image-20210617180123419"></p>
<p>​    日期和时间类型</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180149314.png" alt="image-20210617180149314"></p>
<p>​    字符串类型</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180214099.png" alt="image-20210617180214099"></p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="B-树概念"><a href="#B-树概念" class="headerlink" title="B+树概念"></a>B+树概念</h4><h5 id="选择B-实现的原因"><a href="#选择B-实现的原因" class="headerlink" title="选择B+实现的原因"></a>选择B+实现的原因</h5><p>​    因为Mysql查询的形式是有以下几种：1）查询特定数据。2）查询范围数据。</p>
<ul>
<li>hash表并不支持范围查询，其他平衡树也是对于范围查询很低效。</li>
<li>B树和B+树的区别就是：B+树的数据存储只在叶子节点。因为系统IO并不是需要什么就读取什么，而是会读取这块空间的周围存储。B树因为非叶子结点也存储数据，所以会造成多次的IO读取。B+树因为叶子结点是链表的形式，所以可以较少次的IO读取。</li>
<li>跳表比较适合内存空间存储，对于磁盘空间查询不友好。（也是没有利用磁盘缓存的特点）跳表的查询相对于B+树稍微差些。</li>
</ul>
<h5 id="B-树概念-1"><a href="#B-树概念-1" class="headerlink" title="B+树概念"></a>B+树概念</h5><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210615113558216.png" alt="image-20210615113558216"></p>
<ul>
<li>B+树非叶子节点上是不存储数据的，仅存储键值。键就是排序的因素，值就是直线下一个节点的地址。</li>
<li>B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值。</li>
<li>B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</li>
<li>根节点至少拥有两个子树</li>
<li>每个树节点最多拥有M个子树</li>
<li>每个树节点(除了根节点)拥有至少M/2个子树</li>
</ul>
<h5 id="B-树的性质"><a href="#B-树的性质" class="headerlink" title="B+树的性质"></a>B+树的性质</h5><ul>
<li>索引字段要尽量的小。因为索引字段过大，就会导致数据项变小，即B+树的阶数变小。导致B+树的高度变高，读取IO的次数也变多。</li>
<li>索引的最左匹配特性。因为B+树建立复合索引时是根据从左到右的方向来建立搜索树的，查询也是根据第一个字段来决定查询的方向，如果没有带第一个字段，就无法匹配。查到第一个字段后，这段数据的附近则是根据其他索引进行排序的。</li>
</ul>
<h4 id="MySQL中索引的分类"><a href="#MySQL中索引的分类" class="headerlink" title="MySQL中索引的分类"></a>MySQL中索引的分类</h4><ul>
<li><p>按照数据结构可以分为B+tree索引、Hash索引、Full-text索引。</p>
</li>
<li><p>B+tree索引：上面讲的差不多，有点就是查询快，读取IO磁盘的次数较低</p>
</li>
<li><p>Hash索引：单个查询可以快速，但是范围查询就很慢了</p>
</li>
<li><p>Full-text索引：full-text在mysql里仅有myisam支持它，而且支持full-text的字段只有char、varchar、text数据类型。full-text主要是用来代替like “%***%”效率低下的问题。</p>
<p>  按照物理存储可以分为：聚簇索引、二级索引（辅助索引或者非聚簇索引）</p>
</li>
<li><p>聚簇索引：聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。</p>
</li>
<li><p>非聚簇索引：二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。</p>
<p>  按照字段特性可以分类为：主键索引、普通索引、前缀索引。</p>
</li>
<li><p>主键索引：建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。</p>
</li>
<li><p>普通索引：建立在普通字段上的索引被称为普通索引。</p>
</li>
<li><p>前缀索引：前缀索引是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。</p>
</li>
<li><p>唯一索引：建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。</p>
<p>  按照字段个数可以分类为：单列索引、联合索引（复合索引、组合索引）。</p>
</li>
<li><p>单列索引：建立在单个列上的索引被称为单列索引。</p>
</li>
<li><p>联合索引：建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。</p>
</li>
</ul>
<h4 id="建立索引的几个原则"><a href="#建立索引的几个原则" class="headerlink" title="建立索引的几个原则"></a>建立索引的几个原则</h4><ul>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li>
<li>尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>在建立联合索引的时候，安排索引内的字段顺序的原则：1.如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。2.在必须维护两个重复索引时，这个时候需要考虑字段大小问题。</li>
<li></li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。</li>
</ul>
<h3 id="MySQL中的存储过程"><a href="#MySQL中的存储过程" class="headerlink" title="MySQL中的存储过程"></a>MySQL中的存储过程</h3><p>储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。特点有以下几点：</p>
<ul>
<li>存储过程能实现较快的执行速度。</li>
<li>存储过程允许标准组件是编程。</li>
<li>存储过程可被作为一种安全机制来充分利用。</li>
<li>存储过程能过减少网络流量。</li>
</ul>
<h3 id="SQL中的范式理解"><a href="#SQL中的范式理解" class="headerlink" title="SQL中的范式理解"></a>SQL中的范式理解</h3><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>​    在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 </p>
<p>​    所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<p>​    如：学生表中，有3个字段 学号 姓名 家庭地址(XXX省XXX市）,由于地址字段是可以再拆分的所以不满足第一范式。</p>
<p>​    改造为：学号 姓名 出生省份 出生城市既满足第一范式</p>
<h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>​    第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。<br>​    第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p>
<p>​    如：学生表中 有 学号 姓名 选课号 出生日期 成绩 五个字段， 其中学号为主键，成绩并不依赖与学号，所以不满足第二范式。应该删除选课号，然后构建一张选课表。</p>
<h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>​    满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 </p>
<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><ul>
<li>查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。(from后面跟多个表，通过where的形式做限定是内连接，只寻找两个表中都存在的数据)</li>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li>
<li>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li>
<li>MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。</li>
</ul>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>​    update 表名称 set 列名称=新值 where 更新条件;</p>
<ul>
<li>你可以同时更新一个或多个字段。</li>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以在一个单独表中同时更新数据。</li>
</ul>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><ul>
<li>如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li>
<li>你可以在 WHERE 子句中指定任何条件</li>
<li>您可以在单个表中一次性删除记录。</li>
</ul>
<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><ul>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以在 WHERE 子句中使用LIKE子句。</li>
<li>你可以使用LIKE子句代替等号 **=**。</li>
<li>LIKE 通常与 <strong>%</strong> 一同使用，类似于一个元字符的搜索。</li>
<li>你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</li>
<li>**%**：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</li>
<li>**_**：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。</li>
<li>**[]**：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</li>
<li><strong>[^]</strong> ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</li>
<li>查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。</li>
</ul>
<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n</span><br><span class="line"><span class="keyword">FROM</span> tables</span><br><span class="line">[<span class="keyword">WHERE</span> conditions]</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>]</span><br><span class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n</span><br><span class="line"><span class="keyword">FROM</span> tables</span><br><span class="line">[<span class="keyword">WHERE</span> conditions];</span><br></pre></td></tr></table></figure>

<p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p>
<ul>
<li><strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li>
<li><strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li>
<li>要注意UNION的两个查询条件返回结果要一致。</li>
<li>UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！</li>
<li>官网要求两个子查询列的名称和数据类型、和数目必须一致。但是数据类型和名称可以不一致也可以执行，只是后续又可能会出错。</li>
<li>UNION结果集的列名取自第一个SELECT语句的列名。</li>
<li>如果相应的SELECT列的数据类型不匹配，则UNION结果中的列的类型和长度将考虑所有SELECT语句检索的值。</li>
</ul>
<h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a><strong>ORDER BY</strong></h3><ul>
<li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li>
<li>你可以设定多个字段来排序。</li>
<li>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li>
<li>你可以添加 WHERE…LIKE 子句来设置条件。</li>
<li>如果字符集采用的是 utf8(万国码)，需要先对字段进行转码然后排序：<code>ORDER BY CONVERT(runoob_title using gbk);</code></li>
</ul>
<h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><p>GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。(count是统计，sum是求和)</p>
<h3 id="null值比较"><a href="#null值比较" class="headerlink" title="null值比较"></a>null值比较</h3><p>MySQL提供了三大运算符:用来对bull值比较</p>
<ul>
<li><strong>IS NULL:</strong> 当列的值是 NULL,此运算符返回 true。</li>
<li><strong>IS NOT NULL:</strong> 当列的值不为 NULL, 运算符返回 true。</li>
<li><strong>&lt;=&gt;:</strong> 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。</li>
<li>可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的控制语句"><a href="#事务的控制语句" class="headerlink" title="事务的控制语句"></a>事务的控制语句</h4><ul>
<li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li>
<li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>
<li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>
<li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li>
<li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>
<li>ROLLBACK TO identifier 把事务回滚到标记点；</li>
<li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>常用的函数，这个链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/mysql/mysql-functions.html">菜鸟网络</a> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span>[&#123;,<span class="operator">&lt;</span>expression<span class="operator">&gt;</span>...&#125;]</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], [&#123;,<span class="operator">&lt;</span>expression<span class="operator">&gt;</span>...&#125;]</span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<ul>
<li>首先，<code>PARTITION BY</code>子句将<code>FROM</code>子句生成的结果集划分为分区。<code>DENSE_RANK()</code>函数应用于每个分区。</li>
<li>其次，<code>ORDER BY</code> 子句指定<code>DENSE_RANK()</code>函数操作的每个分区中的行顺序。</li>
<li>与<code>RANK()</code>函数不同，<code>DENSE_RANK()</code>函数始终返回连续的排名值。</li>
</ul>
<ul>
<li><p>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。也可以使用OFFSET设定偏移量，你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</p>
</li>
<li><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。显示为一行，所以要对其他列进行聚合显示，求和或者求最大。</p>
</li>
<li><p>where后面的条件需要带上引号，单引号和双引号都可以。除了int和数字不需要带引号。</p>
</li>
<li><p>mysql没有full join，可以通过将左连接和右连接组合一起打到full join</p>
</li>
<li><p>各个SQL关键字执行的顺序</p>
<ol>
<li>FROM, including JOINs</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>WINDOW functions</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>UNION</li>
<li>ORDER BY</li>
<li>LIMIT and OFFSET</li>
</ol>
</li>
<li><p><code>count(1)和count（*）count（cloum）统计列值的数量时，会忽略空值，当括号内的值不可能为空时，就直接统计行数。count（1）和count（*）都是一样的，都是统计行数，都是根据索引来统计行数。</code></p>
</li>
<li><p>group by后面的having中的字段必须要查询到，如果相对表做个筛选，可以在group by前面添加where语句，having语句是对group by语句到补充。</p>
</li>
<li><p>in后面可以跟多个字段，和concat函数类似。</p>
</li>
<li><p>join当两个表中不匹配时，不返回任何行。</p>
</li>
<li><p>慢查询日志就是查询超过阈值的语句会被记录下来，一般的默认值就是10秒。这个可以设置。</p>
</li>
<li><p>CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result …] [ELSE result] END case的用法，一般用来做判断。</p>
</li>
<li><p>mod函数用来求余的，mod（3,2）返回1</p>
</li>
<li><p>COALESCE取值的，COALESCE（1，2）如果1为null，就取2。</p>
</li>
<li><p><code>LEFT(Str,length)</code>函数是一个字符串函数，它返回具有指定长度的字符串的左边部分。str是字符串，length是要截取的长度。</p>
</li>
<li><p>ROW_NUMBER()是一个窗口函数或分析函数，它为从1开始应用的每一行分配一个序号。用例：id - row_number() over(order by id) as rk</p>
</li>
<li><p>with tmp as (select * from table） 可以将查询结果作为临时表，子查询互相之间是不能访问的。</p>
</li>
<li><p><code>CROSS JOIN</code>子句从连接的表返回行的笛卡儿乘积。</p>
</li>
</ul>
<h2 id="MySQL语句优化"><a href="#MySQL语句优化" class="headerlink" title="MySQL语句优化"></a>MySQL语句优化</h2><p>​    大概30点个点。</p>
<ul>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li>尽量不要使用like进行匹配，要不然也会导致全表扫描。</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描。</li>
<li>如果在 where 子句中使用参数，也会导致全表扫描。</li>
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</li>
<li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
<li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</li>
<li>不要写一些没有意义的查询，如需要生成一个空表结构。</li>
<li>很多时候用 exists 代替 in 是一个好的选择。</li>
<li>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</li>
<li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>
<li>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</li>
<li>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li>
<li>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</li>
<li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
<li>临时表并不是不可使用，适当地使用它们可以使某些例程更有效。</li>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</li>
<li>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</li>
<li>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li>
<li>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</li>
<li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</li>
<li>尽量避免大事务操作，提高系统并发能力。</li>
<li>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</li>
<li>MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。</li>
<li>你可以在 MySQL 数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。</li>
</ul>
<h4 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h4><p>首先是通过慢查询日志来记录数据库中查询比较慢的SQL</p>
<p>然后是用explain来判断语句使用了哪些索引，以及一些基础的信息。看看和自己的预期是否一致</p>
<p>最后做对应的修改，例如增加索引或者修正索引的顺序。</p>
<h3 id="MySQL中问到的问题"><a href="#MySQL中问到的问题" class="headerlink" title="MySQL中问到的问题"></a>MySQL中问到的问题</h3><ul>
<li>MySQL中优化的场景和具体的做法。</li>
</ul>
<p>​    举个例子：我们有一个表，里面存储了点位的一些信息，建立了一个联合索引，点位id和设备id。有一次需要执行一条语句，查询某个设备的所有模拟信号点位信息。where后面的语句就是point_id=1 and mn&gt;0 and equipment_id=2.但是后来发现执行的效率不太对，通过explain查询发现只了一个索引，就是point_id，按理说应该走equipment_id。因为最左匹配原则，遇到范围查询时停止使用索引，所以最后造成这样的结果，可以调整sql的顺序，将范围查询放到后面。这样的例子其实在网上挺多的，这个需要你平时写sql多注意和多总结，遇到不正常的SQL去解析查询的流程。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>//MySQL中锁的分类，行级锁、排查锁、共享锁</p>
<p>// MySQL中的隔离级别</p>
<p>//事务</p>
<p>//索引</p>
<p>//数据类型</p>
<p>//B+树和B-树</p>
<p>//范式（了解即可）</p>
<p>//优化MySQL</p>
<p>//存储过程</p>
<p>//慢查询日志</p>
<p>慢SQL优化</p>
<p>//MySQL的事务文件就是redolog和undolog</p>
<p>//Mysql binlog和Relog</p>
<p>其他</p>
<p>分布式事务</p>
<p>需要学习窗口函数</p>
<p>ranking&gt;=countNum/2 and ranking&lt;=countNum/2+1</p>
<p>select Id,Company,Salary<br>from<br>(<br>select Id,Company,Salary,<br>row_number()over(partition by Company order by Salary)as ranking,<br>count(Id) over(partition by Company)as cnt<br>from Employee<br>)a<br>where ranking&gt;=cnt/2 and ranking&lt;=cnt/2+1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ckupl1rs2001z6rup5esi4jnf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E6%8D%AE%E4%BD%8D%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E8%AE%B0%E5%BD%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>