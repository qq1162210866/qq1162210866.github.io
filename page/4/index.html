<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-qq1162210866.github.io/博客/中间件/MySQL/SQL语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/SQL%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2021-10-13T13:28:21.196Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一些重要的SQL命令："><a href="#一些重要的SQL命令：" class="headerlink" title="一些重要的SQL命令："></a>一些重要的SQL命令：</h3><ul>
<li><strong>SELECT</strong> - 从数据库中提取数据</li>
<li><strong>UPDATE</strong> - 更新数据库中的数据</li>
<li><strong>DELETE</strong> - 从数据库中删除数据</li>
<li><strong>INSERT INTO</strong> - 向数据库中插入新数据</li>
<li><strong>CREATE DATABASE</strong> - 创建新数据库</li>
<li><strong>ALTER DATABASE</strong> - 修改数据库</li>
<li><strong>CREATE TABLE</strong> - 创建新表<ul>
<li><strong>NOT NULL</strong> - 指示某列不能存储 NULL 值。</li>
<li><strong>UNIQUE</strong> - 保证某列的每行必须有唯一的值。</li>
<li><strong>PRIMARY KEY</strong> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><strong>FOREIGN KEY</strong> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><strong>CHECK</strong> - 保证列中的值符合指定的条件。</li>
<li><strong>DEFAULT</strong> - 规定没有给列赋值时的默认值。</li>
</ul>
</li>
<li><strong>ALTER TABLE</strong> - 变更（改变）数据库表</li>
<li><strong>DROP TABLE</strong> - 删除表</li>
<li><strong>CREATE INDEX</strong> - 创建索引（搜索键）</li>
<li><strong>DROP INDEX</strong> - 删除索引</li>
</ul>
<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ul>
<li>SQL 使用单引号来环绕文本值，如果是数值字段，请不要使用引号。</li>
<li>通过使用 SQL，可以为表名称或列名称指定别名。基本上，创建别名是为了让列名称的可读性更强。</li>
<li>更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。</li>
</ul>
<h3 id="关键字用法"><a href="#关键字用法" class="headerlink" title="关键字用法"></a>关键字用法</h3><ul>
<li><p>SELECT DISTINCT 语句。在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>DISTINCT 关键词用于返回唯一不同的值。</p>
</li>
<li><p>WHERE语句。WHERE 子句用于提取那些满足指定条件的记录。</p>
<ul>
<li>BETWEEN：在某个范围内<code>Select * from emp where sal between 1500 and 3000;</code></li>
<li>LIKE：搜索某种模式<code>Select * from emp where ename like &#39;M%&#39;;</code>（通配符类似正则表达式）</li>
<li>MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。<code>SELECT * FROM Websites WHERE name REGEXP &#39;^[GFs]&#39;;</code></li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210601165337182.png" alt="image-20210601165337182"></p>
<ul>
<li>IN：指定针对某个列的多个可能值<code>Select * from emp where sal in (5000,3000,1500);</code></li>
</ul>
</li>
<li><p>AND &amp; OR 运算符。如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
</li>
<li><p>ORDER BY关键字。 关键字用于对结果集按照一个列或者多个列进行排序。(多列时，先排前面字段，再拍后面字段)ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。<code>SELECT * FROM Websites ORDER BY alexa DESC;</code></p>
</li>
<li><p>SELECT TOP 子句。MYSQL中为LIMIT。<code>SELECT * FROM Websites LIMIT 2;</code>SELECT TOP 子句用于规定要返回的记录的数目。</p>
</li>
<li><p>JOIN语句。SQL join 用于把来自两个或多个表的行结合起来。<strong>on</strong> 条件是在生成临时表时使用的条件，它不管 <strong>on</strong> 中的条件是否为真，都会返回左边表中的记录。<strong>where</strong> 条件是在临时表生成好后，再对临时表进行过滤的条件。</p>
<ul>
<li><strong>INNER JOIN</strong>：如果表中有至少一个匹配，则返回行</li>
<li><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行。LEFT JOIN语句后面的表被称为右表。</li>
<li><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li>
<li><strong>FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li>
</ul>
</li>
<li><p>UNION 操作符合并两个或多个 SELECT 语句的结果。UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。UNION ALL用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p>
</li>
<li><p>SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。</p>
</li>
<li><p>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p>
</li>
<li><p>TRUNCATE TABLE 语句。仅仅删除表内的数据，但并不删除表本身。</p>
</li>
<li><p>AUTO INCREMENT 字段。我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">LastName <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">FirstName <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h3><ul>
<li>AVG() 函数返回数值列的平均值。</li>
<li>COUNT() 函数返回匹配指定条件的行数。<ul>
<li>COUNT(column_name) 函数返回指定列的值的数目</li>
<li>COUNT(*) 函数返回表中的记录数</li>
<li>COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目</li>
</ul>
</li>
<li>FIRST() 函数返回指定的列中第一个记录的值。</li>
<li>LAST() 函数返回指定的列中最后一个记录的值。</li>
<li>MAX() 函数返回指定列的最大值。</li>
<li>MIN() 函数返回指定列的最小值。</li>
<li>SUM() 函数返回数值列的总数。</li>
<li>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</li>
<li>HAVING 子句。在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。HAVING 子句可以让我们筛选分组后的各组数据。</li>
<li>EXISTS 运算符用于判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。</li>
<li>UCASE() 函数把字段的值转换为大写。</li>
<li>LCASE() 函数把字段的值转换为小写。</li>
<li>MID() 函数用于从文本字段中提取字符。</li>
<li>LEN() 函数返回文本字段中值的长度。</li>
<li>ROUND() 函数用于把数值字段舍入为指定的小数位数。</li>
<li>NOW() 函数返回当前系统的日期和时间。</li>
<li>FORMAT() 函数用于对字段的显示进行格式化。</li>
<li>DATEDIFF() 函数返回两个日期之间的天数。用前一个参数减去后一个参数。</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p># Write your MySQL query statement below</p>
<p>select  count(distinct sender_id send_to_id)/count(distinct requester_id accepter_id) from FriendRequest,RequestAccepted</p>
<p>select product_id,sum(rest),sum(paid),sum(canceled),sum(refunded) from Invoice group by product_id;</p>
<p>select distinct</p>
<p>a.follower,</p>
<p>count(f.followee) as num</p>
<p>from </p>
<p>(select distinct followee as follower</p>
<p>from follow </p>
<p>where</p>
<p>followee in (select distinct follower from follow)) as a</p>
<p>left join follow as f on a.follower = f.followee</p>
<p>group by f.followee</p>
<p>order by a.follower</p>
<p>select distinct</p>
<p>a1.player_id</p>
<p>from Activity as a1,Activity as a2</p>
<p>where a1.event_date = a2.event_date-1</p>
<p>select </p>
<p>b.book_id</p>
<p>from Orders as o</p>
<p>left join Books as b</p>
<p>on o.book_id = b.book_id</p>
<p>where datediff(2019-06-23,b.available_from)&gt;30 </p>
<p>and datediff(o.dispatch_date,2018-06-23)&gt;0</p>
<p>group by book_id</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/SQL%E8%AF%AD%E6%B3%95/" data-id="ckupl1rs200206rup8fl4biv3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/中间件/PostgreSQL/Centos安装Postgresql和posogis插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/PostgreSQL/Centos%E5%AE%89%E8%A3%85Postgresql%E5%92%8Cposogis%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2021-10-13T13:28:21.196Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Centos安装Postgresql和posogis插件"><a href="#Centos安装Postgresql和posogis插件" class="headerlink" title="Centos安装Postgresql和posogis插件"></a>Centos安装Postgresql和posogis插件</h2><p>​    公司临时让装一个数据库，正好是之前了解过的Postgresql，顺带把之前的安装的坑填。并且这次也安装了插件。下面直接开始。</p>
<p>​    安装的插件有：fuzzystrmatch、postgis、uuid-ossp。其中uuid-ossp需要再初始化数据库的时候指定，剩下的都可以在安装完数据库后进行安装。下面直接上教程，不逼逼了。很详细。</p>
<ul>
<li>下载postgresql官方压缩包，选择对应的版本。地址：<a target="_blank" rel="noopener" href="https://www.postgresql.org/ftp/source/">https://www.postgresql.org/ftp/source/</a>，下载tar.gz</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806103650919.png" alt="image-20200806103650919"></p>
<ul>
<li><p>解压到指定目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf postgresql-9.6.10.tar -C /home/program/soft/</span><br></pre></td></tr></table></figure></li>
<li><p>执行配置命令，中间出现部分错误，按照指示安装对应插件即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install uuid uuid-devel</span><br><span class="line">./configure --prefix=/bigdata/work/postgresql --with-uuid=ossp</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806104151703.png" alt="image-20200806104151703"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install readline-devel</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806104250201.png" alt="image-20200806104250201"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zlib-devel</span><br></pre></td></tr></table></figure>

<p>出现下面命令即可以执行make命令。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806104818429.png" alt="image-20200806104818429"></p>
</li>
<li><p>执行make命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>出现以下截图即安装成功：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806105752457.png" alt="image-20200806105752457"></p>
</li>
<li><p>后续的配置</p>
<p>创建一个postgres用户，创建数据目录和日志目录，将权限给这个用户。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adduser postgres</span><br><span class="line">mkdir /bigdata/work/postgresql/data</span><br><span class="line">chown -R postgres:postgres /bigdata/work/postgresql/data</span><br></pre></td></tr></table></figure></li>
<li><p>添加环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PGDATA=/bigdata/work/postgresql/data</span><br><span class="line"><span class="built_in">export</span> PGHOME=/bigdata/work/postgresql</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PGHOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li>
<li><p>初始化数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - postgres</span><br><span class="line">initdb</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806111651152.png" alt="image-20200806111651152"></p>
</li>
<li><p>修改两个配置，使用root用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /bigdata/work/postgresql/data/pg_hba.conf</span><br><span class="line">vim /bigdata/work/postgresql/data/postgresql.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806141658615.png" alt="image-20200806141658615"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806141724073.png" alt="image-20200806141724073"></p>
</li>
<li><p>将启动脚本复制到linux中去管理。</p>
<p>从postgresql中的解压目录复制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp contrib/start-scripts/linux  /etc/init.d/postgresql</span><br><span class="line">vim /etc/init.d/postgresql</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200807090320846.png" alt="image-20200807090320846"></p>
</li>
<li><p>授予权限，设置开机自启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/postgresql</span><br><span class="line">chkconfig --add postgresql</span><br></pre></td></tr></table></figure></li>
<li><p>启动，设置密码。</p>
<p>直接使用root用户启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service postgresql start</span><br></pre></td></tr></table></figure>

<p>使用postgrees用户查看进程信息</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806142450969.png" alt="image-20200806142450969"></p>
<p>使用自带的工具连接数据库，设置密码。可以讲这个设置为系统环境变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bigdata/work/postgresql/bin/psql</span><br><span class="line">\password</span><br></pre></td></tr></table></figure></li>
<li><p>使用远程工具连接测试</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806142714037.png" alt="image-20200806142714037"></p>
</li>
<li><p>安装Postgis插件</p>
<ul>
<li>先做准备工作，设置postgres用户的环境变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">su - postgres</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PGDATA=/bigdata/work/postgresql/data</span><br><span class="line"><span class="built_in">export</span> PGHOME=/bigdata/work/postgresql</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PGHOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$PGHOME</span>/lib:/lib64:/usr/lib64:/usr/<span class="built_in">local</span>/lib64:/lib:/usr/lib:/usr/<span class="built_in">local</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装需要依赖包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python-devel perl-ExtUtils-Embed python-devel gcc-c++ openssl-devel readline readline-devel bzip2 zlib zlib-devel openssl openssl-devel pam pam-devel libxml2 libxml2-devel libxslt libxslt-devel openldap openldap-devel libgeos-dev libproj-dev libgdal-dev xsltproc docbook-xsl docbook-xml imagemagick libmagickcore-dev dblatex tcl tcl-devel unixODBC unixODBC-devel libpng12 libpng12-devel</span><br></pre></td></tr></table></figure>

<ul>
<li><p>下载其他依赖包</p>
<ul>
<li><p>安装Proj4</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.osgeo.org/proj/proj-4.9.3.tar.gz</span><br><span class="line">  tar -xf proj-4.9.3.tar.gz</span><br><span class="line">  <span class="built_in">cd</span> proj-4.9.3</span><br><span class="line">  ./configure --prefix=/bigdata/work/postgresql/plugin/proj</span><br><span class="line">  make </span><br><span class="line">  make install</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;/bigdata/work/postgresql/plugin/proj/lib&quot;</span> &gt; /etc/ld.so.conf.d/proj-4.9.3.conf</span><br><span class="line">  ldconfig</span><br></pre></td></tr></table></figure></li>
<li><p>安装GEOS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  wget http://download.osgeo.org/geos/geos-3.6.1.tar.bz2</span><br><span class="line">  tar -jxf geos-3.6.1.tar.bz2</span><br><span class="line">  <span class="built_in">cd</span> geos-3.6.1</span><br><span class="line">serivice jj</span><br><span class="line">  make</span><br><span class="line">  make install</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;/bigdata/work/postgresql/plugin/geos/lib&quot;</span> &gt; /etc/ld.so.conf.d/geos-3.6.1.conf</span><br><span class="line">  ldconfig</span><br></pre></td></tr></table></figure></li>
<li><p>安装GDAL</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.osgeo.org/gdal/2.1.2/gdal-2.1.2.tar.gz</span><br><span class="line">tar -xf gdal-2.1.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gdal-2.1.2</span><br><span class="line">./configure --prefix=/bigdata/work/postgresql/plugin/gdal</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/bigdata/work/postgresql/plugin/gdal/lib&quot;</span> &gt; /etc/ld.so.conf.d/gdal-2.1.2.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure></li>
<li><p>安装PostGIS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.osgeo.org/postgis/<span class="built_in">source</span>/postgis-2.2.5.tar.gz</span><br><span class="line">tar -xf postgis-2.2.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> postgis-2.2.5</span><br><span class="line">./configure --prefix=/bigdata/work/postgresql/plugin/postgis --with-pgconfig=/bigdata/work/postgresql/bin/pg_config --with-geosconfig=/bigdata/work/postgresql/plugin/geos/bin/geos-config --with-gdalconfig=/bigdata/work/postgresql/plugin/gdal/bin/gdal-config --with-projdir=/bigdata/work/postgresql/plugin/proj</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200807094928599.png" alt="image-20200807094928599"></p>
<p>解决这个问题。需要将postgresql的lib目录导入ld.so.conf.d</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">/bigdata/work/postgresql/lib</span><br><span class="line"></span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>验证插件正常安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">su postgres</span><br><span class="line">psql</span><br><span class="line">create database postgis;</span><br><span class="line">\c postgis</span><br><span class="line">CREATE EXTENSION postgis;</span><br><span class="line">CREATE EXTENSION postgis_topology;</span><br><span class="line">CREATE EXTENSION fuzzystrmatch;</span><br><span class="line">CREATE EXTENSION postgis_tiger_geocoder;</span><br><span class="line">CREATE EXTENSION <span class="string">&quot;uuid-ossp&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200807150426313.png" alt="image-20200807150426313"></p>
<p>即成功。</p>
<p>fuzzystrmatch是在源码中的有的，但是没有包含编译的时候没有包含进去，需要make一下。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> contrib/fuzzystrmatch/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>UUID-OSSP插件也是</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> contrib/uuid-ossp/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>  如下图：</p>
<p>  <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200807151502098.png" alt="image-20200807151502098"></p>
</li>
</ul>
<p>​    剩下就没有什么可以讲的了，按照步骤来就可以了。以为一些centos的依赖指定了版本，如果你的PostgreSQL版本和我的不一致，这一点需要注意。如何查询对应的版本需要到网上搜一搜。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/PostgreSQL/Centos%E5%AE%89%E8%A3%85Postgresql%E5%92%8Cposogis%E6%8F%92%E4%BB%B6/" data-id="ckupl1rs300216rup4wk5bnl0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/中间件/RabbitMQ/RabbitMQ基础知识了解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BA%86%E8%A7%A3/" class="article-date">
  <time datetime="2021-10-13T13:28:21.196Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RabbitMQ基础知识了解"><a href="#RabbitMQ基础知识了解" class="headerlink" title="RabbitMQ基础知识了解"></a>RabbitMQ基础知识了解</h2><p>​    公司前一段时间重构了一个老项目的代码，转为了SpringBoot，但是中间RabbitMQ在转换的时候我问了大佬一个很弱智的问题，所以抽了空，了解一下这个之前一直用但是不懂原理的中间件。</p>
<p>​    RabbitMQ是基于AMQP（高级消息队列协议）开发的一个消息队列产品，相当于一个软件，所以其实要讲的AMQP，下面也就简单介绍一下AMQP，然后在介绍中间的一些组件。</p>
<p>​    AMQP高级消息队列协议）是一种消息传递协议，使一致的客户端应用程序可以与一致的消息传递中间件代理进行通信。消息发布到<em>exchanges</em>（交换机），交换机类似于邮局或邮箱。然后，交换机使用称为<em>bindings</em>（绑定）的规则将消息副本分发到队列中。然后，代理要么将消息传递给订阅了队列的消费者，要么消费者按需从队列中获取/拉取消息。这就是AMQP的一些基础概念，下面就来一一叙述中间提及到的概念。概念如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200924085039570.png" alt="image-20200924085039570"></p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>​    交换机是接收消息的AMQP中的一种实体。交换记接收一条消息并将其路由到零个或多个队列中。使用的路由算法取决于交换机的类型和绑定的规则。交换机在RabbitMQ官网上只有四种，但是实际使用中还多了一个默认的类型。四种交换机名称分别为：Direct exchange（直接交换）、Fanout exchange（扇形交换）、Topic exchange（主题交换）、Headers exchange（标头交换）。下面就说说实际使用到的五种交换。</p>
<ul>
<li>默认交换。默认交换是一种特殊的直接交换，特殊的地方在于：默认交换是预先声明的不带名称（空字符串）的直接交换。创建的每个队列都使用与队列名称相同的路由自动绑定到该队列。举个例子，有一个队列声明为：”search-indexing-online”，那么使用路由关键字”search-indexing-online”发送到默认交换机的消息将会被队列”search-indexing-online”接收。看起来类似于直接将消息发送到队列中。</li>
<li>直接交换。直接交换是基于消息路由关键字将消息传递到队列，原理也比较容易理解：队列使用路由关键字绑定到交换机，收到消息后，如果消息的路由关键字和前面的关键字一致，该消息就会路由到该队列。需要注意的是，如果有多个消费者接收同一个队列，那么将会在消费者层面进行负载均衡，而不是队列。示意图如下：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200923175758411.png" alt="image-20200923175758411"></p>
<ul>
<li>扇形交换。扇形交换将消息路由到与其绑定的所有队列，并且路由关键字将被忽略。如果将N个队列绑定到扇形交换的交换机，则将新消息发布到该交换机时，会将消息的副本传递到所有N个队列。扇出交换机非常适合消息的广播路由。示意图如下：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200923180111463.png" alt="image-20200923180111463"></p>
<ul>
<li>主题交换。主题交换根据消息的路由关键字和一个匹配规则将消息路由到一个或多个队列。主题交换类型通常用于实现各种发布/订阅模式变体。类似于MQTT中主题的概念，订阅了这个主题的客户端都可以接收到此类消息。没有示意图。</li>
<li>标头交换。标头交换旨在用于在多个属性上进行路由，这些属性比路由键更容易表示为消息标头。标头交换忽略路由键属性。相反，用于路由的属性取自headers属性。如果标头的值等于绑定时指定的值，则认为消息匹配。</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>​    AMQP中队列的概念和其他协议中队列的概念一致，存储由应用程序使用的消息。队列的属性有一些不同于其他的，如下：</p>
<ul>
<li><p>名称</p>
</li>
<li><p>持久（队列将在代理重新启动后幸存）</p>
</li>
<li><p>独占（仅由一个连接使用，并且该连接关闭时队列将被删除）</p>
</li>
<li><p>自动删除（至少有一个使用方的队列在最后一个使用方退订时被删除）</p>
</li>
<li><p>参数（可选；由插件和特定于代理的功能使用，例如消息TTL，队列长度限制等）</p>
<p> 需要注意的是，队列必须要先声明再使用，声明这个工作没有定必须由谁做，消费者或者生产者都可以，最好是由谁最先使用谁创建。如果声明已经创建的队列，属性一致的话，声明无效；属性不一致的话，会报一个406的通道异常。</p>
</li>
</ul>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>​    绑定是交换机使用的规则之一，这个规则的作用就是将消息路由联系到队列。为了指示交换机E将消息路由到队列Q，必须将Q 绑定到E。绑定可能具有某些交换机类型使用的可选 路由键属性。路由键的目的是选择发布到交换机的某些消息以路由到绑定队列。换句话说，路由键就像一个过滤器。</p>
<h3 id="消息的相关知识"><a href="#消息的相关知识" class="headerlink" title="消息的相关知识"></a>消息的相关知识</h3><p>​    broker(代理)将消息发送到应用程序之后（使用<code>basic.deliver</code>或<code>basic.get-ok</code>方法）。应用程序发送回确认之后（使用<code>basic.ack</code>方法）。前者称为自动确认模型，而后者称为显式确认模型。</p>
<p>​    关于RabbitMQ或者AMQP的基础知识了解到这里就暂时差不多了，后续的学习需要更加深入。就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BA%86%E8%A7%A3/" data-id="ckupl1rs300226rupeos4acvr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/中间件/RabbitMQ/RabbitMQ相关知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2021-10-13T13:28:21.196Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RabbtiMQ相关知识点"><a href="#RabbtiMQ相关知识点" class="headerlink" title="RabbtiMQ相关知识点"></a>RabbtiMQ相关知识点</h2><h3 id="RabbitMQ中的一些基础概念"><a href="#RabbitMQ中的一些基础概念" class="headerlink" title="RabbitMQ中的一些基础概念"></a>RabbitMQ中的一些基础概念</h3><h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><p>​    AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>
<p>​    过程：发布者（Publisher）发布消息（Message），经由交换机（Exchange）。交换机根据路由规则将收到的消息分发给与该交换机绑定的队列（Queue）。最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210629175842275.png" alt="image-20210629175842275"></p>
<h5 id="Exchange交换机"><a href="#Exchange交换机" class="headerlink" title="Exchange交换机"></a>Exchange交换机</h5><p>​    交换机是用来发送消息的 AMQP 实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。有四种类型的交换机。</p>
<ul>
<li>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</li>
<li>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应绑定键的队列。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</li>
<li>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果 N 个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的 N 个队列。</li>
<li>主题交换机（Topic exchange）Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。</li>
<li>头交换机（headers exchange）headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</li>
</ul>
<h5 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h5><p>​    AMQP 中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。</p>
<p>​    队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为 406 的通道级异常就会被抛出。</p>
<p>​    持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。（持久化的队列并不会使得路由到它的消息也具有持久性。）</p>
<h6 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h6><p>​    当一条消息在队列中出现以下三种情况的时候，该消息就会变成一条死信。</p>
<ul>
<li>消息被拒绝(basic.reject / basic.nack)，并且requeue = false</li>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
</ul>
<p>​    “死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</p>
<h5 id="消息的机制"><a href="#消息的机制" class="headerlink" title="消息的机制"></a>消息的机制</h5><h6 id="RabbitMQ确认消息收到的机制"><a href="#RabbitMQ确认消息收到的机制" class="headerlink" title="RabbitMQ确认消息收到的机制"></a>RabbitMQ确认消息收到的机制</h6><p>​    生产者发送消息到 RabbitMQ Server 后，RabbitMQ Server 需要对生产者进行消息 Confirm 确认。</p>
<p>​    消费者确认指的就是 RabbitMQ 需要确认消息到底有没有被收到，来确定要不要将该条消息从队列中删除掉。这就需要消费者来告诉 RabbitMQ，有以下两种方式。</p>
<ul>
<li>消费者在消费消息的时候，如果设定应答模式为自动，则消费者收到消息后，消息就会立即被 RabbitMQ 从 队列中删除掉。 </li>
<li>手动应答模式：可以在既定的正常情况下进行确认（告诉 RabbitMQ，我已经消费过该消息了，你可以删除该条数据了）；可以在既定的异常情况下不进行确认（RabbitMQ 会继续保留该条数据），这样下一次可以继续消费该条数据。    </li>
</ul>
<h6 id="RabbitMQ消息的持久化"><a href="#RabbitMQ消息的持久化" class="headerlink" title="RabbitMQ消息的持久化"></a>RabbitMQ消息的持久化</h6><p>持久化可以提高 RabbitMQ 的可靠性，以防止在异常情况（比如：重启、关机、宕机等）下的数据丢失。</p>
<p>RabbitMQ 持久化分为三部分：交换机的持久化、队列的持久化、消息的持久化。</p>
<ul>
<li>交换机持久化是指将交换机的属性数据存储在磁盘上，当 MQ 的服务器发生意外或关闭之后，在重启 RabbitMQ 时不需要重新手动或执行代码去创建交换机了，交换机会自动被创建，相当于一直存在。</li>
<li>如果不将队列设置为持久化，那么在 RabbitMQ 服务重启之后，相关队列的元数据会丢失，数据也会丢失。队列都没有了，消息也找不到地方存储了。队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失；</li>
<li>RabbitMQ 的消息是依附于队列存在的，所以要想消息持久化，那么前提是队列也必须设置持久化。</li>
</ul>
<h6 id="RabbitMQ消息的唯一性"><a href="#RabbitMQ消息的唯一性" class="headerlink" title="RabbitMQ消息的唯一性"></a>RabbitMQ消息的唯一性</h6><p>对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是：</p>
<p>（1）全局唯一</p>
<p>（2）MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽</p>
<p>有了这个inner-msg-id，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。</p>
<h4 id="RabbitMQ中一些详细的概念"><a href="#RabbitMQ中一些详细的概念" class="headerlink" title="RabbitMQ中一些详细的概念"></a>RabbitMQ中一些详细的概念</h4><ul>
<li>Connection（连接）：Producer 和 Consumer 通过 TCP 连接到 RabbitMQ Server。一个连接就代表了一个TCP连接。</li>
<li>Channel（信道）：基于 Connection 创建，数据流动都是在 Channel 中进行。一个连接可以有多个信道，因为TCP的创建和删除非常消耗资源。信道是双向数据流通道，是一个建立在TCP连接内的虚拟连接，每个信道有一个ID。</li>
<li>Vhost（虚拟主机） ： 虚拟主机，一个消息代理（Broker）里可以开设多个虚拟主机（Vhost），用作不同用户的权限分离。</li>
<li>Broker（消息代理）：实际上就是消息服务器实体。</li>
</ul>
<h3 id="RabbitMQ使用的场景"><a href="#RabbitMQ使用的场景" class="headerlink" title="RabbitMQ使用的场景"></a>RabbitMQ使用的场景</h3><ul>
<li>异步处理：比如用户注册后，需要写入数据库并且发送邮件和短信，这里可以通过RabbitMQ将发送邮件和短信异步化，因为这些操作对于目前的流程没有影响。</li>
<li>应用解耦：两个系统之间的应用解耦，A系统发送消息队列通知B系统，B系统完成数据持久化后，发送消息队列返回告知A系统。</li>
<li>流量削峰：用户发起请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,超过一定阈值后则直接抛弃用户请求或跳转到错误页面。可以缓解短时间的高流量压垮应用。</li>
</ul>
<h3 id="RabbitMQ和Mosquitto的区别"><a href="#RabbitMQ和Mosquitto的区别" class="headerlink" title="RabbitMQ和Mosquitto的区别"></a>RabbitMQ和Mosquitto的区别</h3><p>​    MQTT一般是物联网首选的协议，基于发布订阅的轻量级协议。一字节报头，两字节心跳报文。开销比较小，能够减少网络流量。</p>
<p>​    AMQP高级消息队列协议，是面向消息中间件提供的开放的应用层协议，其设计目标是对于消息的排序、路由（包括点对点和订阅-发布）、保持可靠性、保证安全性。AMQP规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像SMTP，HTTP，FTP等协议可以创建交互系统一样。</p>
<p>​    RabbitMQ和Mosquitto分别是这两种协议的broker。Mosquitto比较轻量级。</p>
<h3 id="RabbitMQ使用中遇到的一些问题"><a href="#RabbitMQ使用中遇到的一些问题" class="headerlink" title="RabbitMQ使用中遇到的一些问题"></a>RabbitMQ使用中遇到的一些问题</h3><ul>
<li>RabbitMQ如何保证消息顺序性</li>
</ul>
<p>​    通过添加一个属性，上一条消息的ID，生产者顺序发送。消费者拿到消息后，如何没有上一条消息的ID，就进行正常消费，同时在缓存中存储一下这条消息的ID。如果有上一条id的属性，但是不对或者缓存中没有，把消息重新放到队列里面，或者睡眠一段时间，等待其他消费者消费完上一条消息。</p>
<p>​    也可以将生产者和消费者绑定，就是一个生产者对应一个消费者。将业务分离，本身RabbitMQ到消息就有顺序性，这样就能保证整体的顺序性。</p>
<p>​    也可以将生产者的消息都发到一个队列里面，消费者这对应一个队列。生产者轮流发送消息。</p>
<ul>
<li>RabbitMQ如何保证消息的幂等性</li>
</ul>
<p>​    生产者在发送消息时，可以添加一个业务ID，例如SessionID，消费者收到消息后，在redis中进行设置，如果redis中存在，认为消息已经消费了，丢弃当前消息，如果没有key，认为消息没有被消费。执行业务逻辑。</p>
<p>​    还有一种就是将id当作数据库主键，如果该数据存在了，就update一下，不再新增数据。</p>
<ul>
<li>RabbitMQ如何保证消息可靠性？</li>
</ul>
<p>​    首先有三个地方需要保证。1）生产者发送消息到交换机，这里可以通过confirmCallBack来实现，还有消息投递队列失败后会调用一个ReturnCallback，不过这个消耗比较高。2）MQ里面如果宕机了，可以通过队列持久化和消息持久化解决这个问题，可能会影响吞吐量。3）消费者这边取消自动ack，手动确认收到消息。业务处理完成之后ack。</p>
<ul>
<li>RabbitMQ消费者如果长时间不ack会怎么样？</li>
</ul>
<p>猜想：消费者连接时通过心跳机制可以检测消费者是否在线，如果一条消息没有ack，并且消费者心跳不在线，认为消费者挂了，将消息重新放到队列里面。</p>
<ul>
<li>RabbitMQ如何实现延时发送</li>
</ul>
<p>​    因为我们的系统里面很少遇到这样的需求，所以后续的说法可能不太准确。1）可以利用死信队列来达到这样的效果，生产者生产消息，到一个普通交换机中，绑定这个交换机的队列就是延时队列，设置过期时间ttl，然后等待过期时间，消息过期后回转到指定的死信交换机的死信队列里面，再让消费者去消费死信队列里面的消息即可。达到延时的效果。但是这种存在一些缺点，因为延时时间是不固定的，所以队列的设置也比较多，给代码开发带来很多繁琐。2）利用rabbitMQ插件来实现延时队列，安装插件、创建指定的队列和交换机发送的时候指定延时时间就可以了。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>//Rabbbit使用场景</p>
<p>//RabbitMQ确认消息收到的机制</p>
<p>//RabbitMQ确认消息唯一的机制</p>
<p>//RabbitMQ消息的持久化</p>
<p>//RabbitMQ的死信队列</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>一般编写了config类，直接使用即可，因为springboot对当前包的bean都扫描了</p>
<p>启用对@ConfigurationProperties注释 bean 的支持。 @ConfigurationProperties bean 可以以标准方式注册（例如使用@Bean方法），或者为了方便，可以直接在此注释上指定。</p>
<p>@SpringBootApplicationh注解是三个注解的集合体@Configuration,@EnableAutoConfiguration,@ComponentScan，会自动扫描当前包及子包的所有注入bean吗，会自动根据xml文件配置相关bean</p>
<p>导入相关依赖</p>
<p>创建bean，指定创建的交换机和队列的属性，是否持久化</p>
<p>使用rabbitTemplate发送消息即可，发送消息时需要指定交换机、绑定key、发送的对象</p>
<p>持久化需要交换机持久化、队列持久化。消息持久化</p>
<p>交换机和队列可以在创建bean的时候指定是否持久化</p>
<p>消息持久化需要在发送的时候确定，默认是自动持久化的。不过需要队列先持久化</p>
<p>message 从 producer 到 rabbitmq broker cluster 则会返回一个 confirmCallback 。</p>
<p>重点是 CorrelationData 对象，每个发送的消息都需要配备一个 CorrelationData 相关数据对象，CorrelationData 对象内部只有一个 id 属性，用来表示当前消息唯一性。</p>
<p>发送的时候创建一个 CorrelationData 对象。</p>
<p>message 从 exchange-&gt;queue 投递失败则会返回一个 returnCallback 。我们将利用这两个 callback 控制消息的最终一致性和部分纠错能力。</p>
<p>必须 rabbitTemplate.setMandatory(true)，不然当 发送到交换器成功，但是没有匹配的队列，不会触发 ReturnCallback 回调。而且 ReturnCallback 比 ConfirmCallback 先回调。</p>
<p>后一个callback会导致性能下降，尽量少用</p>
<p>接收：</p>
<p>接收需要手动确认，需要在配置文件中开启一项设置</p>
<p>编写方法即可，填写相关的入参，然后判断ID，就是deliverTag，deliverTag是递增的，然后ack即可。处理完毕或者先ACK都可以。</p>
<p>练习</p>
<p>//练习RabbitMQ中的一些基础概念</p>
<p>//练习发送的确认</p>
<p>//练习消费的确认</p>
<p>controller发送指定交换机的消息</p>
<p>消费者消费，并且返回ack</p>
<p>打印这条消息</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ckupl1rs400236rupajpo1c5u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/中间件/Redis/Redis相关知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2021-10-13T13:28:21.196Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Redis基础概念"><a href="#Redis基础概念" class="headerlink" title="Redis基础概念"></a>Redis基础概念</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>​    Redis是一个高性能的key-value数据库。支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候再次加载使用。读的速度为110000次/s写的速度为81000次/s。操作都是原子操作。redis支持的类型：String、list、set、Zsetsorted set、Hash等。redis是单进程，单线程单，通过队列技术将并发访问变为串行访问。</p>
<ul>
<li>当Redis内存满了后，写命令会返回错误信息，读命令还是可以正常返回。</li>
</ul>
<h3 id="持久化机制和原理"><a href="#持久化机制和原理" class="headerlink" title="持久化机制和原理"></a>持久化机制和原理</h3><p>Redis有两个持久化策略：RDB和AOF</p>
<h4 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h4><p>​    Redis支持将当前数据的快照存成一个数据文件的持久化机制。而一个持续写入的数据库如何生成快照呢。Redis借助了fork命令的copy on write机制。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写如一个临时文件，持久化结束后，用这个临时文件代替上一个持久化文件，也就是rename。由于os的写时复制机制（copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是fork时刻整个数据库的一个快照。即持久化后的数据库的修改不会记录到持久化文件中，这个也是它的一个缺点之一，因为有可能从持久化后到服务器断电之前到数据都会丢失，主要是看项目的取舍。而且RDB快照是全量持久化，并不是增量持久化。</p>
<p>​    在redis客户端中执行<code>save 60 1000</code>(60秒内，如果有1000个键被修改就执行RDB)命令即可调用RDB快照的备份。</p>
<h4 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h4><p>​    AOF日志的全称是Append Only File，是一个追加写入的日志。但是AOF日志文件里面存储的是redis的标准命令，有些命令经过转化，例如删除一个不存在的键，redis认为不会对数据库造成造成修改，所以不会记录在AOF日志文件中，有些命令因为操作系统的不同可能会导致执行结果不同，所以都转换为统一的命令。</p>
<ul>
<li>AOF rewrite：功能就是重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件那样，可能记录了对同一个值的多次操作。其生成过程和RDB类似，也是fork一个进程，直接遍历数据，写入新的AOF临时文件。在写入新文件的过程中，所有的写操作日志还是会写到原来老的 AOF文件中，同时还会记录在内存缓冲区中。当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的 AOF文件取代老的AOF文件。 </li>
</ul>
<p>​    在Redis中对AOF调用write写入后，何时再调用fsync将其写到磁盘上，通过appendfsync选项来控制，下面appendfsync的三个设置项，安全强度逐渐变强。 通过设置配置项来实现AOF备份：<code>appendonly yes</code>,通过配置<code>appendfsync</code>来设置何时写到磁盘上。</p>
<ul>
<li>appendfsync no ：当设置appendfsync为no的时候，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。 </li>
<li>appendfsync everysec：当设置appendfsync为everysec的时候，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一 次的fsync调用时长超过1秒时。Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。 </li>
<li>appednfsync always：当设置appendfsync为always时，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响。 </li>
</ul>
<h3 id="Redis的内存回收策略"><a href="#Redis的内存回收策略" class="headerlink" title="Redis的内存回收策略"></a>Redis的内存回收策略</h3><p>​    如果redis占用的内存满了，可以通过设置内存回收策略来进行键值淘汰，配置项为：<code>maxmemory-policy</code>。主动清除策略主要有八种：</p>
<blockquote>
<ul>
<li><p>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</p>
</li>
<li><p>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</p>
</li>
<li><p>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。（LRU：最近最少使用）</p>
</li>
<li><p>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除（LFU：最不经常使用）</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>allkeys-random：从所有键值对中随机选择并删除数据。</p>
</li>
<li><p>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</p>
</li>
<li><p>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ul>
</blockquote>
<p>LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!</p>
<p>LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!</p>
<h3 id="Redis的键删除策略"><a href="#Redis的键删除策略" class="headerlink" title="Redis的键删除策略"></a>Redis的键删除策略</h3><p>​    Redis过期key的删除方式有三种：</p>
<ul>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key。返回nil。</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key。<ul>
<li>随机测试100个设置了过期时间的key</li>
<li>删除所有发现的已过期的key</li>
<li>若删除的key超过25个则重复步骤1</li>
</ul>
</li>
<li>当前已用内存超过maxmemory限定时，触发主动清理策略。</li>
</ul>
<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>​    Redis有三种集群模式：主从模式、Sentinel模式（哨兵模式）、Cluster模式（集群模式）。</p>
<h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p>​    主从模式将数据库分为两种，主库和从库。主数据库可以进行读和写，从数据库只能进行读。多个从数据库对应一个主数据库，从数据库挂了重启后会向主数据库请求同步数据。主数据库挂掉后，不影响从数据库的读，但是不能提供写服务了。</p>
<p>​    机制：当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。</p>
<p>​    缺点就是主数据挂掉后，redis无法提供写服务。</p>
<p>​    搭建方式：通过下载redis安装包，安装后，通过启动不同的配置文件来达到多个redis服务的目的。在配置文件中配置主数据库和从数据库即可。</p>
<h5 id="流程和细节"><a href="#流程和细节" class="headerlink" title="流程和细节"></a>流程和细节</h5><p>建立连接阶段（即准备阶段）</p>
<ol>
<li>设置master的地址和端口，保存master信息</li>
<li>建立socket链接</li>
<li>发送ping命令（定时器任务）</li>
<li>身份验证</li>
<li>发送slave端口信息<br>至此，主从链接成功！</li>
</ol>
<p>数据同步阶段（注意从机命令为psync，主机命令为bgsave）</p>
<p>步骤1：请求同步<br>步骤2：创建RDB同步数据<br>步骤3：恢复RDB同步数据<br>步骤4：请求部分同步数据<br>步骤5：恢复部分同步数据<br>至此，数据同步工作完成</p>
<p>命令传播阶段</p>
<p>通过ping命令，从机通知主机发送缓冲区内的命令</p>
<h4 id="Sentinel模式（哨兵模式）"><a href="#Sentinel模式（哨兵模式）" class="headerlink" title="Sentinel模式（哨兵模式）"></a>Sentinel模式（哨兵模式）</h4><p>​    主从模式的弊端就是主数据库挂掉后，从数据库无法提供写的服务，所以产生了哨兵模式。</p>
<p>​    Sentinel是一个进程，用来监控redis进程的状态，Sentinel也可以启动多个形成一个集群。当Sentinel检测到主节点挂掉后，会将从节点升级为主节点，并修改其他所有节点的配置文件。当主节点再次启动后，会变为从节点。从节点故障后，哨兵不会进行故障转移。</p>
<p>​    机制：每个Sentinel会每秒钟一次的频率向所有的主从节点发送PING命令，如果实例的回复超过了指定的值（通过配置down-after-milliseconds,默认是30秒），则会被Sentinel标记为主观下线。如果主节点标记主观下线，其他Sentinel都要确认这个主节点下线，。当Sentinel的确认数量超过了配置值后，认为主节点客观下线。将每10一次发送的INFO命令变为1秒发送一次。</p>
<h5 id="具体的流程和细节"><a href="#具体的流程和细节" class="headerlink" title="具体的流程和细节"></a>具体的流程和细节</h5><p>​    哨兵在进行主从切换过程中经历三个阶段</p>
<p>1.监控阶段</p>
<p>​    单个哨兵通过和主节点建立cmd链接，发送info命令，得到主节点的信息和各个从节点的信息，同时在主节点内存储哨兵实例的信息。主节点信息同步完毕后，向从节点建立链接，发送info命令，完善从节点的信息。</p>
<p>​    当其他哨兵加入进来时，链接到主节点后，发现主节点内有哨兵实例，通过发布订阅的形式，将两个哨兵实例的信息进行同步，后续的哨兵都是这样。</p>
<p>2.通知阶段</p>
<p>​    哨兵通过建立的cmd链接，发送相应的命令给节点，节点将状态信息返回，然后该哨兵通过发布订阅将信息同步给其他哨兵。</p>
<p>3.故障转移</p>
<p>​        一个哨兵发现主节点发送info命令没有回复，通知其他哨兵，并且将主节点状态修改为主观下线。其他哨兵也发送命令给主节点，如果确认的哨兵数超过了设定的值，就认为该主节点客观下线。然后哨兵之间需要选举出一个哨兵执行节点切换的任务。</p>
<p>​    每个哨兵都有一票，这票投给自己最先收到竞选通知的哨兵，直到某个哨兵票数超过一半以上，就认为该哨兵负责本次的切换。</p>
<p>​    哨兵从剩下的从节点中选出最优的主节点。先筛选出在线的，再筛选出响应快的，再筛选出和原先主节点同步时间最近的，最后还有多个的话，就按照优先原则，偏移量和uuid都会有影响。最后选出一个从节点，然后将这个从节点升级为主节点，将其他从节点的主节点的信息修改为新的主节点。后面如果掉线的主节点上线的话，也会修改为从节点。</p>
<h4 id="Cluster模式（集群模式）"><a href="#Cluster模式（集群模式）" class="headerlink" title="Cluster模式（集群模式）"></a>Cluster模式（集群模式）</h4><p>​    哨兵模式基本可以满足生产的需要，但是当数据量过大，导致一台机器无法满足时，这个时候就需要将数据进行分片存储，这就是集群模式。</p>
<p>​    Redis集群是一个由多个节点组成的分布式服务器群，它具有复制、高可用和分片特性；Redis集群没有中心节点，并且带有复制和故障转移特性，这可以避免单个节点成为性能瓶颈，或者因为某个节点下线而导致整个集群下线；</p>
<p>​    我们有3个主节点，3个从节点，每个主节点处理各自的数据，提供读写能力，从节点异步复制主节点的数据。一般读请求分配给从节点，写请求分配给主节点。</p>
<h5 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h5><p>​    一个 Redis 集群包含 16384 个哈希槽（hash slot）， 它们的编号为0、1、2、3……16382、16383，这个槽是一个逻辑意义上的槽，实际上并不存在。redis中的每个key都属于这 16384 个哈希槽的其中一个，存取key时都要进行key-&gt;slot的映射计算。Redis Cluster中的每个Master节点都会负责一部分的槽，当有某个key被映射到某个Master负责的槽，那么这个Master负责为这个key提供服务。在Redis Cluster中，只有Master才拥有槽的所有权，如果是某个Master的slave，这个slave只负责槽的使用，但是没有所有权。</p>
<h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>​    在cluster中，节点之间通过gossip协议进行通信。A节点会发送PING消息给B节点，若是在cluster_node_timeout时长内没有收到B节点的回复消息，则A节点会判定B节点已经下线了。这时候，A节点判定完后，会想集群广播B节点下线的消息。如果集群中的超过半数以上的节点都认为B节点下线后，B节点就会真正的下线。</p>
<p>​    当问题节点下线后，如果该下线节点是带有槽的主节点，则需要从它的从节点选出一个替换它，当问题节点的从节点发现其主节点下线时，将会触发故障恢复流程。但是并不是所有的从节点都能参与到故障恢复的流程中，若从节点与问题主节点的断线时间超过cluster_node_timeout * cluster-slave-validity-factor时，该从节点不能参与到后续恢复流程。</p>
<p>​    主要是通过对多个从节点使用不同的延迟选举时间来支持优先级问题。复制偏移量越大说明从节点延迟越低，那么它应该具有更高的优先级来替换故障主节点。</p>
<h4 id="Redis中的脑裂现象"><a href="#Redis中的脑裂现象" class="headerlink" title="Redis中的脑裂现象"></a>Redis中的脑裂现象</h4><p>​    redis中的脑裂现象：哨兵将发现主节点下线后，将一个从节点升级为主节点，但是仍然有客户端连接旧的主节点，两个主节点造成数据没有同步，后续主节点恢复后，数据仍然丢失。可以通过设置第一个参数表示连接到master的最少slave数量，第二个参数表示slave连接到master的最大延迟时间这两个参数。如果两个条件都不满足，主节点就会拒绝同步数据。防止脑裂现象的产生。</p>
<h3 id="Redis中的发布订阅"><a href="#Redis中的发布订阅" class="headerlink" title="Redis中的发布订阅"></a>Redis中的发布订阅</h3><p>​    Redis中的发布订阅可以使用匹配符，需要注意当没有消费者时，生产者发布的消息可能会丢失。</p>
<h3 id="Redis中的事务"><a href="#Redis中的事务" class="headerlink" title="Redis中的事务"></a>Redis中的事务</h3><p>​    Redis中的事务比较独特。事务开启后，会将命令都放入队列缓存中，其他客户端的命令不会放入。事务执行后，如果遇到命令格式错误，事务中所有的操作都不会被执行。但是如果命令格式正确，使用方式不对，例如对String执行hash方法，该命令不会被执行，其他正确命令仍然会被执行。</p>
<p>​    watch是为了完善redis事务的特点，在事务开始前监听某个key，如果事务中间key发生了变化，事务就会中断，不再执行。unwatch是为了取消监听，防止本次的监听对下次的事务产生影响。exec和discard也有同样的效果。</p>
<p>​    如果客户端发送的命令为 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令的其中一个， 那么服务器立即执行这个命令。如果不是这四个命令，服务器并不立即执行这个命令， 而是将这个命令放入一个事务队列里面， 然后向客户端返回 QUEUED。某些命令执行出错也不会影响整个事务。</p>
<h3 id="Redis中的管道"><a href="#Redis中的管道" class="headerlink" title="Redis中的管道"></a>Redis中的管道</h3><p>​    Redis默认每次执行请求都会创建和断开一次连接池的操作，因此我们可以使用Redis的管道来一次性发送多条命令并返回多个结果，节约发送命令和创建连接的时间提升效率。</p>
<p>​    Redis中管道的实现是根据队列，可以保证数据的顺序性。</p>
<h2 id="Redis数据结构相关知识点"><a href="#Redis数据结构相关知识点" class="headerlink" title="Redis数据结构相关知识点"></a>Redis数据结构相关知识点</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>一个键最大能存储 512MB，暂时没有找到原因</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</li>
<li>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><ul>
<li>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</li>
<li>hash的原理也是数组加链表，扩容机制不太一样，是双table扩容，新的table要扩容时，是在执行完原油命令后，将就table上的元素慢慢复制到新table。这就是渐进式扩容。但是还是存在一些问题的，就是极端情况下，如果键一直在增加，新table也会很快触发扩容，这种情况下如何处理，这里其实估计只有后续看源码能够想清楚了。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</li>
<li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li>
<li>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</li>
</ul>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><ul>
<li>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</li>
<li>Zset就是排序集合，在插入时需要制定元素的权，redis也是根据权来进行排序的。权相同时，则是根据字典排序。</li>
</ul>
<h3 id="跳跃表（skiplist）"><a href="#跳跃表（skiplist）" class="headerlink" title="跳跃表（skiplist）"></a>跳跃表（skiplist）</h3><p>​    跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</p>
<p>​    跳表相当于是在链表的形式上添加层级来达到快速查询的目的。</p>
<h2 id="Redis相关命令"><a href="#Redis相关命令" class="headerlink" title="Redis相关命令"></a>Redis相关命令</h2><h3 id="Redis常用的基础命令"><a href="#Redis常用的基础命令" class="headerlink" title="Redis常用的基础命令"></a>Redis常用的基础命令</h3><ul>
<li>启动：<code>redis-server redis.conf</code></li>
<li>连接：<code>redis-cli -h host -p port -a password</code></li>
<li>获取配置：<code>CONFIG GET *</code></li>
<li>设置配置：<code>ONFIG SET loglevel &quot;notice&quot;</code></li>
<li>删除key：<code>del tset</code></li>
<li>序列化给定 key ，并返回被序列化的值:<code>dump test</code></li>
<li>检查给定 key 是否存在:<code>EXISTS test</code></li>
<li>为给定 key 设置过期时间，以秒计:<code>EXPIRE test 120</code></li>
<li>为给定 key 设置过期时间,接受的时间参数是 UNIX 时间戳: <code>EXPIREAT test 1623297047</code></li>
<li>设置 key 的过期时间以毫秒计:<code>PEXPIRE test 120000</code></li>
<li>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计:<code>PEXPIREAT test 1623297047000</code></li>
<li>查找所有符合给定模式( pattern)的 key :<code>keys tes*</code></li>
<li>将当前数据库的 key 移动到给定的数据库 db 当中:<code>move test 1</code></li>
<li>移除 key 的过期时间，key 将持久保持:<code>PERSIST test</code></li>
<li>以毫秒为单位返回 key 的剩余的过期时间:<code>PTTL test</code></li>
<li>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live):<code>TTL test</code></li>
<li>从当前数据库中随机返回一个 key :<code>RANDOMKEY</code></li>
<li>修改 key 的名称:<code>RENAME test test1</code></li>
<li>仅当 newkey 不存在时，将 key 改名为 newkey:<code>RENAMENX test1 test</code></li>
<li>迭代数据库中的数据库键:<code>SCAN cursor [MATCH pattern] [COUNT count]</code></li>
<li>返回 key 所储存的值的类型:<code>type test</code></li>
<li>验证密码是否正确：<code>AUTH qhlk@2017</code></li>
<li>打印字符串：<code>ECHO &quot;this is test&quot;</code>(当你的字符串中间带特殊字符时，需要你带上双引号)</li>
<li>查看服务是否运行：<code>PING</code></li>
<li>关闭当前连接：<code>QUIT</code></li>
<li>切换到指定的数据库：<code>SELECT 0</code>(总共十六个库，0-15)</li>
<li>创建当前数据库的备份：<code>SAVE</code></li>
<li>根据备份文件恢复redis数据库：<code>BGSAVE</code></li>
</ul>
<h3 id="字符串相关命令"><a href="#字符串相关命令" class="headerlink" title="字符串相关命令"></a>字符串相关命令</h3><ul>
<li>设置指定 key 的值：<code>set tset &quot;hello&quot;</code>也可以对存在的key执行就是修改</li>
<li>获取指定 key 的值：<code>GET test1</code></li>
<li>返回 key 中字符串值的子字符：<code>GETRANGE test1 0 5</code></li>
<li>将给定 key 的值设为 value ，并返回 key 的旧值(old value)：<code>GETSET test1 &quot;this is test1.&quot;</code></li>
<li>对 key 所储存的字符串值，获取指定偏移量上的位(bit)：<code>GETBIT test1 10</code></li>
<li>获取所有(一个或多个)给定 key 的值：<code>MGET test test1</code></li>
<li>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)：<code>SETBIT test1 10 1</code></li>
<li>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)：<code>SETEX test1 120 &quot;this is test1&quot;</code></li>
<li>只有在 key 不存在时设置 key 的值：<code>SETNX test1 &quot;hello&quot;</code></li>
<li>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始：<code>SETRANGE test2 1 &quot;hahaha&quot;</code></li>
<li>返回 key 所储存的字符串值的长度：<code>STRLEN test2</code></li>
<li>同时设置一个或多个 key-value 对：<code>mset key &quot;2&quot; key2 &quot;this is &quot;</code></li>
<li>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在：<code>MSETNX ke2 &quot;test&quot; key &quot;haha&quot;</code></li>
<li>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间：<code>PSETEX key 120000 &quot;this &quot;</code></li>
<li>将 key 中储存的数字值增一：<code>INCR key</code></li>
<li>将 key 所储存的值加上给定的增量值（increment）：<code>INCRBY ke2 34</code></li>
<li>将 key 中储存的数字值减一：<code>DECR ke2</code></li>
<li>key 所储存的值减去给定的减量值（decrement） ：<code>DECRBY ke2 3</code></li>
<li>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾：<code>APPEND key &quot;end&quot;</code></li>
</ul>
<h3 id="HASH相关命令"><a href="#HASH相关命令" class="headerlink" title="HASH相关命令"></a>HASH相关命令</h3><ul>
<li>删除一个或多个哈希表字段：<code>HDEL testhash object</code></li>
<li>查看哈希表 key 中，指定的字段是否存在：<code>HEXISTS testhash2 bug</code></li>
<li>获取存储在哈希表中指定字段的值：<code>HGET testhash2 age</code></li>
<li>获取在哈希表中指定 key 的所有字段和值：<code>HGETALL testhash2</code></li>
<li>为哈希表 key 中的指定字段的整数值加上增量 increment ：<code>HINCRBY testhash2 age 1</code></li>
<li>为哈希表 key 中的指定字段的浮点数值加上增量 increment ：<code>HINCRBYFLOAT testhash2 money 3.4</code></li>
<li>获取所有哈希表中的字段：<code>HKEYS testhash2</code></li>
<li>获取哈希表中字段的数量：<code>HLEN testhash2</code></li>
<li>获取所有给定字段的值：<code>HMGET testhash2 redis mysql age</code></li>
<li>同时将多个 field-value (域-值)对设置到哈希表 key 中：<code>HMSET testhash2 age 13 money 13.4 name lihua</code></li>
<li>将哈希表 key 中的字段 field 的值设为 value ：<code>HSET testhash2 redis good mysql bad rabbitmq bad</code>(也可以设置多个字段)</li>
<li>只有在字段 field 不存在时，设置哈希表字段的值:<code>HSETNX testhash2 tag &quot;null&quot;</code></li>
<li>获取哈希表中所有值:<code>HVALS testhash2</code></li>
<li>迭代哈希表中的键值对:<code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
</ul>
<h3 id="LIST相关命令"><a href="#LIST相关命令" class="headerlink" title="LIST相关命令"></a>LIST相关命令</h3><ul>
<li>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止：<code>BLPOP testlist2 10</code></li>
<li>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止：<code>BRPOP testlist2 10</code></li>
<li>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止：<code>BRPOPLPUSH testlist testlist5 10</code>（从尾部取出，插入到另一个列表的头部）</li>
<li>通过索引获取列表中的元素：<code>LINDEX testlist 3</code></li>
<li>在列表的元素前或者后插入元素：<code>LINSERT testlist AFTER test &quot;after&quot;</code></li>
<li>获取列表长度：<code>LLEN testlist</code></li>
<li>移出并获取列表的第一个元素：<code>LPOP testlist</code></li>
<li>将一个或多个值插入到列表头部：<code>LPUSH testlist &quot;hehe&quot; &quot;test222&quot;</code></li>
<li>将一个值插入到已存在的列表头部：<code>LPUSHX testlist1 &quot;hehe&quot; &quot;test222&quot;</code></li>
<li>获取列表指定范围内的元素：<code>LRANGE testlist 0 2</code></li>
<li>移除列表元素：<code>LREM testlist 0 &quot;haha&quot;</code></li>
<li>通过索引设置列表元素的值：<code>LSET testlist 0 &quot;this is test&quot;</code></li>
<li>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除：<code>LTRIM testlist 0 4</code></li>
<li>移除列表的最后一个元素，返回值为移除的元素：<code>RPOP testlist</code></li>
<li>移除列表的最后一个元素，并将该元素添加到另一个列表并返回：<code>RPOPLPUSH testlist testlist2</code>(头部插入)</li>
<li>在列表中添加一个或多个值：<code>RPUSH testlist &quot;test&quot; &quot;test2&quot;</code>(添加到尾部)</li>
<li>为已存在的列表添加值：<code>RPUSHX mylist &quot;test&quot;</code></li>
</ul>
<h3 id="SET相关命令"><a href="#SET相关命令" class="headerlink" title="SET相关命令"></a>SET相关命令</h3><ul>
<li>向集合添加一个或多个成员：<code>SADD myset &quot;123&quot; 3</code>（这里是多个成员，分别为字符串123和int 3）</li>
<li>获取集合的成员数：SCARD myset</li>
<li>返回第一个集合与其他集合之间的差异：<code>SDIFF myset myset1</code>(主要返回前面集合中的差异，后面集合元素不会返回)</li>
<li>返回给定所有集合的差集并存储在 destination 中：<code>SDIFFSTORE myset2 myset myset1</code></li>
<li>返回给定所有集合的交集：<code>SINTER myset myset2</code></li>
<li>返回给定所有集合的交集并存储在 destination 中：<code>SINTERSTORE myset3 myset myset2</code></li>
<li>判断 member 元素是否是集合 key 的成员：<code>SISMEMBER myset &quot;123&quot;</code></li>
<li>返回集合中的所有成员：<code>SMEMBERS myset1</code></li>
<li>将 member 元素从 source 集合移动到 destination 集合：<code>SMOVE myset2 myset1 &quot;3&quot;</code></li>
<li>移除并返回集合中的一个随机元素：<code>spop myset1</code></li>
<li>返回集合中一个或多个随机数：<code>SRANDMEMBER myset1 2</code></li>
<li>移除集合中一个或多个成员：<code>SREM myset1 &quot;haha&quot;</code></li>
<li>返回所有给定集合的并集：<code>SUNION myset myset1</code></li>
<li>所有给定集合的并集存储在 destination 集合中：<code>SUNIONSTORE myset4 myset myset1</code></li>
<li>迭代集合中的元素：<code>SSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
</ul>
<h3 id="有序集合相关命令"><a href="#有序集合相关命令" class="headerlink" title="有序集合相关命令"></a>有序集合相关命令</h3><ul>
<li>向有序集合添加一个或多个成员，或者更新已存在成员的分数：<code>ZADD myzset 1 &quot;test1&quot; 2 &quot;test2&quot;</code></li>
<li>获取有序集合的成员数：<code>ZCARD myzset</code></li>
<li>计算在有序集合中指定区间分数的成员数：<code>ZCOUNT myzset 0 2</code></li>
<li>有序集合中对指定成员的分数加上增量 increment：<code>ZINCRBY myzset 2 &quot;test2&quot;</code></li>
<li>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中：<code>ZINTERSTORE summyzset 2 myzset myzset2</code>(中间的数字2代表有两个set合并)</li>
<li>在有序集合中计算指定字典区间内成员数量：<code>ZLEXCOUNT myzset - +</code>(不清楚为啥)</li>
<li>通过索引区间返回有序集合指定区间内的成员：<code>ZRANGE myzset 0 -1 withscores</code>(withscores是表示将权一块显示出来，0代表排序的第一位，2代表排序集合的第三个元素)</li>
<li>通过字典区间返回有序集合的成员：<code>ZRANGEBYLEX myzset - +</code>(-号代表底，+号代表最高)</li>
<li>通过分数返回有序集合指定区间内的成员：<code>ZRANGEBYSCORE myzset (0 (2 withscores</code>(（代表不包含0，[代表包含,这里的分数就带代表权)</li>
<li>返回有序集合中指定成员的索引：<code>ZRANK myzset &quot;test1&quot;</code>(索引即时该元素在排序集合中的位置)</li>
<li>移除有序集合中的一个或多个成员：<code>ZREM myzset &quot;test1&quot;</code></li>
<li>移除有序集合中给定的字典区间的所有成员：<code>ZREMRANGEBYLEX myzset2 - +</code></li>
<li>移除有序集合中给定的排名区间的所有成员：<code>ZREMRANGEBYRANK myzset 0 0</code></li>
<li>移除有序集合中给定的分数区间的所有成员：<code>ZREMRANGEBYSCORE myzset 0 5</code> </li>
<li>返回有序集中指定区间内的成员，通过索引，分数从高到低：<code>ZREVRANGE myzset 0 -1 withscores</code></li>
<li>返回有序集中指定分数区间内的成员，分数从高到低排序：<code>ZREVRANGEBYSCORE myzset 100 0</code>(也存在根据字典区间的命令)</li>
<li>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序：<code>ZRANK myzset lisi</code>(查询lisi在有序集合中的排名)</li>
<li>返回有序集中，成员的分数值：<code>ZSCORE myzset lisi</code></li>
<li>计算给定的一个或多个有序集的并集，并存储在新的 key 中：<code>ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3</code>(看不懂)</li>
<li>迭代有序集合中的元素（包括元素成员和元素分值）：<code>ZSCAN site 0 match &quot;R*&quot;</code></li>
</ul>
<h3 id="HyperLogLog相关命令"><a href="#HyperLogLog相关命令" class="headerlink" title="HyperLogLog相关命令"></a>HyperLogLog相关命令</h3><p>​    redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在Redis里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。但是HyperLogLog 只会计算基数，不会存储元素本身。</p>
<ul>
<li>添加指定元素到 HyperLogLog 中：<code>PFADD mypf &quot;redis&quot;</code>(后面可以跟多个元素，元素可以不带引号，存储的都是字符串类型)</li>
<li>返回给定 HyperLogLog 的基数估算值：<code>PFCOUNT mypf</code></li>
<li>将多个 HyperLogLog 合并为一个 HyperLogLog：<code>PFMERGE mypf3 mypf mypf2</code></li>
</ul>
<h3 id="发布订阅相关命令"><a href="#发布订阅相关命令" class="headerlink" title="发布订阅相关命令"></a>发布订阅相关命令</h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道。</p>
<ul>
<li>订阅一个或多个符合给定模式的频道：<code>PSUBSCRIBE testchannel</code>(后面参数类似于正则表达式)</li>
<li>查看订阅与发布系统状态：<code>PUBSUB channels</code>(目前不清楚用法，现在参数固定)</li>
<li>将信息发送到指定的频道：PUBLISH testchannel “this is test”</li>
<li>退订所有给定模式的频道：PUNSUBSCRIBE mychannel </li>
<li>订阅给定的一个或多个频道的信息：SUBSCRIBE testchannel</li>
<li>指退订给定的频道：UNSUBSCRIBE mychannel</li>
</ul>
<h3 id="Redis中的事务-1"><a href="#Redis中的事务-1" class="headerlink" title="Redis中的事务"></a>Redis中的事务</h3><ul>
<li>取消事务，放弃执行事务块内的所有命令:<code>DISCARD</code></li>
<li>执行所有事务块内的命令:<code>EXEC</code></li>
<li>标记一个事务块的开始:<code>MULTI</code>（连续执行两次multi不会导致事务回滚）</li>
<li>取消 WATCH 命令对所有 key 的监视:UNWATCH（使用方法是在watch前面，并不是在事务中取消监视，而是在监视前取消所有的其他监视，所以只要调用了watch，key被修改，就会出错。只是为了完善redis事务的一个点）</li>
<li>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断:<code>WATCH lock</code>（在multi里面执行watch不会导致事务回滚。）</li>
</ul>
<h2 id="Redis在SpringBoot中的应用"><a href="#Redis在SpringBoot中的应用" class="headerlink" title="Redis在SpringBoot中的应用"></a>Redis在SpringBoot中的应用</h2><h2 id="Redis实际中的应用和解决方案"><a href="#Redis实际中的应用和解决方案" class="headerlink" title="Redis实际中的应用和解决方案"></a>Redis实际中的应用和解决方案</h2><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>​    对于一些设置了过期时间的key，如果这个key可能会在某些时间点被超高并发地访问，是一个热点数据，当这个key过期后，这个时间点有大量并发去请求这个key，该key没有命中，大量的请求穿透到数据库服务器。</p>
<p>​    解决方案：有两种方案，1）将热点数据设置永不过期。2）使用互斥锁：先从redis获取数据，如果redis中数据没有，去争夺锁，拿到锁的线程去查询数据库，然后见过结果放入redis中。其他没抢到的，等一段时间，再执行查询等方法，重新从redis中获取数据。锁是需要按照key 维度去加锁。例如akey的锁不能影响其他key的查询。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>​    大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<p>​    解决方案：1）可以给缓存时间加上一个随机偏移量，例如一个小时的缓存时间，可以将这个时间再10分钟内随机，将失效时间平均到10分钟内。2）和上面的缓存击穿一样，加一个互斥锁，减少数据库的访问次数。3）设置热点数据永不过期，需要考虑数据的同步时间间隔和数据异常的处理情况。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>​    访问一个一定不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。因为查不到数据，所以后续的查询仍然会请求数据库。</p>
<p>​    解决方案有以下：1）如果是大量的不存在的key，可以认为是受到的攻击，可以在最外层做一层过滤。2）当数据库查询的结果为空时，可以将这个null结果做个缓存，设置一个较短的过期时间。当查询的key都是不存在的时候且不重复，这个作用也是比较小的。3）布隆过滤器。</p>
<h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>​    有一个bitset集合，还有一组hash算法，将一个key通过这组hash算法计算得到一组下标。将bitset中这组下标的位置设置为true，如果一个key通过这样的计算，得到的一组下标的位置不全为true，则这个key一定不存在，当都是true时，这个key可能存在。降低误判率也有方法：增大bitset集合的长度，增多hash算法，得到更多的下标。一般是增加长度，因为长度如果过短的话，增加hash算法其实意义不大。</p>
<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>​    当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。</p>
<p>​    解决方法：更新数据库后，直接让缓存失效。</p>
<h3 id="面试中遇到的问题"><a href="#面试中遇到的问题" class="headerlink" title="面试中遇到的问题"></a>面试中遇到的问题</h3><ul>
<li>项目中什么地方用到redis，为什么使用redis？</li>
</ul>
<p>我们项目中redis的主要作用就是存储设备点位的信息，主要是存储设备当前状态的值，还有就是用户的token信息也是存储在redis中。当然，项目中还有一些其他的地方我没有涉及，可能这部分的信息也有存储在redis中的需求。因为项目是在我来公司之前成立的，所以技术的选型我并没有参与，对于选用redis并不知道当时出于什么考虑。我们redis使用的是单机服务，对于我们的项目来说可能够用了，但是并没有考虑到高可用，小公司对于技术的优化可能没有强烈的需求，我也是在私下会对这部分有个了解。我对于公司的redis优化的思路是采用哨兵模式进行高可用的优化。因为单机模式会存在宕机的可能，集群模式主要是为了应对单个服务器无法存储全部的数据的情况，所以我认为哨兵模式对于我们的项目来说比较适合。后面就介绍一下哨兵模式的一些特点和搭建中遇到的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ckupl1rs400246rup71df853s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/SpringCloud/SpringCloud集成Hystrix" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/SpringCloud/SpringCloud%E9%9B%86%E6%88%90Hystrix/" class="article-date">
  <time datetime="2021-10-13T13:28:21.195Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringCloud集成Hystrix"><a href="#SpringCloud集成Hystrix" class="headerlink" title="SpringCloud集成Hystrix"></a>SpringCloud集成Hystrix</h2><p>​    之前在SpringCLoud了解的博客简单介绍了Hystrix，现在就来详细介绍一下，顺带编写一个demo。</p>
<p>​    为了防止雪崩现象（一个系统中的错误导致系统大面积不可用），所以要让请求在发生错误时仍然可以维持后续的步骤，就是让操作降级，或者后续再处理。总之就是要维持后续的步骤，让系统在发生错误的情况下仍然可用。（这个感觉需要和业务紧密连接，虽然组件可以达到高可用，但是业务上的后续处理还是需要自己编写相关的业务代码的。）</p>
<p>​    Hystrix的原理。</p>
<blockquote>
<ul>
<li>防止任何单个依赖项耗尽所有容器（例如Tomcat）用户线程。</li>
<li> 减少负载并快速失败，而不是排队。</li>
<li>在可行的情况下提供备用，以保护用户免受故障的影响。</li>
<li>使用隔离技术（例如如 bulkhead, swimlane, 和 circuit breaker 模式）来限制任何一种依赖关系的影响。</li>
<li>通过近实时指标，监视和警报优化发现时间。</li>
<li>通过在Hystrix的大多数方面中以低延迟传播配置更改来优化恢复时间，并支持动态属性更改，这使您可以通过低延迟反馈回路进行实时操作修改。</li>
<li>防止整个依赖性客户端执行失败，而不仅仅是网络流量失败。</li>
</ul>
</blockquote>
<p>  为了实现这些目标，Hystrix也做了一些处理。</p>
<blockquote>
<ul>
<li>将对外部系统（或“依赖关系”）的所有调用包装在通常在单独线程中执行的<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象中（这是<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Command_pattern">命令模式</a>的示例）。</li>
<li>超时呼叫花费的时间超过您定义的阈值。有一个默认的，而是由“属性”，使它们比测量的99.5略高的方式对大多数依赖你自定义设置这些超时个百分点每个依存性的性能。</li>
<li>为每个依赖项维护一个小的线程池（或信号灯）；如果已满，发往该依赖项的请求将立即被拒绝，而不是排队。</li>
<li>测量成功，失败（客户端抛出的异常），超时和线程拒绝。</li>
<li>如果某个服务的错误百分比超过阈值，则使断路器跳闸，以在一段时间内手动或自动停止所有对特定服务的请求。</li>
<li>当请求失败，被拒绝，超时或短路时执行回退逻辑。</li>
<li>几乎实时监控指标和配置更改。</li>
</ul>
</blockquote>
<p>  上面都是翻译自Hystrix的GitHub页面，找了一圈，没有找到官网，只找到这个GitHub页面，上面也有一些文档。GitHub地址如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/hystrix/wiki">https://github.com/Netflix/hystrix/wiki</a></p>
<p>​    然后就是一些图片，关于服务的正常调用和异常调用。</p>
<center>正常的服务之间的调用</center>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704171401715.png" alt="image-20200704171401715"></p>
<center>异常的服务之间的调用</center>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704172314545.png" alt="image-20200704172314545"></p>
<p>​    一个服务的节点阻塞，导致阻塞用户的整个请求，最后产生雪崩现象。</p>
<center>Hystrix之间的调用</center>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704172521744.png" alt="image-20200704172521744"></p>
<p>​    还是那句话，有能力的最好直接看官网文档，比较详细而且比较全。</p>
<p>​    介绍完了大致的原理，下面就开始撸代码。</p>
<p>​    因为feign默认集成了Hystrix，所以这里和上一节的Ribbon都不需要添加新的依赖。直接就可以编写。需要修改的地方有三个，一个是在feign接口代码添加一个回调类，还有就是创建一个回调类，写一些业务逻辑代码。最后就是在配置文件中开启Hystrix，因为feign默认不开启。</p>
<p>​    接口代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient.feign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.eurekaclient.hystrix.UserHystrix;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserFeign.java</span></span><br><span class="line"><span class="comment"> * Description: User的feign</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;provider-mysql&quot;, fallback = UserHystrix.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 查询list中的id所对应的用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">selectUserByID</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; ids)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    回调类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient.hystrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.eurekaclient.feign.UserFeign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserHystrix.java</span></span><br><span class="line"><span class="comment"> * Description: UserFeign的回调类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHystrix</span> <span class="keyword">implements</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 查询的回调方法，里面可以放一些异常后处理机制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selectUserByID</span><span class="params">(List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用异常，但是可以继续往下执行&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    配置代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################### common config : ####################################</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">eureka-client</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8081</span></span><br><span class="line"><span class="comment">#eureka注册中心的配置</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://127.0.0.1:8080/eureka</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#日志的级别</span></span><br><span class="line"><span class="attr">logging</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">level</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">com.psq.eurekaclient.feign.UserFeign</span>: <span class="string">debug</span></span><br><span class="line"><span class="comment">#feign默认不开启Hystrix，需要配置开启</span></span><br><span class="line"><span class="attr">feign</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">hystrix</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    关闭生产者前的调用截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704175652527.png" alt="image-20200704175652527"></p>
<p>关闭生产者后的调用截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704180406092.png" alt="image-20200704180406092"></p>
<p>​    以上就是简单的调用，说了这么多，这些组件都是为了保证服务的高可用，但是写下来后发现，企业里面要保证高可用只有这些事不够的，需要结合自己公司的情况做对应的修改，有可能需要对这些组件的源码修。还是之前说的，公司的实力不够还是不要搞微服务了，很坑。</p>
<p>​    上面简单的调用没有什么技术点，后面还是需要看看源码或者分析具体的原理。但是现在显然短短一篇博客是不可能的了，这些都可以算到后面的债。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/SpringCloud/SpringCloud%E9%9B%86%E6%88%90Hystrix/" data-id="ckupl1rr600156rup23be7iai" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/SpringCloud/SpringCloud集成OpenFeign" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/SpringCloud/SpringCloud%E9%9B%86%E6%88%90OpenFeign/" class="article-date">
  <time datetime="2021-10-13T13:28:21.195Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringCloud集成OpenFeign"><a href="#SpringCloud集成OpenFeign" class="headerlink" title="SpringCloud集成OpenFeign"></a>SpringCloud集成OpenFeign</h2><p>​    上次讲完Eureka，这次来讲一下OpenFeign。</p>
<p>​    之前的Eureka没有讲它的原理，后面看看能不能补上，这里也简单叙述一下OpenFeign的原理，后面慢慢补充。</p>
<p>​    OpenFeign。简化调用服务时的工作，将复杂的请求简化为配置，使用动态代理来构造出需要请求的服务地址，最后发起请求和解析请求。</p>
<p>​    微服务即然已经搭建起来了，但是各个微服务之前如何通讯和调用确实各问题，当然可以通过http的形式调用相应的服务，但是这样写的话，比较繁琐，并且代码的耦合度也会很高，这里就引出了Openfeign的概念。Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，这种请求相对而言比较直观。所以一个插件或者组件的产生肯定是为了解决某个问题的，不可能没有任何用处但是仍然在使用。</p>
<p>​    Openfeign的原理相对于我来说还是比较复杂的，这里我也就我自己的理解和别人的博客简单说一下Openfeign的一次调用。</p>
<ul>
<li><p>在使用feign 时，会定义对应的接口类，在接口类上使用Http相关的注解，标识HTTP请求参数信息</p>
</li>
<li><p>在Feign 底层，通过基于面向接口的动态代理方式生成实现类，将请求调用委托到动态代理实现类</p>
</li>
<li><p>最后将方法的调用转换为一次http请求</p>
</li>
</ul>
<p>​    我的理解就是这么个过程，可能不太对，欢迎大家指正。下面就上代码。</p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>​    生产者的代码主要就是一个controller，只要有返回就可以了。这里就不再累述。没有什么可讲的。主要讲一下中间遇到的坑。</p>
<ul>
<li><p>IDEA运行的时候，因为我的结构是父模块和子模块的形式，所以在编译的时候一直没有通过，只需要先把父模块编译，要注意pom文件不要带子模块，编译完毕在<code>install</code>一下就可以了，子模块就可以编译运行了。</p>
</li>
<li><p>为了方便后面的测试，所以在模块中添加了swagger-ui，很简单，添加pom文件、增加一个swagger配置类就可以了。详细的解释和需要添加的注解可以看下面的俩博客。</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xifengxiaoma/p/11022146.html">https://www.cnblogs.com/xifengxiaoma/p/11022146.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012702547/article/details/88775298">https://blog.csdn.net/u012702547/article/details/88775298</a></p>
<p>生产者代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.providermysql.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserController.java</span></span><br><span class="line"><span class="comment"> * Description:  User相关controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(value = &quot;用户&quot;, tags = &quot;用户管理相关接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;查询用户接口&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selectUserByID</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello SpringCloud&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>​    主要改动的地方就在消费者，首先消费者模块需要添加一个feign依赖，然后消费者通过编写一个feign接口来代表生产者的方法，controller通过<code>@Autowired</code>注解直接使用就可以了，启动类也需要添加一个<code>@EnableFeignClients</code>注解。其他的地方就不需要改动了。代码如下：</p>
<ul>
<li><p>Feigin接口代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient.feign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserFeign.java</span></span><br><span class="line"><span class="comment"> * Description: User的feign</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;provider-mysql&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 查询list中的id所对应的用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">selectUserByID</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; ids)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>controller层代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.eurekaclient.feign.UserFeign;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserController.java</span></span><br><span class="line"><span class="comment"> * Description:  User相关controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(value = &quot;用户&quot;, tags = &quot;用户管理相关接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserFeign userFeign;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;查询用户接口&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selectUserByID</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        String result = userFeign.selectUserByID(ids);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动类代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EurekaClientApplication.java</span></span><br><span class="line"><span class="comment"> * Description:  Eureka Client 启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>导入的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置feign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    代码就是上面的代码，运行截图如下：</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200616145706715.png" alt="image-20200616145706715"></p>
<p>​    难点上面都说了，也没有啥可以说的了，感觉坑还是自己踩踩比较好，后面也会又个深入的了解，也会把踩到的坑说说。</p>
<p>​    顺带说一下，代码也上传到GitHub了，大家也可以下载源码。链接：<a target="_blank" rel="noopener" href="https://github.com/qq1162210866/springcloud-train">https://github.com/qq1162210866/springcloud-train</a></p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/SpringCloud/SpringCloud%E9%9B%86%E6%88%90OpenFeign/" data-id="ckupl1rr600166rupak8ual8t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/SpringCloud/SpringCloud集成Ribbon" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/SpringCloud/SpringCloud%E9%9B%86%E6%88%90Ribbon/" class="article-date">
  <time datetime="2021-10-13T13:28:21.195Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringCloud集成Ribbon"><a href="#SpringCloud集成Ribbon" class="headerlink" title="SpringCloud集成Ribbon"></a>SpringCloud集成Ribbon</h2><p>​    Ribbon 是一个基于 HTTP 和 TCP 的 客服端负载均衡工具，它是基于 Netflix Ribbon 实现的。</p>
<p>​    说的明白点就是一个或者多个消费者去调用生产者的方法，但是哪个消费者去调用哪个生产者这个是根据算法来确定的，Ribbon就类似于这个算法。</p>
<p>​    Ribbon有很多的负载均衡算法，轮询策略（默认）、权重轮询策略、随机策略、最少并发数策略、重试策略、可用性敏感策略、区域敏感性策略。很多算法看名字就知道意思，这里算法不是本次讨论的重点，也不再累述，后面有机会了解一下。</p>
<p>​    Ribbon是集成于客户端的，业内也有两种主流的负载均衡的方案。1.集中式负载均衡（服务器负载均衡），通过一个单独的模块来实现负载均衡。2.进程内负载均衡（客户端负载均衡），客户端通过算法去查询合适的生产者，然后调用。可以显而易见的看到Ribbon是属于后者的。</p>
<p>​    还是老样子，实际操作一下，后面再说原理的事。成功了才会有兴趣去深入。</p>
<p>​    因为OpenFeign已经集成了Ribbon，所以之前的代码不需要大的改动。</p>
<p>​    要实现负载均衡，需要有两个生产者。这里直接将一个生产者的文件夹复制，在修改文件夹名字，然后IDE导入模块就可以了。项目结构如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200702181859656.png" alt="image-20200702181859656"></p>
<p>​    第二个生产者模块需要修改一个端口号，以免两个生产者启动冲突。然后启动两个生产者模块即可。可以看到注册中心页面如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200702181934513.png" alt="image-20200702181934513"></p>
<p>​    然后使用swagger-ui直接调用消费者的方法，消费者通过OpenFeign调用生产者的方法。会发现两个生产者的控制台在循环打印信息，这是因为Ribbon默认使用的轮询算法。效果如图：</p>
<p>生产者1:</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200702182439596.png" alt="image-20200702182439596"></p>
<p>生产者2:</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200702182525176.png" alt="image-20200702182525176"></p>
<p>​    总共是调用了五次，所以生产者累计打印了五次。</p>
<p>​    在编写的过程中才发现，Ribbon更多的是提供了一个思路或者解决办法，解决的问题就是生产者和消费者之间调度的问题。因为SpringCloud对于这些组件集成的比较好（还是之前说的，这些工具的产生是为了加快开发的速度），所以本次更多的还是理解负载均衡的意义和原理。后面也会对这些源码进行阅读，了解深层次的一些东西。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/SpringCloud/SpringCloud%E9%9B%86%E6%88%90Ribbon/" data-id="ckupl1rr700176rupbwkq9yc5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/netty/Netty了解和学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/netty/Netty%E4%BA%86%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.195Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    工作中需要集成一个TCP客户端，使用Java原生的<code>ServerSocket</code>写了一个demo，但是整合到项目中的时候发现原来的代码使用的是<code>Netty</code>，由于自己不是很了解，所以这次就来学习一下，首先按照惯例先了解Netty的基础概念。开始。</p>
<p>​    Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。（摘抄自百度百科）</p>
<p>​    也就是说，Netty是一个网络应用程序框架，是用来开发和网络服务有关的，所以本次的TCP服务端就使用的是Netty。同时，Netty是基于Java中的NIO的，但是Netty对NIO的封装比较友好。（大家都说java中的NIO烂的一塌糊涂，我也没有用过，只能顺大流了）另外，Netty吸收了很多的协议的实现经验，所以保证了易于开发并且性能稳定。说完了它的历史背景和所解决的问题，下面就要开始介绍一下Netty的一些基础组件，方便后面的理解。</p>
<ul>
<li><p>引导类。引导类分为服务端ServerBootStap、客户端BootStrap。引导类作用是将各个基础组件通过链式语法进行组装，服务端通过bind()进行启动,客户端通过connect()进行启动。</p>
</li>
<li><p>线程模型。</p>
<ul>
<li>Boss线程：负责接收客户端连接请求。</li>
<li>Worker线程：负责IO读写事件和任务处理(比如channel注册selector、channel绑定端口等)，通过inEventLoop()和MPSC(Multiple Producer Single Consumer)队列实现无锁化串行线程执行模型。</li>
<li>IO-Reactor：Netty可配置三种IO-Reactor线程模型,分别为单Boss线程处理客户端连接和IO读写、单Boss线程处理客户端连接-多Worker线程处理IO读写、多Boss线程处理客户端连接-多Worker线程处理IO读写。</li>
<li>NioEventLoopGroup：线程池，内部存储可用线程NioEventLoop，默认大小为2倍的cpu核数。</li>
<li>ThreadPerTaskExecutor：线程创建器，创建过程中会为线程重命名，并将其转换为FastThreadLocalThread类型。</li>
<li>Chooser：线程选择器，根据NioEventLoopGroup中线程数量采取不同策略选取可用线程。</li>
</ul>
</li>
<li><p>通道/业务逻辑处理</p>
<ul>
<li>Channel：数据传输通道,Netty对NIO中ServerSocketChannel和SocketChannel进行抽象和功能封装。</li>
<li>ChannelPipeline：业务逻辑处理链，采取责任链模式将事件进行传递交由ChannelHandler进行处理。Netty通过Synchronized关键字保证ChannelPipeline的线程安全性，实现ChannelHandler的动态添加和删除。事件传递：入站事件向后一个入站事件传递，出站事件向前一个出站事件传递，异常事件向后一个事件传递。</li>
<li>ChannelHandler：业务处理组件，分为入站处理、出站处理和入出站处理三种类型。特别注意ChannelHandler并非线程安全，因此最好实现一些无状态方法，或者通过线程安全容器和关键字保证数据的线程安全。</li>
<li>ChannelHandlerContext：存储业务处理组件上下文信息，保存ChannelHandlerContext-&gt;ChannelHandler的1:1映射关系，因为ChannelHandler可被共享重复使用，所以ChannelHandler-&gt;ChannelHandlerContext并不一定是一一映射。</li>
</ul>
</li>
<li><p>数据容器/编解码</p>
<ul>
<li>ByteBuf：Netty中数据存储的载体，根据内存类型、内存回收和API实现机制可分为Head/Direct、Pooled/UnPooled和UnSafe/非UnSafe三种类型。编解码：数据以二进制方式在服务端和客户端进行传输，接收数据后需要对数据进行解码，发送数据前需要对数据进行编码。</li>
<li>ByteToMessageDecoder：解码器，将累加的字节流数据进行decode，decode操作交由子类实现，通过fireChannelRead事件将解码后的数据向后传播。</li>
<li>MessageToByteEncoder：编码器，分配内存将数据写入ByteBuf，发起write事件将编码后的数据向前传播。</li>
</ul>
</li>
</ul>
<p>​    上面就是基于作用来介绍各个组件，还有一个图，这些都是拷贝自另一个博主的，总结的挺好的，但是不知道为什么不写了。。。博客地址：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/17ccfc1005f8">https://www.jianshu.com/p/17ccfc1005f8</a></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200618155425968.png" alt="image-20200618155425968"></p>
<p>  下面就说一下Netty的特点。（来自官网）</p>
<ul>
<li>丰富的缓冲区数据结构</li>
<li>通用的异步I/O API</li>
<li>基于拦截器链模式的事件模型</li>
<li>高级组件，实现更快的开发</li>
</ul>
<p>还有一个官网的图，看不懂也要看。。。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200618153050073.png" alt="image-20200618153050073"></p>
<p>​    感觉还是官网比较靠谱，我在各个博客找了很久，大部分都不是很好，后来感觉官网写挺不错的，同时官网上面也有jar包和文档，都比较齐全。</p>
<p>​    官网地址：<a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io</a></p>
<p>​    后面就是开始写demo了，简单介绍到这里就结束了，后面有机会也慢慢补上其他的概念。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/netty/Netty%E4%BA%86%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0/" data-id="ckupl1rr700186rup6e6q6aj4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/netty/Netty相关知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/netty/Netty%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2021-10-13T13:28:21.195Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NIO和BIO和AIO的区别"><a href="#NIO和BIO和AIO的区别" class="headerlink" title="NIO和BIO和AIO的区别"></a>NIO和BIO和AIO的区别</h2><ul>
<li>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。</li>
</ul>
<p>​    Linux对于IO的区分：</p>
<ul>
<li>阻塞IO模型：应用进程等待数据准备好，拷贝完后，处理数据。</li>
<li>非阻塞IO模型：如果数据没有准备好，返回一个错误，数据准备好后，拷贝完毕后，处理数据。</li>
<li>IO复用模型：Linux提供select/poll，可以检测多个通道数据是否就绪，当就绪后，调用回调函数。</li>
<li>信号驱动IO模型：调用一个信号处理函数，系统做其他事情，当数据准备就绪时，生成一个信号，通过信号回调通知程序读取数据。</li>
<li>异步IO：告知系统启动某个操作，让内核在完成操作后通知程序。和信号驱动的区别就是，拷贝过程中，异步IO也不会阻塞。</li>
</ul>
<h3 id="BIO相关知识点"><a href="#BIO相关知识点" class="headerlink" title="BIO相关知识点"></a>BIO相关知识点</h3><p>​    一般有一个独立线程负责监听客户端的连接，如果接收到客户端的请求，为每一个客户端的请求创建一个线程进行处理，处理完成后，通过输出流将返回信息返回给客户端。</p>
<p>​    还有就是通过线程池和同步队列实现的伪异步的IO通信框架。将套接字封装成一个Task，让后交给线程池处理。这样线程池可大可小，不会导致资源耗尽。</p>
<p>​    但是这样如果有一方接收速度较慢，另一方就会被阻塞。</p>
<h3 id="NIO相关知识点"><a href="#NIO相关知识点" class="headerlink" title="NIO相关知识点"></a>NIO相关知识点</h3><h4 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h4><p>​    Netty是一个高性能、异步事件驱动的NIO框架，所有的IO操作都是异步非阻塞的。</p>
<ul>
<li>缓冲区buffer。缓冲区是一个对象，包含要写入或者要读出的数据。BIO中是直接操作Stream，但是NIO是直接操作buffer。缓冲区类似于字节数组。</li>
<li>通道Channel。通道类似于一个自来水管，可以通过它读取和写入数据。网络数据通过通道读取和写入，并且通道是双向的。</li>
<li>多路复用器Selector。Selector会不断轮询注册其上的Channel，如果某个Channel有TCP连接、读或者写事件，这个Channel就会处于就绪状态，会被Selector轮询出来，进行后续的IO操作。</li>
</ul>
<h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><p>​    NIO可以监听多个通道，通过将通道注册到多路复用器上，如果某个通道有连接、读或者写事件，Selector会通过关键字获取Channel，将通道的消息写入buffer中，再进行后续的IO操作。</p>
<h3 id="AIO相关知识点"><a href="#AIO相关知识点" class="headerlink" title="AIO相关知识点"></a>AIO相关知识点</h3><p>​    AIO就是异步IO，程序启动后，不在原地等待程序执行结果，等到数据到了后，并且拷贝完毕后，异步通知原有程序，进行后续的数据处理。</p>
<h2 id="Netty相关知识点"><a href="#Netty相关知识点" class="headerlink" title="Netty相关知识点"></a>Netty相关知识点</h2><h3 id="Netty基础概念"><a href="#Netty基础概念" class="headerlink" title="Netty基础概念"></a>Netty基础概念</h3><ul>
<li>因为jdk自带的ByteBuffer只有一个指针用于读写操作，使用起来不是很方便，所以netty中的ByteBuf对其进行了优化。ByteBuf采用两个指针，读操作一个，写操作一个。数据的写入会导致写指针增加，读操作回导致读指针增加。但是读指针不能操过写指针，要不然会报错。调用discardReadBytes方法可以释放已经读过的区域。ByteBuf如果写入字节大于能写入字节，会进行动态扩展。<ul>
<li>discardable会将读过的字节清楚，将读指针和写指针向前移动。</li>
<li>clear会将指针变为初始位置，并不会清除缓存区的内容。</li>
<li>mark会将指针备份，rest会将指针恢复到备份到位置。读写指针都有这个方法。</li>
<li>ByteBuf有很多查找字节的方法。</li>
</ul>
</li>
<li>Channel：数据传输通道,Netty对NIO中ServerSocketChannel和SocketChannel进行抽象和功能封装。每个Channel都对应一个物理链接。</li>
<li>ChannelPipeline和ChannelHandler类似于过滤器，数据在ChannelPipeline中流转，ChannelHandler则对这些数据进行处理。底层的Channel触发事件，由EventLoop调用ChannelPipeline，将消息传输到ChannelPipeline中，再依次被各个Handler处理。<ul>
<li>Netty中的启动类会为每个Channel自动创建pipeline，获取pipeline然后将handler加入即可。</li>
<li>ChannelPipeline支持运行时动态添加或者删除Handler。</li>
<li>ChannelPipeline是线程安全的。使用的是synchronized关键字实现。</li>
</ul>
</li>
<li>EventLoop和EventLoopGroup：EventLoop是一个IO线程，但是除了负责读写外，还处理系统Task、定时任务。EventLoopGroup是个线程池，主要放置Accpetor线程或者IO线程。</li>
<li>Future：代表异步操作的结果，一般与Channel操作有关。</li>
<li>Promise ：是可写的Future，Netty通过Promise对Future进行扩展，用于设置IO操作的结果。</li>
</ul>
<p>​    Netty有三种线程模型：</p>
<ul>
<li>Reactor单线程模型：所有的IO操作都在同一个NIO线程上面完成，包括接受TCP连接信息，当链路建立后，将ByteBuf发送给Handler，进行消息解码。小容量可以使用，高并发不适合。</li>
<li>Reactor多线程模型：有一个单独的Acceptor线程监听服务端，接受客户端的请求，IO操作读或者写则由NIO线程池复杂，线程池包含一个队列和N个可用的线程，由这些线程复杂解码、处理。一个NIO线程可以处理多个链路，但是一个链路只对应一个线程，这样可以防止并发导致出现问题。单独的Acceptor线程在某些情况下可能会出现性能问题，如：认证情况下。</li>
<li>主从Reactor多线程模型：服务端用于接受客户端的连接也是一个独立的线程池，Acceptor仅仅用于客户端的登录、握手、安全认证。然后将Channel注册到IO线程池，让后续的IO线程对数据进行处理。</li>
</ul>
<h3 id="Netty具体流程"><a href="#Netty具体流程" class="headerlink" title="Netty具体流程"></a>Netty具体流程</h3><p>​    首先声明一个Channel，然后将这个通道注册到Selector，也就是BossGroup里面。当有客户端进行TCP连接时，把连接信息封装成 NioSocketChannel 注册到 WorkerGroup 线程中的 Selector。当 WorkerGroup 线程中的 Selector 监听到自己感兴趣的 IO 事件后，就调用 Handler 进行处理。</p>
<h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><h2 id="其他相关知识点"><a href="#其他相关知识点" class="headerlink" title="其他相关知识点"></a>其他相关知识点</h2><ul>
<li><p>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。</p>
</li>
<li><p>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。</p>
</li>
<li><p>Java中默认是大端模式。和TCP中的传输一致。</p>
</li>
<li><p>在操作系统层面上的零拷贝是指避免在用户态与内核态之间来回拷贝数据的技术。在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.</p>
</li>
<li><p>Netty的零拷贝完全是在用户态(Java层面)的，更多是数据操作的优化。主要有五点：</p>
<ul>
<li>Netty的接收和发送ByteBuffer使用直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li>
<li>Netty的文件传输调用FileRegion包装的transferTo方法，可以直接将文件缓冲区的数据发送到目标Channel，避免通过循环write方式导致的内存拷贝问题。</li>
<li>Netty提供CompositeByteBuf类, 可以将多个ByteBuf合并为一个逻辑上的ByteBuf, 避免了各个ByteBuf之间的拷贝。</li>
<li>通过wrap操作, 我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象, 进而避免拷贝操作。</li>
<li>ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf, 避免内存的拷贝。</li>
</ul>
</li>
</ul>
<h2 id="面试的问题"><a href="#面试的问题" class="headerlink" title="面试的问题"></a>面试的问题</h2><ul>
<li>介绍一下netty的线程模型</li>
</ul>
<p>​    说到netty的线程模型需要先说一下nio和aio的区别，NIO是内核通知应用可以读写，然后应用去进行读写操作，AIO不太一样，应用知识操作数据，对于读写操作由内核来完成，看起来像是异步的，就是应用要读写后立即返回。netty的线程模型就是基于reactor的。有很多线程模型，单线程模型、多线程模型、主从线程模型。单线程就是建立连接和读写操作都是一个线程，相当于一个线程干全部的活。弊端很明显，大量并发下，会导致系统的吞吐量降低。多线程模型就是一个 线程只用来建立连接，后面还有很多的线程用来处理读写操作，有点像boss和员工，boss找活干，员工来干活。netty中两个线程组就是这个名字。多线程其实已经满足我们项目的需要了，但是有些情况还是不能满足，像需要认证的情况，因为建立连接的线程还是一个，认证操作也比较耗时。就又了主从模型，还是一个线程建立连接，建立后将其交给boss线程组，这些线程主要进行认证这些比较耗时的操作，完成后，读写操作仍然交给后续的worker线程组。</p>
<p>* </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/netty/Netty%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ckupl1rr800196rup6qna38ud" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E6%8D%AE%E4%BD%8D%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E8%AE%B0%E5%BD%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>