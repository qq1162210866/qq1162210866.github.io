<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Hexo</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Java基础/HashMap中红黑树的代码解析（三）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/HashMap%E4%B8%AD%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="HashMap中红黑树的代码解析"><a href="#HashMap中红黑树的代码解析" class="headerlink" title="HashMap中红黑树的代码解析"></a>HashMap中红黑树的代码解析</h3><p>​    看到这里，红黑树的基本概念和操作都已经清楚了，如果条件允许的话，你说不定已经实际操作或者编写代码了。下面就来看一下JDK源码中对于红黑树的实现，再次巩固一下上面的知识。</p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>​    </p>
<p>​    如果当前节点链表超过8个，就调用树化方法、如果当前tab长度没有超过32，就扩容，如果超过32就将链表红黑树化</p>
<p>​    循环遍历将节点链表按照先后顺序复制给hd，然后将hd树化（梳理）</p>
<p>（断言检测不清楚作用）</p>
<p>​    取下一个节点</p>
<h4 id="使用情景和细节"><a href="#使用情景和细节" class="headerlink" title="使用情景和细节"></a>使用情景和细节</h4><p>红黑树颜色的作用是搭配起来使用的，</p>
<p>红黑树的维护平衡有很多方法，主要就是维护高度和节点颜色</p>
<p><a target="_blank" rel="noopener" href="http://www.doczj.com/doc/cffdb8b4e009581b6ad9eb1c-4.html">http://www.doczj.com/doc/cffdb8b4e009581b6ad9eb1c-4.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf">https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/HashMap源码分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><p>​    今天来看一下HashMap的源码，学习一下相关的知识点。不多啰嗦了，直接开始吧。</p>
<p>​    先看一段代码，是使用HashMap的代码，比较简单，先从代码入手。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Date&gt; test = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">test.put(<span class="string">&quot;test1&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">test.put(<span class="string">&quot;test2&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">test.put(<span class="string">&quot;test1&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">Date date = test.get(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">System.err.println(date);</span><br></pre></td></tr></table></figure>

<p>​    代码比较简单，建立一个map，存放date，先后放了三次，代表三个场景，第一次当map为空时放入、第二次放入不同的key，第三次放入相同key，但是value不同。最后取出第一次放入的key的value并且打印出来。下面就来具体看看源码，看看HashMap到底做了什么。</p>
<p>​    先看第一行代码，看到声明了一个map，执行了key和value的类型。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210228215831632.png" alt="image-20210228215831632"></p>
<p>​    构造函数只有一行，指定了负载系数，下面看一下这个负载系数是什么东西。<code>负载因子是在自动增加其哈希表容量之前允许哈希表获得的满度的度量。</code>不难理解，这个负载系数是map自动扩增的一个阈值。好像这个构造函数比较简单，只是简单的赋值了，也没有什么初始化的操作，别急，看看第二行代码吧。</p>
<p>​    第二行代码就是放入一个key为test，value为当前时间的操作。来看看<code>put(K key, V value)</code>做了什么。<code>put(K key, V value)</code>的代码只有一行。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210301161338805.png" alt="image-20210301161338805"></p>
<p>​    <code>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</code>是一个实现，看一下传参的含义，需要注意的参数不多，就一个hash值，下面看一下hash方法。<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210301161814463.png" alt="image-20210301161814463"></p>
<p>​    方法注释如下：<strong>计算key.hashCode（）并将哈希的较高位（XOR）扩展为较低。 由于该表使用2的幂次掩码，因此仅在当前掩码上方的位中发生变化的哈希集将始终发生冲突。 （众所周知的示例是在小表中包含连续整数的Float键集。）因此，我们应用了一种变换，将向下扩展较高位的影响。 在速度，实用性和位扩展质量之间需要权衡。 由于许多常见的哈希集已经合理分布（因此无法从扩展中受益），并且由于我们使用树来处理容器中的大量冲突集，因此我们仅以最便宜的方式对某些移位后的位进行XOR，以减少系统损失，以及合并最高位的影响，否则由于表范围的限制，这些位将永远不会在索引计算中使用。</strong>这边说一下自己的理解：这个方法返回的是int类型，四个字节，后面是用来确定key在数组中的下标，但是map中数组长度是有限制的，一般小于2^16，即65536。获取key下标的代码如下：<code>tab[i = (n - 1) &amp; hash]</code>（hash%n等价于(n - 1) &amp; hash）,也就是说只可能会和四个字节的低两个字节进行位运算，所以这里的hash方法作用也就不难判断出来，将hash值变得更加散乱，减少哈希冲突。这里的实现就是让hashCode和高16位进行异或运算（异或的运算不偏向于0或者1）。<code>hashCode()</code>方法调用底层C的代码，这里能力有限，就不再列出来叙述了。到这里，明白了HashMap并不是将hashCode直接拿来用，还是有一定的运算。这里参考了一片博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42034205/article/details/90384772">讲解hash方法</a></p>
<p>​    回到<code>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</code>方法，代码比较多，这里直接粘贴出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里初看代码有些不知道看哪里，可以按照最开始编写的代码去跑这个代码逻辑。下面就开始按照第二行代码梳理。</p>
<p>​    代码先是判断数组存不存在，数组每个位置存放的是一个节点链表。如果数组为空，就调用初始化方法<code>resize()</code>,这个方法可以放在后面讲，现在暂时略过，方法作用很简单，就是初始化或者增加表大小。下面就是根据哈希值获取key所在的下标，因为这里第一次放入，代码肯定位空，所以直接新建节点并且放入，next节点置为空。接着就来到了最后，判断当前负载系数是否超过最开始设置的值（默认0.75），如果超过，就再执行一次<code>resize()</code>.最后返回一个空。以上解析就是HashMap在放入第一个值时做的事，看着还是挺多的，下面接着看最开始编写的第三行代码。</p>
<p>​    第三行代码放入了一个不同的key，不同的value。按照上面的代码再走一遍，不过这个时候数组已经有了，不需要再次创建。但是因为key不相同，所以哈希值不相同（假设没有哈希冲突），所以后面的步骤就和上面的一样了：新建一个节点，放入到数组中。同时在最后也会对数组长度做判断，达到负载系数就扩容。那就来看第四行代码。</p>
<p>​    第四行代码是继续放入一个相同的key，但是value不同。仍然走上面的代码，发现数组已经创建，但是通过计算下标发现该下标已经有节点，执行了else部分。先是判断key是否相同，这里判断方法为：<code>hash值是否相等&amp;&amp;(两个key相等||两个key的eques方法返回true)</code>。看到这里，是不是也清楚了：重写eques方法一定要重写hashCode方法。因为如果这里没有重写hashCode方法，即哈希值不一定相同，就会造成相同的key，却有两个下标，导致后续的put无法覆盖掉原有的key。回到源码，看到else最后将原有的value取出，将新的放进去，并且将原有value返回，结束本次放入。（这里可能理解不太对，欢迎大佬们指正）</p>
<p>​    到了最后一行，将放入到值取出。看看源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码可以比较清晰的看到HashMap中<code>节点</code>这个概念的存储结构，先是找到哈希值所在的下标，再去判断节点的第一个到key是否相同（和上面所到判断方法一致），到这里，也就理解了：哈希值相同，eques方法不一定返回true。如果不是第一个元素，在开始遍历节点中的链表，一直到找到为止。到这里，最开始编写的代码也就全部解析完毕。中间的一些逻辑分支没有细说，东西都是大差不差，没有什么需要特别说的点。下面根据这个方法我找到了一个流程图。和下面的图片来源一样。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302141253511.png" alt="image-20210302141253511"></p>
<p>​    最后开始填上面的坑，resize方法。这个方法是比较重要的，属于map的扩容机制。先提一点，通过上面的解析，现在也大致清楚了HashMap中的结构，不仅仅的是一个数组，是将链表和数组的形式结合了起来。类似于下面这个形式。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302110441809.png" alt="image-20210302110441809"></p>
<p>​    这个图片来源于:<a target="_blank" rel="noopener" href="https://blog.csdn.net/login_sonata/article/details/76598675">Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法）</a>,后面的解析也参考了这个博客，讲解的比较清晰。</p>
<p>​    当数组到了一定的容量后，需要对数组进行扩容，扩容后也需要对元素的下标进行重新计算，resize方法完成的就是这些内容。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里按照讲解put方法的方式分析，按照两种情况进行解析。1.数组没有初始化的时候扩容。2.数组负载系数达到阈值时，对数组进行扩容。</p>
<ul>
<li><p>当数组没有初始化，先是将数组长度和长度阈值设置好，然后直接创建数组，将数组给全局变量就完成这一步骤。初始化比较简单，主要就是各个参数的设置。</p>
</li>
<li><p>当数组需要扩容时就比较复杂了，判断是否需要扩容这一部分就不再细说了，就是各个逻辑的梳理，按照代码来即可，没有什么可说的点。只需要记得扩容后就是将原有数组长度乘2，所以HashMap的数组长度只能是2的幂次方（包括你自己设置为13，也会自动寻找最近的2的幂次方）需要重点说的就是扩容后，将原有数组移植到新数组中。这里有两个分支不需要讲：1.链表长度超过8时转换为红黑树的实现（这部分包括put方法里面涉及红黑树的会单独写一个博客，留坑）。2.链表只有一个节点时的情况，比较简单，重新计算下标即可。重点中的重点就是，链表节点树为多个的情况。就是最后一个else里面的代码。</p>
<p>先看一个解析。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302113927205.png" alt="image-20210302113927205"></p>
<p>这个解析比较清晰，所以判断一个链表中改位置需不需要移动，就可以直接用<code>(e.hash &amp; oldCap) == 0</code>来判断，即直接将数组长度和哈希值与一下就能判断出高位是否会变化。如果等于零就不需要移动，不等于零，就需要移动到新的位置，新的数组下标为多少，上面的解析也能看出来，就是加8，即加上旧数组长度。这样的话，看这段代码就比较容易看懂了。循环遍历链表，再判断该节点是否需要移动，需要移动就放到高位节点链表中，不需要移动就放到低位节点链表中。创建四个节点也是为了方便放入，最后遍历完毕，将高低位的头节点放入到指定下标即可，完成了数组的迁移。</p>
</li>
</ul>
<p>​    至此，关于最开始编写的代码的解析都已经完毕了，剩下的红黑树实现和哈希表的原理因为能力有限，放到后面讲，要不然博客就太长了。在最后，欢迎各位大佬指正和批评。</p>
<p>​    就这样吧，结束。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/JUC学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/JUC%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>java中虚假唤醒的问题</p>
<p>if只会判断一次，但是while唤醒后还是会继续判断</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/Java中Lambda表达式学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Java中Lambda表达式学习"><a href="#Java中Lambda表达式学习" class="headerlink" title="Java中Lambda表达式学习"></a>Java中Lambda表达式学习</h2><p>​    上一篇博客了解了线程的相关学习，学习的过程中看到一个注解<code>@FunctionalInterface</code>，本次的博客就来学习一下函数式接口。函数式接口可以用Lambda来创建，所以函数式接口的学习应该在Lambda表达式前面。</p>
<p>​    先来看一下函数式接口的文档定义：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210218093905631.png" alt="image-20210218093905631"></p>
<p>可以发现几个重要的点：</p>
<ul>
<li>函数式接口只有一个抽象方法。</li>
<li>默认方法和覆盖方法都不计入抽象方法数目。</li>
<li>可以用Lambda表达式、方法引用、构造函数引用来创建函数式接口实例。</li>
<li>注解并不一定是必须的，只要符合要求，编译器会自动将接口视为函数式接口。</li>
</ul>
<p>​    下面看一个jdk中自带的函数式接口的实现，<code>Comparator</code>接口。发现里面有很多方法的实现，但是也使用了<code>@FunctionalInterface</code>注解，仔细再看，可以看到只有两个抽象方法，其他都是静态方法或者默认方法，都有实现。再看两个抽象方法，一个是继承了Object类的<code>equals</code>方法，所以最后这个接口只有一个抽象方法，符合函数式接口的定义。</p>
<p>​    下面就来看一下如何使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Description: 使用lambda表达式作为转换为函数式接口传递到Arrays.sort中第二个参数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2019-07-18</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arraySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String[] arrays = &#123;<span class="string">&quot;1237&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">       Arrays.sort(arrays, (first, second) -&gt; second.length() - first.length());</span><br><span class="line">       System.err.println(arrays[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    方法描述已经比较详细的介绍了这个方法的作用，因为<code>sort(T[] a, Comparator&lt;? super T&gt; c)</code>方法不是本篇博客的重点，所以不再叙述太多，简单理解为将数组中的元素按照给定的方法比较排序即可。这里第二个参数就是函数式接口，可以看到这里的传值为<code>(first, second) -&gt; second.length() - first.length()</code>,这个就是典型的Lambda表达式的应用，函数式接口的实现内容就是：返回用第二个参数的长度减去第一个参数的长度得到的值。但是我们还是有很多疑问的。下面一一去寻找答案。</p>
<ul>
<li><code>(first, second) -&gt; second.length() - first.length()</code>是什么意思，为什么这样写？换个方式<code>(String first, String second) -&gt; &#123;return second.length() - first.length();&#125;</code>这样是不是就可以看出大概了，知道这个是<code>Comparator</code>中接口方法<code>int compare(T o1, T o2);</code>的实现。</li>
<li>为什么不用声明参数类型，代码是如何知道我传入的类型？这个需要看一下方法<code>public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</code>，可以看到在调用soft方法时就已经声明了参数的类型，所以编译器就知道了这里是否正确，也是可以省略参数类型的原因。</li>
</ul>
<p>​    Lambda表达式的特征如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210218113001221.png" alt="image-20210218113001221"></p>
<p>​    下面开始编写自己的一个函数式接口的demo。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 测试使用的代码，分别要传入各自的参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Eatable e)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(e);</span><br><span class="line">		e.taste();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Flyable f)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我正在驾驶：&quot;</span>+f);</span><br><span class="line">		f.fly(<span class="string">&quot;【碧空如洗的日子】&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Addable add)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;5与3的和为：&quot;</span>+add.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 主方法，其中的方法参数都是使用lambda表达式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		demo1 demo1=<span class="keyword">new</span> demo1();</span><br><span class="line">		<span class="comment">//lambda表达式的代码只只有一句，可以省略“&#123;&#125;”</span></span><br><span class="line">		<span class="comment">//这里的lambda表达式实际上被当成任意的类型，具体的类型取决于运行环境的需要</span></span><br><span class="line">		demo1.eat(()-&gt;System.out.println(<span class="string">&quot;苹果的味道不错&quot;</span>));</span><br><span class="line">		<span class="comment">//方法的形参只有一个，可以省略“()”  weather是接口方法的形参</span></span><br><span class="line">		demo1.drive(weather-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;今天的天气是：&quot;</span>+weather);</span><br><span class="line">			System.out.println(<span class="string">&quot;直升机飞行平稳&quot;</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//代码只有一句，可以省略“&#123;&#125;”,同时也可以省略return关键字 a+b是返回值</span></span><br><span class="line">		demo1.test(Integer::sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试使用的接口,只有一个抽象方法的接口（函数式接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String weather)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    现在看这些代码是不是很容易就明白了。这里也就不再将代码进行详细解析。</p>
<p>​    函数式接口和其如何使用都已经了解了，下面就开始了解函数式接口有哪些使用方式，从最开始的文档中可以了解到，有三种方式去创建函数式接口实例。lambda表达式，方法引用或构造函数引用。Lambda表达式刚才已经看到并且使用到了，下面详细说一下方法引用和构造函数引用。</p>
<ul>
<li><p>方法引用。方法引用分为实例方法引用、静态方法引用和特定类型的方法引用。语法分别为：</p>
<ul>
<li>实例方法引用：<code>new instMethod()::method</code></li>
<li>静态方法引用：<code>类名::staticMethod</code></li>
<li>特定类型的方法引用：<code>类名::instMethod</code>（个人认为不常用）</li>
</ul>
<p>举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LambdaTrain6.java</span></span><br><span class="line"><span class="comment"> * Description: 博客中使用的练习demo，将方法引用汇集在一起</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTrain6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 第一个&lt;T&gt; 声明范型的类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2021-02-18</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T s)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是一个静态方法引用，有参数，但是没有返回值：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个普通方法引用，没有参数，但是返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是特定类型的方法引用&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态方法引用</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = LambdaTrain6::hello;</span><br><span class="line">        consumer.accept(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//普通方法引用</span></span><br><span class="line">        Supplier&lt;String&gt; supplier = <span class="keyword">new</span> LambdaTrain6()::put;</span><br><span class="line">        System.err.println(supplier.get());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.抽象方法的第一个参数类型刚好是实例方法的类型（函数式接口的抽象方法必须要有输入参数）。2.抽象方法剩余</span></span><br><span class="line"><span class="comment">         * 的参数恰好可以当做实例方法的参数。如果函数式接口的实现能由上面说的实例方法调用来实现的话，</span></span><br><span class="line"><span class="comment">         * 那么就可以使用对象方法的引用(两个条件都要满足)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BiConsumer&lt;LambdaTrain6, String&gt; biConsumer = LambdaTrain6::fun;</span><br><span class="line">        biConsumer.accept(<span class="keyword">new</span> LambdaTrain6(), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>构造方法引用 ，构造方法引用的语法就只有一种：<code>类名::new</code></p>
<p>举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LambdaTrain5.java</span></span><br><span class="line"><span class="comment"> * Description: lambda表达式练习，练习方法引用的构造方法引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTrain5</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果函数式接口的实现恰好可以通过调用一个类的构造方法来实现，那么就可以使用构造方法引用</span></span><br><span class="line"><span class="comment">     * 语法</span></span><br><span class="line"><span class="comment">     * 类名::new</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 主方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-08-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Person&gt; supplier = () -&gt; <span class="keyword">new</span> Person();</span><br><span class="line">        Supplier&lt;Person&gt; supplier1 = Person::<span class="keyword">new</span>;</span><br><span class="line">        supplier.get();</span><br><span class="line">        supplier1.get();</span><br><span class="line"></span><br><span class="line">        Consumer&lt;Integer&gt; consumer = (i) -&gt; <span class="keyword">new</span> Student(i);</span><br><span class="line">        Consumer&lt;Integer&gt; consumer1 = Student::<span class="keyword">new</span>;</span><br><span class="line">        consumer.accept(<span class="number">1</span>);</span><br><span class="line">        consumer1.accept(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有参构造器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Function&lt;String, Integer&gt; function = s -&gt; s.length();</span><br><span class="line">        Function&lt;String, Integer&gt; function1 = String::length;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + function.apply(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + function1.apply(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Function&lt;String, Student&gt; function2 = Student::<span class="keyword">new</span>;</span><br><span class="line">        function2.apply(<span class="string">&quot;hahahah&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 重写构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-08-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is Person&#x27;s construction method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have no parameter &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    学习了函数式接口的使用方式和练习了一些基本的demo，现在回头看Lambda表达式是不是就更加清楚其意思了。但是什么时候或者什么地方该用Lambda呢？这个问题我现在也没有很明白，后续会慢慢补充。<code>java.util.function</code>包下都是jdk自带的函数式接口，阅读完这些接口的含义可能会对函数式接口有了一个更加清晰的认识，说到底，Lambda表达式和函数式接口的存在还是为了让写代码更加清晰和简洁。万变不离其意。要在开发中你感觉可以使用Lambda的地方使用它，使用的多了，了解也就更加的深入了。</p>
<p>​    就这样吧，结束。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/Java中基础知识记录"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Java中基础运算符和知识点记录"><a href="#Java中基础运算符和知识点记录" class="headerlink" title="Java中基础运算符和知识点记录"></a>Java中基础运算符和知识点记录</h2><p>​    在阅读源码和其他的一些代码后，发现自己一些基础的运算符老是忘记（其实就是不懂。。。），所以专门写一篇博客记录一下，防止后续自己忘记。不多啰嗦，直接开始。</p>
<p>​    <code>&amp;</code>：与运算符，位运算符的一种，表示同一位都为1时，最后结果才为1。例子：<code>4&amp;6=4</code>（使用计算器将两个数都显示出来更加能够理解透彻）</p>
<p>​    <code>|</code>：或运算符，位运算符的一种，表示同一位只要有一个为1，最后结果就为1。例子：<code>4|6=6</code>。</p>
<p>​    <code>~</code>：非运算符，位运算符的一种，该位为1时，结果为0，该位为0时，结果为1。例子：<code>(byte)~4=0xFB</code></p>
<p>​    <code>^</code>：异或运算符，位运算的一种，表示同一位相同时最后结果为0，同一位不同时最后结果为1.例子：<code>4^6=2</code></p>
<p>​    <code>&gt;&gt;</code>：右移运算符，位运算符的一种，表示将操作数向右移动，移出的全部丢弃，左边的看符号位进行补全，如何符号为位0，则补0，反之补1。例如：<code>4&gt;&gt;2=2</code></p>
<p>​    <code>&lt;&lt;</code>：左移运算符，运算符的一种，表示将操作数向左移动，移出位置全部丢弃，右边全部补0.例如：<code>2&lt;&lt;2=4</code></p>
<p>​    <code>&gt;&gt;&gt;</code>：无符号右移运算符。位运算符的一种，表示将操作数向右移动，移出位置全部丢弃，左边全部补0.例如<code>-4&gt;&gt;&gt;2=1073741823</code></p>
<ul>
<li>补充：计算机中存储负数不是简单的符号位加后面的数，存储的是负数的补码，这样是方便两个数相加。例如-4的补码是0xFFFFFFFC,所以负数的无符号右移会和预想中的不一致。可以自己写写代码看一下。</li>
</ul>
<p>​    <code>布尔表达式?表达式1:表达式2</code>：三目运算符。如果布尔表达式为true，执行表达式1，为false，执行表达式2。例如：<code>a=1&gt;2?1:2</code>,最后a=2.</p>
<p>​    <code>&amp;&amp;</code>：逻辑与，逻辑运算符的一种。当两个条件都为true时，最后结果才为true，有一个不为true，最后结果就为false。</p>
<p>​    <code>||</code>：逻辑或，逻辑运算符的一种。当两个条件任意一个为true时，最后结果就为true，只有两个条件都为false，最后结果才为false。</p>
<p>​    <code>bread和continue的区别</code>：break跳出本层嵌套的循环，continue跳出本次的循环，并没有跳出循环体。</p>
<p>​    暂时就想到这些了，后续还会慢慢补充。</p>
<p>​    就这样吧，结束。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/Java中的参数传递类型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Java中的参数传递类型"><a href="#Java中的参数传递类型" class="headerlink" title="Java中的参数传递类型"></a>Java中的参数传递类型</h2><p>​    在阅读HashMap中的源码过程中，阅读到一些方法之间的调用涉及到参数传递，有些情况下感觉最后的结果和我想的不一样，所以特地了解了一下参数传递，在这里也记录一下，防止自己忘记。</p>
<p>[TOC]</p>
<h3 id="了解一些基础概念"><a href="#了解一些基础概念" class="headerlink" title="了解一些基础概念"></a>了解一些基础概念</h3><p>​    在学习参数传递之前需要先了解一些基础概念，这里也会给出实例代码。方便理解。</p>
<h4 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h4><p>​    参数传递在程序中是比较常见的。参数传递涉及到两个概念。形式参数和实际参数。下面就说一下两者的区别。</p>
<blockquote>
<p>形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数，简称“形参”。<br>实际参数：在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”，简称“实参”。</p>
</blockquote>
<p>​    Java也不例外，也存在形式参数和实际参数，在这里分别举个例子。</p>
<h4 id="形参和实参的举例"><a href="#形参和实参的举例" class="headerlink" title="形参和实参的举例"></a>形参和实参的举例</h4><p>​    形式参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(StringBuffer s, <span class="keyword">int</span> a)</span><span class="comment">//形式参数s和a</span></span></span><br></pre></td></tr></table></figure>

<p>​    实际参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">test(s, a);<span class="comment">//实际参数s和a</span></span><br></pre></td></tr></table></figure>

<p>​    看了上面的例子，是不是了解了形式参数和实际参数的区别。</p>
<h4 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h4><p>​    在程序语言中的参数传递类型有两种，分别为值传递和引用传递。两者的概念和区别如下：</p>
<blockquote>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<p>​    这里的举例用C来举例，用C的代码分别举例值传递和引用传递。</p>
<h4 id="值传递和引用传递的举例"><a href="#值传递和引用传递的举例" class="headerlink" title="值传递和引用传递的举例"></a>值传递和引用传递的举例</h4><p>​    值传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bef swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">    swap(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pass by value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    引用传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bef swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">    swap2(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass by reference</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面两个例子就是值传递和引用传递的区别，运行后也是不同的效果，还是比较明显的。c这一块不是很熟悉，代码可能有误，但是思想我认为传达到了。</p>
<h3 id="了解Java中的传递类型"><a href="#了解Java中的传递类型" class="headerlink" title="了解Java中的传递类型"></a>了解Java中的传递类型</h3><p>​    终于到了本文的正题了，开始讲解一下Java中的参数传递的机制和原理。在讲解之前，需要先了解一下JVM中的堆和栈的区别。</p>
<ul>
<li>栈内存。栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</li>
<li>堆内存。存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li>
</ul>
<p>​    可以简单的理解为方法中的变量都存储在栈中，实际的对象都存储在堆中。方法之间是不能够互相修改变量的。所以也就有了这种说法。<strong>Java中只存在值传递，不存在引用传递</strong>，因为本质上都是复制了一份副本，所以都是值传递。下面就开始讲解。</p>
<h4 id="对于传递类型的解析"><a href="#对于传递类型的解析" class="headerlink" title="对于传递类型的解析"></a>对于传递类型的解析</h4><p>​    Java中的参数分为两种，基本类型参数和引用数据类型，基本数据类型基本上没有什么分歧，都认为是值传递。主要分歧都在引用数据类型上。</p>
<p>​    在方法之间传递一个引用数据类型是，类似于这种<code>foo(User user)</code>,变量user相当于一个指针，指向了堆中实际的存储对象。在传递过程中，将指针进行复制，传递到foo方法中，两个变量是有区别的，但是指想的都是堆中同一个对象。</p>
<p>​    说的可能不太好理解，举一些例子来说明一下。</p>
<h4 id="举一些小例子"><a href="#举一些小例子" class="headerlink" title="举一些小例子"></a>举一些小例子</h4><ul>
<li>例子一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nativetrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferHKTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 调用海康SDK的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferHKTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        test(user);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user.name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    User(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    运行结果如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210317153823967.png" alt="image-20210317153823967"></p>
<p>​    这个运行结果好像和我们说的不一致，其实细想一下就明白了，方法传递的是一个指针的副本，最后指向的都是堆中的对象。修改这个对象后在主方法中当然可以起效。但是和引用传递还是有区别的，区别就是引用传递能修改真正的参数，但是Java中的传递并不行。可以再看一下下面一个代码示例。</p>
<ul>
<li>例子二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nativetrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferHKTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 调用海康SDK的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferHKTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        test(user);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    User(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210317154636836.png" alt="image-20210317154636836">    </p>
<p>​    只是简单的修改了一下，最后的结果就不一样了。这里将参数传递的变量进行初始化，相当于在堆中又创建了一个User对象，和主方法中的user对象所指向的对象是两个完全不同的对象，所以这里的修改也就没有起效。两次的打印也就不一样。</p>
<p>​    到这里，是不是对于Java中参数传递类型就更加清楚了一些。能力有限，如果文中有些错误，欢迎大佬指正。</p>
<p>​    本文也借鉴了一些博客，博客地址：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sum-41/p/10799555.html">深入理解Java中方法的参数传递机制</a></p>
<p>​    就这样吧，结束。</p>
<p>​    </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/Java代码实现ping命令"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0ping%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Java代码实现ping命令"><a href="#Java代码实现ping命令" class="headerlink" title="Java代码实现ping命令"></a>Java代码实现ping命令</h2><p>​    在一个项目中，遇到了一个问题，需要查看某个IP是否能够ping通，这里就直接使用Java代码实现了，记录一下。</p>
<p>​    先说一下实现的几个方法。</p>
<ul>
<li><p>Jdk1.5的InetAddresss方式</p>
</li>
<li><p>调用本机CMD</p>
</li>
<li><p>Java调用控制台执行ping命令</p>
</li>
</ul>
<p>​    下面也就不不废话了，直接上代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> network_train;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NetWorkTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 网络测试demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTrain</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 主方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ipAddress = <span class="string">&quot;192.168.16.127&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Jdk1.5的InetAddresss方式</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Jdk1.5的InetAddresss方式&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;主机的状态，&quot;</span> + pingforInetAddresss(ipAddress));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 直接调用CMD</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.err.println(<span class="string">&quot;直接调用CMD&quot;</span>);</span><br><span class="line">            <span class="comment">//pingForCMD(ipAddress);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;更加完善的调用CMD方法&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;主机的状态&quot;</span> + pingForExec(ipAddress, <span class="number">5</span>, <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: Jdk1.5的InetAddresss方式，返回值是true时，说明host是可用的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">pingforInetAddresss</span><span class="params">(String ipAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//超时应该在3秒以上</span></span><br><span class="line">        <span class="keyword">int</span> timeOut = <span class="number">3000</span>;</span><br><span class="line">        <span class="comment">// 当返回值是true时，说明host是可用的，false则不可。</span></span><br><span class="line">        <span class="keyword">boolean</span> status = InetAddress.getByName(ipAddress).isReachable(timeOut);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 直接调用CMD,方法直接将CMD窗口的信息打印出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pingForCMD</span><span class="params">(String ipAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process pro = Runtime.getRuntime().exec(<span class="string">&quot;ping &quot;</span> + ipAddress);</span><br><span class="line">            BufferedReader buf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    pro.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> ((line = buf.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">                System.out.println(line);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 更加完善的调用CMD方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pingTimes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeOut</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">pingForExec</span><span class="params">(String ipAddress, <span class="keyword">int</span> pingTimes, <span class="keyword">int</span> timeOut)</span> </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将要执行的ping命令,此命令是windows格式的命令</span></span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        String pingCommand = <span class="string">&quot;ping &quot;</span> + <span class="string">&quot;-c &quot;</span> + pingTimes + <span class="string">&quot; &quot;</span> + ipAddress;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">// 执行命令并获取输出</span></span><br><span class="line">            System.out.println(pingCommand);</span><br><span class="line">            Process p = r.exec(pingCommand);</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逐行检查输出,计算类似出现=23ms TTL=62字样的次数</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line">            <span class="keyword">int</span> connectedCount = <span class="number">0</span>;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connectedCount += getCheckResult(line);</span><br><span class="line">                <span class="comment">// 如果出现类似=23ms TTL=62这样的字样,出现的次数=测试次数则返回真</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> connectedCount == pingTimes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();   <span class="comment">// 出现异常则返回假</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != in) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 若line含有=18ms TTL=16字样,说明已经ping通,返回1,否則返回0.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> line</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCheckResult</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;控制台输出的结果为:&quot; + line);</span></span><br><span class="line">        String trueZF = <span class="string">&quot;time=&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (line.contains(trueZF)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行的截图如下：</p>
<p>​    成功的：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200615154620793.png" alt="image-20200615154620793"></p>
<p>​    失败的：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200615154550305.png" alt="image-20200615154550305"></p>
<p>​    下面就说说中间的问题。</p>
<p>​    一个是不同的电脑系统，代码中的命令是不一样的，我这里的是Mac os，所以命令和Windows上面的有所不同。</p>
<ul>
<li><p>Mac os（或者Linux）:ping -c 5 127.0.0.1 </p>
</li>
<li><p>Windows： ping 127.0.0.1 -n 5 -w 1000</p>
</li>
</ul>
<p>​    所以不同的系统要拼接的命令也是不一样的。然后就是需要注意最后结果的分析，我这里的代码是直接判断有没有<code>time=</code>,有就是成功了。大家也可以根据自己的需求对延迟做一定对要求，我这里比较简单，就没有写的太复杂。到这里就基本完成了。</p>
<p>​    就这样吧，结束。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/Java反射"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><ul>
<li>编译时的类型由声明对象来决定，运行时类型由赋值对象来决定。即编译看左边，运行看右边。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>静态代理：就是在运行前就存在代理的代码，代理类和原始类的关系在运行前就已经确定了。缺点时维护成本高，修改原始类时还要修改代理类。</li>
<li>动态代理：在程序运行期间，通过JVM反射等机制动态的生成代理类的代码，代理类和原始类的关系是在运行后才确定的。</li>
</ul>
<h3 id="反射基础概念"><a href="#反射基础概念" class="headerlink" title="反射基础概念"></a>反射基础概念</h3><p>反射指的是在运行状态中，对于任意一个类能够知道这个类的所有属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectionTrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射小练习</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//通过类的路径来获取Class</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 1 class.forName(&quot;类的路径&quot;)</span></span><br><span class="line"><span class="comment">          * 2 类名.Class</span></span><br><span class="line"><span class="comment">          * 3 实例.getClass</span></span><br><span class="line"><span class="comment">          */</span>          </span><br><span class="line">         Class a=Class.forName(<span class="string">&quot;ReflectionTrain.Sub&quot;</span>);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 1 newInstance: 弱类型。低效率。只能调用无参构造。</span></span><br><span class="line"><span class="comment">          * 2 new: 强类型。相对高效。能调用任何public构造。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         Base b=(Base)a.newInstance();</span><br><span class="line">         <span class="comment">//为什么打印的是 Sub？</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 子类强转为父类，向上转换</span></span><br><span class="line"><span class="comment">          * 通过向上转换，我们能够在编写程序时采用通用程序设计的思想，</span></span><br><span class="line"><span class="comment">          * 在需要使用子类对象的时候，通过把变量定义为父类型，我们可以通过一个变量，使用该父类型的所有子类型实例</span></span><br><span class="line"><span class="comment">          * 子类可以转换为父类，即父类引用指向子类对象。引用的属性是父类的，方法若果被子类重写则是子类的方法。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         b.f();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> * 测试类，测试子类与父类的关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub2</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Sub2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射相关的类：</p>
<ul>
<li>Class类：用来表示类的信息。</li>
<li>Field类：表示类的成员变量。</li>
<li>Method类：表示类的方法。</li>
<li>Constructor类：用来表示类的构造方法。</li>
</ul>
<p>获取Class的三种方法</p>
<p>​    获取Class对象有三种方法：1）通过对象方法。object.getClass();。2）调用类的Class属性，即：Object.class。3）通过Class类中的ForName方法获取，即：Class.forName(“类的全路径”).</p>
<p>​    创建对象的两种方式：调用类的newInstance()方法来创建、通过Class获取Constructor对象，再调用newInstance()方法，这种方法可以选定构造方法。</p>
<p>​    Java有5种方式来创建对象： 1、使用 new 关键字（最常用）： ObjectName obj = new ObjectName(); 2、使用反射的Class类的newInstance()方法： ObjectName obj = ObjectName.class.newInstance(); 3、使用反射的Constructor类的newInstance()方法： ObjectName obj = ObjectName.class.getConstructor.newInstance(); 4、使用对象克隆clone()方法： ObjectName obj = obj.clone(); 5、使用反序列化（ObjectInputStream）的readObject()方法： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }</p>
<h3 id="反射需要注意的"><a href="#反射需要注意的" class="headerlink" title="反射需要注意的"></a>反射需要注意的</h3><ul>
<li>子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。（可以通过反射获取父类的字段）</li>
<li>编译时的类型由声明对象来决定，运行时类型由赋值对象来决定。即编译看左边，运行看右边。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>静态代理：就是在运行前就存在代理的代码，代理类和原始类的关系在运行前就已经确定了。缺点时维护成本高，修改原始类时还要修改代理类。</li>
<li>动态代理：在程序运行期间，通过JVM反射等机制动态的生成代理类的代码，代理类和原始类的关系是在运行后才确定的。</li>
<li>Spring中的IOC使用到了反射，通过反射获取到配置里面类的实例对象，存入到Spring的bean容器中。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/Java基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><p>​    简单范型的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型练习类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParadigmTrain1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate[] dates = &#123;LocalDate.of(<span class="number">1996</span>, <span class="number">12</span>, <span class="number">9</span>), LocalDate.of(<span class="number">1997</span>, <span class="number">5</span>, <span class="number">15</span>), LocalDate.of(<span class="number">1998</span>, <span class="number">5</span>, <span class="number">15</span>)&#125;;</span><br><span class="line">        Pair&lt;LocalDate&gt; result = minmax(dates);</span><br><span class="line">        System.err.println(result.getFirst());</span><br><span class="line">        System.err.println(result.getSecond());</span><br><span class="line">      	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里可以通过参数的形式来推断出范型的类型，所以不需要输入范型的类型参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>);	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 输入的参数必须要实现Comparable。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> paradigmtrain.Pair&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个范型是对参数进行限制，第二个是返回的类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((a == <span class="keyword">null</span>) || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T min = a[<span class="number">0</span>];</span><br><span class="line">        T max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> aLength = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aLength; i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 比较大小，通过compareTo方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>范型方法类型变量要放在方法修饰符后面，返回类型前面。</li>
<li>范型里面，尖括号里面是类代表一个点，如果带有问号，代表一个范围。</li>
<li>限定列表中如果存在类，则必须为限定列表中的第一个。（接口需要放在类后面）</li>
<li>基本数据类型不能用于范型。</li>
<li>范型的查询只能判断原始类型，例如: <code>a instanceof Pair&lt;String&gt;</code> 只能判断a是否是任意一个类型的Pair。</li>
<li>编译器会将范型类型转换为原始类型（类型擦除），有限定类型就使用第一个限定类型，没有就用object代替。返回类型时，由于返回的为限定类型或者为Object，会将限定类型或者Object强制转换为对应的类型。</li>
<li>不允许创建参数化类型的数组。例如<code>Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]</code> 这样是错误的。（可以通过注解消除这个警告）因为范型擦除的存在，所以会将类型进行擦除，导致存储的元素可能不一致。（存储Integer和String都是可以的）</li>
<li>推荐通过功能性接口（Supplier）来实例化类型变量，反射也可以实现，但是比较麻烦。</li>
<li>不能构造范型数组，例如<code>public static &lt;T&gt; T[] minmax(T[] t)</code>这种写法是错误的。这里也是可以利用函数式接口实现。</li>
<li>范型类中，静态代码中的类型变量无效。（因为类型擦除的原因，返回的Onject不知道转换为那种类型）</li>
<li>不能抛出或者捕获范型类的实例。</li>
<li>范型类之间不存在继承关系，无论S和T什么关系，<code>Pair&lt;S&gt;和Pair&lt;T&gt;不存在继承关系</code></li>
<li>如上面所说，<code>Pair&lt;Object&gt;和Pair&lt;String&gt;</code>不存在继承关系，但是方法中想要使用这样的关系如何写呢？这个时候就要用到通配符类型，即？,代码如下：<code>public static void test(Pair&lt;? extends Object&gt; p)</code>这样就可以传String和Integer.通配符类型上届使用extends，下届用super。上届一般用于读取，下届一般用于写入。</li>
<li>桥方法是为了保持多态，具体的原因如下代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * paradigmTrain3.java</span></span><br><span class="line"><span class="comment"> * Description: 范型方法桥方法练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">paradigmTrain3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base&lt;Date&gt; base = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">//这里调用的应该是setFirst(Date date),但是实际会调用setFirst(Object date)</span></span><br><span class="line">        base.setFirst(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是子类的覆盖方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里编译后会生成一个桥方法，为了维持多态</span></span><br><span class="line"><span class="comment">//    public void setFirst(Object date)&#123;</span></span><br><span class="line"><span class="comment">//        setFirst((Date) date);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul>
<li>封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。</li>
<li>继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。</li>
<li>多态：按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。即父对象可以根据赋值的不同子对象调用不同的方法。即调用子对象重写的方法。</li>
<li>抽象：抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法。即将生活中的万物形容成一个个类。</li>
</ul>
<ul>
<li>类与类之间最常见的关系主要有三种：依赖(uses-a)、聚合(has-a)和继承(is-a)。依赖就是屠夫使用刀、聚合就是大雁组成雁群，大雁相对于雁群是聚合关系（两个不同的类）、继承就是儿子继承父亲的家业。</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>简单的内部类代码：</p>
<ul>
<li>内部类就是定义在一个类中的类，最开始的作用就是简化代码，比较便捷。还有就是内部类完善了多重继承，每个内部类都可以独立继承一个接口的实现，但是感觉相对于它所带来的复杂程度而言，带来的便捷性其实不是很好，也可能是我学的比较浅。</li>
<li>内部类对象有一个隐式的引用，指向了实例化该内部类对象的外部类对象。</li>
<li>不需要内部类引用外部类的时候，可以使用静态内部类。</li>
<li>静态内部类创建实例的形式和普通内部类不太一样 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通内部类</span></span><br><span class="line">Out out=<span class="keyword">new</span> Out();</span><br><span class="line">out.in in=out.<span class="function">new <span class="title">in</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line">Out.In in=<span class="keyword">new</span> Out.In();</span><br></pre></td></tr></table></figure>

<ul>
<li>双括号初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双括号的使用方法，匿名列表，适用于只使用一次的数组列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;String&gt; test = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;hah&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><ul>
<li><p>成员内部类</p>
<ul>
<li>成员内部类不能使用static方法和变量</li>
<li>只有创建了外部类才能创建内部类</li>
</ul>
</li>
<li><p>局部内部类</p>
<ul>
<li>可以引用局部变量，但是局部变量必须声明为final（jdk1.8之前）</li>
</ul>
</li>
<li><p>匿名内部类</p>
<ul>
<li>匿名内部类不能有构造方法（构造方法必须和类名相同）</li>
<li>匿名内部类没有访问修饰符</li>
</ul>
</li>
<li><p>静态内部类</p>
<ul>
<li>静态内部类只能访问外部类的静态成员和方法</li>
<li>静态内部类的创建不需要依赖于外部类的对象</li>
</ul>
</li>
</ul>
<h2 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h2><ul>
<li><code>==</code>当两边的是基本类型时，对比的是值，当两边是引用类型时，比较的内存地址。当两边一个基本一个引用时，因为Java自动拆包，所以也是判断值是否相等。</li>
<li>count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0。</li>
<li>非new生成的Integer和new生成的Integer结果只能为false，两个非new比较时，都在-128-127内，比较值，否则比较地址。</li>
<li>+=会自动装箱，将运算的结果转换为相应的类型。<code>byte a = 127;byte b = 126;b = a + b;(错误) b+=a;(正确)</code></li>
<li>自动装箱只能装相应的类型，没法自动转换。</li>
<li>三元运算符会自动做类型提升。</li>
<li>&amp;是逻辑与，会计算两边的等式，&amp;&amp;是短路与，某些情况下只计算左边的等式。｜和｜｜的区别类似。</li>
<li>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。</li>
<li>while循环就是当条件不满足时，跳出，无论while还是dowhile，只不过dowhile第一次无论如何都会执行。</li>
<li>如果不加break，是从case语句匹配的位置往下一直执行</li>
<li>取余取头，取模取尾。java中的%是取余运算，看头。即最后结果的符号看运算符的前面还是后面。</li>
<li>同名方法，不同参数是重载，父类和子类之间是重写。</li>
<li>重写方法时，访问权限不能比父类中被重写的方法的访问权限更低，父类为public，子类不能为private。</li>
<li>编译看左边，运行看右边。 ClassA a = new ClassB();编译时为ClassA，运行时为ClassB。</li>
<li>finally是在return执行之后，语句返回之前执行的。</li>
<li>二维数组定义，一维长度必须定义，二维可以后续定义。</li>
<li>类中的变量可以不用初始化，但是方法中的变量声明后一定要初始化。</li>
<li>try块后面可以不加catch块，但是必须要有finally和catch之一。</li>
<li>Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整。</li>
<li>str.split(&quot;,&quot;)方法是把str字符串根据分割符&quot;,&quot;划分成一个字符串数组，如果str字符串中找不到分隔符&quot;,&quot;，则把整个str字符串放入字符</li>
<li>replaceAll方法的第一个参数是一个正则表达式，.代表所有字符。</li>
<li>如果字符串长度没有初始化长度大，capacity返回初始化的长度，如果append后的字符串长度超过初始化长度，capacity返回增长后的长度。</li>
<li>JSP中：application可以被web应用程序访问，session可以被同一对话访问，request可以被同一请求访问，pageContext可以被当前页面访问。</li>
<li>子类抛出的异常不能比父类的更加广泛，更加广泛的异常类的catch块要放在下面。</li>
<li>所有的异常都是继承Throwable，下层分为Error和Exception，Error描述了Java运行时系统的内部错误和资源耗尽错误。Exception分为运行时异常和其他异常。</li>
<li>Error和Exception都是集成Throwable,其中Exception又被IOException和RuntimeException继承。</li>
<li>枚举类默认的toString方法会将字符串打印出来。</li>
<li>串数组的第一个元素。</li>
<li>静态代码块可以分开写。</li>
<li>导包只可以导到当前层。</li>
<li>包装类的值都是不可变的。</li>
</ul>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><ul>
<li>抽象类是类的抽象化，接口则是抽象方法的集合。抽象类可以被实现类继承，接口则只能被实现类实现。抽象类是自下而上的设计理念，接口则是自上而下的设计理念。两个都不能被实例化。</li>
<li>接口就是在不同层面对一类事物的抽象描述。例如：在生物层面，人和猪都是会吃东西的。但是不同的层面，人和猪可能就不是同一类事物。</li>
<li>抽象类可以存在普通成员变量和静态成员变量，也可以存在静态方法和构造方法、普通方法。接口可以存在成员变量，但都是静态的。接口在1.8之后可以定义静态方法。</li>
</ul>
<h2 id="继承相关的"><a href="#继承相关的" class="headerlink" title="继承相关的"></a>继承相关的</h2><ul>
<li>在构造方法中如果使用关键字 <code>this</code> 调用其他构造方法，则 <code>this(参数列表)</code> 语句必须出现在其他语句之前。super是调用父类的某个构造函数，也必须在第一行。两者不能同时出现在一个函数里面。两者都不能在static中使用。</li>
<li>不会初始化子类的几种、调用的是父类的static方法或者字段、调用的是父类的final方法或者字段、通过数组来引用。</li>
<li>如果构造方法没有显式地调用同一个类中其他的构造方法或父类的构造方法，将隐性地调用父类的无参数构造方法，即编译器会把 <code>super()</code> 作为构造方法的第一个语句。</li>
<li>静态代码块只执行一次，构造代码块只要创建对象就会执行。</li>
<li>java语言是静态多分派，动态单分派的。 如果是重载方法之间的选择，则是使用静态类型。 如果是父类与子类之间的重写方法的选择，则是使用动态类型。 如A a = new B(); 会使用类型B去查找重写的方法，使用类型A去查找重载的方法。</li>
</ul>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>byte的数值为-128-127，因为-0表示为128</p>
<ul>
<li><p>原码：计算机中将一个数字转换为二进制，并在其最高位加上符号的一种表示方法。</p>
</li>
<li><p>反码：根据表示规定，正数的反码就是本身，而负数的反码，除符号位外，其余位依次取反。</p>
</li>
<li><p>补码：根据表示规定，正数的补码就是本身，而负数的补码，是在其反码的末位加1。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础/Java并发"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E5%B9%B6%E5%8F%91/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="并发的基本特性"><a href="#并发的基本特性" class="headerlink" title="并发的基本特性"></a>并发的基本特性</h3><ul>
<li>并行指多个cpu同时执行多个任务，并发是指一个cpu按照时间片轮流执行多个任务。</li>
<li>进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。例如qq就是操作系统中的一个进程。切换进程的开销比较大。线程是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个进程内部可能存在多个线程。线程的切换开销要比进程小的多。qq上面能够同时听音乐和看视频就是不同的线程。</li>
<li>并发的三个特点：原子性、可见性、有序性。原子性是指一个线程内的多个操作要么全部执行，要么都不执行。可见性是指当一个线程修改了一个变量的值时，其他线程要立即看到修改的值。有序性指代码在机器中的执行顺序和代码的编写顺序一致。</li>
<li>线程池整体流程：首先设置核心线程数和最大线程数，然后提交任务，任务小于核心线程数时，是慢慢创建线程执行任务的，当执行的任务超过了核心线程数，就将后续的任务放入队列中，当队列满了时，创建非核心线程。当峰值过了后，将非核心线程数超时销毁。如果更多，就直接执行拒绝策略，通知任务提交失败，执行失败后的方法。</li>
<li>饿汉单例模式和双检锁单例模式是线程安全的，懒汉式线程模式是线程非安全的。</li>
</ul>
<h3 id="关于锁"><a href="#关于锁" class="headerlink" title="关于锁"></a>关于锁</h3><ul>
<li>死锁：两个或两个以上的线程在执行过程中，因为争夺对方手中的资源而导致相互等待的现象。比如AB两个线程，A线程拿到1资源，B线程拿到2资源。互相需要对方的21资源，结果两个线程都在等待，造成死锁。</li>
<li>死锁的解决办法。1）让线程步骤一致的获取资源。2）让多个线程尽量不要获取相同的资源。3）如果发现自己需要的资源上锁了，放弃手中的资源，再等待。</li>
<li>synchronized的实现：每一个对象都有一个锁，并且该锁也只有一个内部条件。如果使用synchronized声明方法，该对象的锁就会保护整个方法。静态方法也可以使用synchronized声明，声明后，其他线程无法使用这个类的全部静态方法。普通方法和其他静态方法仍然可以使用。synchronized无论执行完毕或者抛出异常，都会放弃锁。</li>
<li>synchronized和Lock的区别：Lock可以设定超时时间、synchronized无法获得锁的状态，Lock获取锁时会给失败还是成功、synchronized锁的条件比较单一。synchronized使用的是非公平锁，Lock支持非公平锁（默认）和公平锁。</li>
<li>volatile不能保证数据的修改具有原子性。只能保证可见性和有序性。线程1修改一个共享变量时，JVM 会把该线程1对应的本地内存中的共享变量值立即刷新到主内存。当线程2读取时，JMM 会把该线程2对应的本地内存置为无效。线程2接下来将从主内存中读取共享变量。有序性就是代码不会被重新编排。</li>
<li>Happens-Before原则就是为了解决可见性的问题，制定了8个原则，这8个原则梳理出分割线，给程序的运行制定了指导方向。程序顺序规则、锁定规则、volatile变量规则、线程启动规则、线程结束规则、中断规则、终结器规则、传递性规则。</li>
<li>synchronized和volatile的区别：voaltile只能用在变量级别，synchronized可以用在方法和类上。volatile只能保证变量的可见性和有序性，不能保证原子性，synchronized可以保证原子性。volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>悲观锁就是在修改数据的时候默认其他线程也会修改，所以在修改数据时会上锁，修改完毕后将锁释放。乐观锁就是修改数据时默认其他线程不会修改数据，修改完毕后要更新时，如果发现数据被修改了，丢弃自己的操作，如果没有修改，则执行更新。</li>
<li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。但是CAS存在ABA问题，即线程修改为B后又修改回A。可以通过添加版本号的形式来解决这个问题。</li>
<li>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li>
<li>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li>
<li>阻塞队列的流程如下：许多线程向阻塞队列中取出指令并且执行相应命令，如果有生产者插入队列中新的元素但是队列长度已经满了，生产者的插入就会被阻塞。消费者移除一个元素时，阻塞队列如果为空，移除操作也会阻塞。</li>
<li>原子操作意为不可中断的一个操作。在Java中通过锁和循环CAS实现原子操作。原子类有很多，例如AtomicInterge、AtomicArray。</li>
<li>ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。</li>
<li>CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转，翻译成人话就是循环，一般是用一个无限循环实现。这样一来，一个无限循环中，执行一个 CAS 操作，当操作成功，返回 true 时，循环结束；当返回 false 时，接着执行循环，继续尝试 CAS 操作，直到返回 true。</li>
<li>AQS是指抽象队列的同步器。定义了一套多线程访问共享资源的同步框架，</li>
</ul>
<h3 id="关于集合中的线程安全问题"><a href="#关于集合中的线程安全问题" class="headerlink" title="关于集合中的线程安全问题"></a>关于集合中的线程安全问题</h3><ul>
<li><p>HashMap是线程不安全的，它的不安全主要体现在扩容时，因为多个线程的操作，可能会导致环链，即头尾向连，无限循环。具体的实现原理可以看集合那一篇。</p>
</li>
<li><p>ConcurrentHashMap是线程安全的。它是通过分段锁的形式来解决并发读写的问题的。多个线程读写不同的Segment，是没有影响的。AB同时读写同一个Segment，也是没有影响的。AB同时写，会导致AB中间一个阻塞。保证可见性则是使用voliate关键字。ConcurrentHashMap是采用CAS+Synchronized来实现锁的。segment的多少也指ConcurrentHashMap的并发度，一般是16.</p>
</li>
<li><p>String效率较低，StringBuffer和StringBuilder修改频繁时效率较高并且占用内存少，前者线程线程安全，后者多线程状态下可能会出现问题。</p>
</li>
<li><p>SynchronizedMap是通过锁住一整张表来实现线程安全的，效率相对于ConcurrentHashMap很低。</p>
</li>
<li><p>CopyOnWriteArrayList，写数组的拷贝，支持高效率并发且是线程安全的,读操作无锁的ArrayList。所有可变操作都是通过对底层数组进行一次新的复制来实现。CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里。</p>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>实现原理：每个线程都有一个ThreadLocalMap，这个map的key就是弱引用指向的ThreadLocal对象，value就是你要放入值。每个线程都可以获取自己线程独有的map，从而获取对应ThreadLocal对象的值。也就是value。</p>
<p>可能出现的问题：可能出现的问题就是内存溢出。因为Thrad中map存放的key是弱引用，所以在垃圾回收的时候会将这个弱引用回收，导致key为null。无法获取value，时间长了，慢慢就会导致内存溢出。可以在使用完毕后，调用remove方法解决这个问题，同时在ThreadLocal的get方法也会清楚nullkey。</p>
<p>缓存</p>
<p>当ThreadLocal不用时，将其置为空，因为Thread中的map的key是弱引用，所以在下一次垃圾回收时，会直接将这个对象回收，避免造成内存溢出。如果强引用的话，因为key一直指向ThreadLocal，所以一直不会回收。</p>
<p>当key为null时，这个时候无法访问到value，所以可能会造成内存溢出。可以通过remove方法来避免。本身调用get方法到时候也会将null值回收。</p>
<h3 id="HashMap中存在的线程安全问题"><a href="#HashMap中存在的线程安全问题" class="headerlink" title="HashMap中存在的线程安全问题"></a>HashMap中存在的线程安全问题</h3><p>​    安全问题有几点：扩容时出现链表死循环的现象、扩容的时候出现数据丢失的情况、size在多线程操作的时候也会出现不正确的情况、put方法时，hash冲突会出现数据丢失的情况。</p>
<p>​    负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p>
<p>hashmap如何putnull值，会将这个元素放在第0个坐标。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>