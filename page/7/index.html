<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-qq1162210866.github.io/博客/Java基础/第十四章、并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E3%80%81%E5%B9%B6%E5%8F%91/" class="article-date">
  <time datetime="2021-10-13T13:28:21.188Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java中并发了解和学习"><a href="#Java中并发了解和学习" class="headerlink" title="Java中并发了解和学习"></a>Java中并发了解和学习</h2><p>​    了解Java中的并发需要先清楚进程和线程的区别</p>
<p>​    进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p>​    线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<p>​    说的更加通俗一点，进程相当于你电脑运行的各个软件，满足的你的不通需求。线程相当于进程中更加小的进程，例如打游戏时，你既可以看到画面，也能听到游戏的声音，这里就是不同的线程。线程和进程的区别本质在于进程之间的变量不通用，但是线程之间时通用的，所以线程之间的通信要比进程有效的多。同时，创建、撤销线程要比进程开销要小得多。下面就来讲讲Java中的线程和并发。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>​    线程的状态有六种。新创建、可运行、被阻塞、等待、计时等待、被终止。这六种状态的图序如下图。<img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_CC357226F5D1-1.jpeg" alt="IMG_CC357226F5D1-1"></p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><p>​    说完了线程的状态，下面就要说一下线程的属性，线程的属性有线程优先级、守护线程、线程组、未捕获异常的处理器。</p>
<ul>
<li> 需要注意的是Java中线程的优先级依赖于底层系统的计算，说到底Java还是属于应用层，系统底层也有着自己的优先级，所以优先级的设置只能使该线程在Java中的优先级较高，在底层的优先级不能够确定。</li>
<li>当虚拟机中只剩下守护线程时，虚拟机就退出了，守护线程，字如其意，有其他线程让守护线程守护，守护线程才有意义。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>​    并发其实要解决的问题就是多个线程共同使用统一资源的问题（可能有误，欢迎指正）。Java为了防止代码块被并发的访问，最后导致数据的不稳定性。Java提供了一个syncchronized关键字，同时也提供了一个ReentrantLock类。下面就举一个简单的例子。银行转账（大家都用这个例子，我也用）。如果让一百个线程，随机往100个用户里面随机转账，转账完毕后就睡眠。最开始还能保持总金额没有变化，但是随着运行时间越来越长，总金额有可能变大也有可能变小，但是很小的可能会仍然保持不变。这种不确定性就是程序员最害怕的。下面也是用ReentrantLock类来改善这个例子，每次转账时对金额上锁，达到总金额不变的目的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockBank.java</span></span><br><span class="line"><span class="comment"> * Description: 带锁的银行类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Lock banlLock;</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customerNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockBank</span><span class="params">(<span class="keyword">int</span> customerNum, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 填充数值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="keyword">double</span>[customerNum];</span><br><span class="line">        Arrays.fill(accounts, balance);</span><br><span class="line">        banlLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        sufficientFunds = banlLock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 转账方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> money)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        banlLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (accounts[from] &lt; money) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                sufficientFunds.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.err.println(Thread.currentThread());</span><br><span class="line">            accounts[from] -= money;</span><br><span class="line">            System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>, money, from, to);</span><br><span class="line">            accounts[to] += money;</span><br><span class="line">            System.out.printf(<span class="string">&quot;the total balance is %10.2f&quot;</span>, getTotalbalance());</span><br><span class="line">            sufficientFunds.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            banlLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取所有的余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalbalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        banlLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> a : accounts) &#123;</span><br><span class="line">                sum += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            banlLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取当前客户人数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCustomerNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BankMain.java</span></span><br><span class="line"><span class="comment"> * Description: 银行测试的主方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MACCOUNTS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> INITIAL_BALANCE = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MAX_AMOUNT = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockBank lockBank = <span class="keyword">new</span> LockBank(MACCOUNTS, INITIAL_BALANCE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MACCOUNTS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> fromeaccount = i;</span><br><span class="line">            Runnable r = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> toaccount = (<span class="keyword">int</span>) (lockBank.getCustomerNum() * Math.random());</span><br><span class="line">                        <span class="keyword">double</span> money = MAX_AMOUNT * Math.random();</span><br><span class="line">                        lockBank.transfer(fromeaccount, toaccount, money);</span><br><span class="line">                        Thread.sleep((<span class="keyword">int</span>) (DELAY * Math.random()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不难看到，总金额运行后是一直保持不变的。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201214212715997.png" alt="image-20201214212715997"></p>
<p>​    但是这个办法只能用于单个机器，多服务器的情况下仍然会出现金额错乱的情况。使用synchronized关键字的代码如下，只是附上了银行类的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SyncBank.java</span></span><br><span class="line"><span class="comment"> * Description:Java关键字synchronized 的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncBank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customerNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncBank</span><span class="params">(<span class="keyword">int</span> customerNum, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 填充数值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="keyword">double</span>[customerNum];</span><br><span class="line">        Arrays.fill(accounts, balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 转账方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> money)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (accounts[from] &lt; money)</span><br><span class="line">            wait();</span><br><span class="line">        System.err.println(Thread.currentThread());</span><br><span class="line">        accounts[from] -= money;</span><br><span class="line">        System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>, money, from, to);</span><br><span class="line">        accounts[to] += money;</span><br><span class="line">        System.out.printf(<span class="string">&quot;the total balance is %10.2f&quot;</span>, getTotalbalance());</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取所有的余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getTotalbalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> a : accounts) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取当前客户人数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCustomerNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如何选择这些？怎么知道自己需要哪个？1.不要使用Lock/Condition或者synchronized,多数情况下可以使用阻塞队列来同步完成一个共同任务的线程。2.如果能使用synchronized，尽量使用，可以减少代码，从而达到减少出错的机会。3.如果需要使用到Lock\Condition的特性，才使用Lock\Condition。(书上抄的，就这样吧)</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>​    阻塞队列是为了更加优雅的解决上面的问题，如果开发者太多的参与底层的编写，这个是不合理并且不切实际的。所以就有了阻塞队列的产生，用来解决线程之间共享资源的问题。阻塞队列的流程如下：许多线程向阻塞队列中取出指令并且执行相应命令，如果有生产者插入队列中新的元素或者消费者移除一个元素时，阻塞队列会导致线程阻塞。队列会自动的平衡负载。</p>
<p>下面就来简单编写一个阻塞队列的demo。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BlockingQueueTrain.java</span></span><br><span class="line"><span class="comment"> * Description:  阻塞队列的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FILE_QUEUE_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEARCH_THREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File DUMMY = <span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;File&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(FILE_QUEUE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(System.in)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your directory eg: /Users/pengshiquan/Desktop/Developmentcache/JavaTrain/src/syncTrain&quot;</span>);</span><br><span class="line">            String directory = in.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your keyword eg volatile&quot;</span>);</span><br><span class="line">            String keyword = in.nextLine();</span><br><span class="line">            Runnable enumerator = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    enumrate(<span class="keyword">new</span> File(directory));</span><br><span class="line">                    <span class="comment">//通过添加&quot;包尾&quot;来达到通知的效果</span></span><br><span class="line">                    queue.put(DUMMY);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(enumerator).start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; SEARCH_THREADS; i++) &#123;</span><br><span class="line">                Runnable searcher = () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">                            File file = queue.take();</span><br><span class="line">                            <span class="keyword">if</span> (file == DUMMY) &#123;</span><br><span class="line">                                queue.put(file);</span><br><span class="line">                                done = <span class="keyword">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> search(file, keyword);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">new</span> Thread(searcher).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 列举目录下所有的文件或者目录，添加到队列中.会循环遍历目录的目录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory 需要列举的文件夹或者文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/12/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enumrate</span><span class="params">(File directory)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        File[] files = directory.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) enumrate(file);</span><br><span class="line">            <span class="keyword">else</span> queue.put(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 搜索文件中是否含有关键字，有就打印出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file    需要搜索的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyword 搜索时的关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/12/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(File file, String keyword)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(file, <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> lineNumber = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (in.hasNextLine()) &#123;</span><br><span class="line">                lineNumber++;</span><br><span class="line">                String line = in.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (line.contains(keyword)) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s:%d:%s%n&quot;</span>, file.getPath(), lineNumber, line);</span><br><span class="line">                    <span class="comment">//想法是测试队列的公平性，但是测试结果和预想的不太一样</span></span><br><span class="line">                    <span class="comment">//System.err.println(Thread.currentThread().getId());</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面也没有什么难点，说一下大致的思路。这个demo的目的是为了检索用户输入的目录下所有文件含有关键字的行，并且打印该行。demo先是创建一个线程，用来将用户输入的目录下所有的文件或者文件夹放入队列中，另外起大量线程，用来检索文件内是否含有指定关键字。中间一部分代码和预想中的不一致，目前能力有限，也无法验证。就是上面测试队列公平性的代码，发现打印都是用一个线程做的。和我预想中的不太一样。</p>
<h3 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h3><p>​    在Java中实现多线程有两种方式，一种是继承Thread类，还有一种就是实现Runnable接口。Runnable封装一个异步运行的任务，可以看为一个没有参数和返回值的异步方法。Callable和Runnablee类似，但是有返回值。Callable接口是一个参数化的类型，只有一个方法<code>call()</code>。</p>
<p>​    Future能够保存异步计算的结果，流程是这样的：启动一个计算，将Future对象交给某个线程，然后执行其他任务，Future对象的所有者在结果计算好之后就可以获得它。上面的例子也可以修改为使用Future，代码修改为如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FutureTest.java</span></span><br><span class="line"><span class="comment"> * Description: Future的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(System.in)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your directory eg: /Users/pengshiquan/Desktop/Developmentcache/JavaTrain/src/syncTrain&quot;</span>);</span><br><span class="line">            String directory = in.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your keyword eg volatile&quot;</span>);</span><br><span class="line">            String keyword = in.nextLine();</span><br><span class="line">            MathCounter mathCounter = <span class="keyword">new</span> MathCounter(<span class="keyword">new</span> File(directory), keyword);</span><br><span class="line">            FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(mathCounter);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.println(task.get() + <span class="string">&quot;符合的行数&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FutureTest.java</span></span><br><span class="line"><span class="comment"> * Description:  计数类，实现了Callable接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathCounter</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> File directory;</span><br><span class="line">    <span class="keyword">private</span> String keyword;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MathCounter</span><span class="params">(File file, String keyword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = file;</span><br><span class="line">        <span class="keyword">this</span>.keyword = keyword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        File[] files = directory.listFiles();</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (File file : files)</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                MathCounter mathCounter = <span class="keyword">new</span> MathCounter(file, keyword);</span><br><span class="line">                FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(mathCounter);</span><br><span class="line">                result.add(task);</span><br><span class="line">                Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">                t.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (search(file)) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; integerFuture : result) &#123;</span><br><span class="line">            count += integerFuture.get();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(file, <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">while</span> (!found &amp;&amp; in.hasNextLine()) &#123;</span><br><span class="line">                    String line = in.nextLine();</span><br><span class="line">                    <span class="keyword">if</span> (line.contains(keyword)) found = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行器和线程池"><a href="#执行器和线程池" class="headerlink" title="执行器和线程池"></a>执行器和线程池</h3><p>​    线程的创建事比较消耗资源的，如果程序中创建了大量的短期线程，可以使用线程池来管理和获取。</p>
<p>​    这篇博客前前后后写了很长时间，最后写了感觉也不是很理想，中间也断断续续了几次，这篇博客的知识点我也忘了几次，都是看前面写的才记起来写到哪里。最后发现不是我想象中的学习方式，也记录下来，引以为戒。如果只是死看书很难学到有用的知识，可能就是写了一篇博客，其中的知识点也很难到自己的脑子里。还是好奇法更加容易学习，通过工作中的一个例子，去编写一个demo，再去了解这个demo后面藏着的知识，这样的方式才能让知识更加深刻的到达自己的脑子里面。引以为戒。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E3%80%81%E5%B9%B6%E5%8F%91/" data-id="ckupl1rqj000u6rup28ml8exr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/红黑树在HashMap中的应用（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8HashMap%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2021-10-13T13:28:21.188Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="红黑树在HashMap中的应用（一）"><a href="#红黑树在HashMap中的应用（一）" class="headerlink" title="红黑树在HashMap中的应用（一）"></a>红黑树在HashMap中的应用（一）</h2><p>​    现在来填上一篇博客的坑，讲一讲红黑树在HashMap中的应用。</p>
<p>​    在讲之前，先要了解一下红黑树，再去阅读源码。本文就是这样的一个结构。但是一开始没有想到红黑树很复杂，篇幅比预期的要大，所以本次红黑树的记录分为三期，坑一定要慢慢填。。</p>
<p>[TOC]</p>
<h3 id="了解红黑树"><a href="#了解红黑树" class="headerlink" title="了解红黑树"></a>了解红黑树</h3><p>​    分析源码肯定要先了解相关概念，了解了概念去看源码就豁然开朗，要不然一直都像无头苍蝇一样，抓不到头绪。</p>
<h4 id="红黑树的历史"><a href="#红黑树的历史" class="headerlink" title="红黑树的历史"></a>红黑树的历史</h4><p>​    红黑树最开始由鲁道夫·贝尔在1972年发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文。但是其代码的实现非常不容易，所以在2008年Robert Sedgewick编写了一个幻灯片，介绍了左倾红黑树，并且给出了简单的实现代码，就此，红黑树就逐渐变成我们如今了解的样子。</p>
<p>​    作为一个合格的开发人员，应该去了解概念的最初形成，知道其根源的理论。网上的大部分文章都介绍了红黑树的五个性质，但是性质来源和为什么有这些性质并没有说清楚。这里因为本人能力有限（英语方面），使用谷歌翻译但是翻译的一塌糊涂。所以最后虽然找到了论文和PPT，但是看不懂。。。（英语的重要性）下面放上链接，同时也希望自己后续英语能力上来后能够填上这个坑。</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/4567957">A dichromatic framework for balanced trees</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf">Left-Leaning Red-Black Tree</a></p>
<h4 id="红黑树的来源和变种"><a href="#红黑树的来源和变种" class="headerlink" title="红黑树的来源和变种"></a>红黑树的来源和变种</h4><p>​    如果你也和我一样在网上找了一圈相关的论文资料，估计这个小节你已经有了相关的概念。红黑树并不是凭空出来的新概念，只是将最开始的概念进行完善和代码化。下面我就按照完善的顺序介绍各种二叉树的变种。直到最后介绍红黑树，</p>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>​    二叉树（binary tree）是最开始的树，就是一个简单的只有两个字节点的树。甚至节点之间都没有顺序。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210309184758580.png" alt="image-20210309184758580"></p>
<h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>​    二叉查找树（BST，binary search tree）是二叉树的进化，在二叉树的基础上增加了有序性，我们平时说的二叉树也是指的二叉查找树。二叉查找树能够快速的查找、删除、插入元素。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210309185136325.png" alt="image-20210309185136325"></p>
<p>​    但是二叉查找树有一个致命因素，如果元素在特殊情况下插入，二叉树会变成一种单链表，如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210309185326382.png" alt="image-20210309185326382"></p>
<p>​    所以二叉查找树在特殊情况下的时间复杂度非常差。</p>
<h5 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h5><p>​    AVL树（由发明者Adelson-Velsky 和 Landis 的首字母缩写命名）是指任意节点的两个子树的高度差不超过1的平衡树。</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210309190241163.png" alt="image-20210309190241163"></p>
<p>​    上面的树就是AVL树，不是很容易理解，并且AVL树实现自平衡的过程很复杂，这里就不再详细描述了。</p>
<h5 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h5><p>​    2-3树的定义如下：每个具有子节点的节点（内部节点，internal node）要么有两个子节点和一个数据元素，要么有三个子节点和两个数据元素的自平衡的树，它的所有叶子节点都具有相同的高度。</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310163055451.png" alt="image-20210310163055451"></p>
<p>​    2-3树的逻辑还是能够理解的，主要就是维持2-3树的特点，如果出现了不符合2-3树的特征，就需要将数据元素或者字节点往上移动。下面列举一个2-3树生长轨迹图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310165516582.png" alt="image-20210310165516582"></p>
<p>​    图的来源为：<a target="_blank" rel="noopener" href="http://ddrv.cn/a/104429">算法网</a></p>
<h5 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h5><p>​    2-3-4树，它的每个非叶子节点，要么是2节点，要么是3节点，要么是4节点，且可以自平衡，所以称作2-3-4树。2节点：包含两个子节点和一个数据元素；3节点：包含三个子节点和两个数据元素；4节点：包含四个子节点和三个数据元素；</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310165929418.png" alt="image-20210310165929418"></p>
<p>​        2-3-4树是2-3树的进阶版，在2-3树的转换过程中会发现有一种中间状态和上面的图类似，就是具有四个节点和三个数据元素，如果这种状态合法，它就是2-3-4树。</p>
<p>​    如果2-3-4树转换的中间状态也是合法的，就又产生了一种新的树，2-3-4-5树。这样类似的树统称为B树，它允许一个节点可以有多于两个子节点，同时，也是自平衡的，叶子节点的高度都是相同的。B树多了一个概念叫“度”，2-3树的度就是3，2-3-4树多度就是4，度就是表示该树最多拥有多少字节点。</p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>​    红黑树其实是由2-3-4树变种而来（也有说是2-3树变种而来，这里不再讨论详细内容），因为2-3-4树代码的实现比较复杂，所以产生了红黑树（代码实现也不简单）。先说一下红黑树的五条性质。</p>
<ul>
<li>节点是要么红色或要么是黑色。</li>
<li>根一定是黑色节点。</li>
<li>每个叶子结点都带有两个空的黑色结点（称之为NIL节点，它又被称为黑哨兵）。</li>
<li>每个红色节点的两个子节点都是黑色（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点）。</li>
<li>从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
<p>​    现在五条性质不清楚原因没有关系，可以在后面慢慢的去了解其意义，或者在上面的论文和幻灯片中寻找答案。和我之前想的一样，不同的高度看到和理解的东西是不一样的，很难一次就理解红黑树的全部概念。列举一个和上面2-3-4树数据元素一致的红黑树。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310182116361.png" alt="image-20210310182116361"></p>
<p>​    这样看的话是不是就能理解为什么红黑树是2-3-4树的变种了？对比五条性质就更能理解这个图。如果上面的两个图片还是抽象，我寻找了画的比我好的一个示意图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310194048137.png" alt="image-20210310194048137"></p>
<p>​    到此，红黑树的来源和中间的一些变种就全部了解完毕。这一部分借鉴了其他人的博客，这里放上链接。</p>
<p>​    <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024499075">红黑树的来源和变种的讲解</a></p>
<h4 id="红黑树的五条性质及其解释"><a href="#红黑树的五条性质及其解释" class="headerlink" title="红黑树的五条性质及其解释"></a>红黑树的五条性质及其解释</h4><p>​    红黑树的五条性质在上面有说到过，下面就一一分析这五条性质。</p>
<h5 id="2-3-4树和红黑树之间的转换"><a href="#2-3-4树和红黑树之间的转换" class="headerlink" title="2-3-4树和红黑树之间的转换"></a>2-3-4树和红黑树之间的转换</h5><p>​    既然说了红黑树来源于2-3-4树，所以两者肯定可以转换，并且红黑树的五条性质也是依赖于这些转换过程的。下面给出转换的图例和解析。2-3-4树只存在2、3、4节点的情况，临时的节点情况不再本次分析之内。</p>
<ul>
<li>2节点。2节点比较简单，直接转换为红黑树中的黑色节点即可，如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314142331015.png" alt="image-20210314142331015"></p>
<p>​    这个还是很好理解的，就是简单将节点赋予颜色，没有什么难点。</p>
<ul>
<li>3节点。3节点有些特殊，存在两个情况，也是红黑树的分支由来，即左倾红黑树和右倾红黑树。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314143232558.png" alt="image-20210314143232558"></p>
<p>​    这里就可以看到颜色的意义，红色本身是没有任何含义的，红色的节点是要结合它的父树一起来看才能看出这棵红黑树树的含义。</p>
<ul>
<li>4节点。4节点和2节点相似，只存在一种情况，如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314143711140.png" alt="image-20210314143711140"></p>
<p>​    到此，就可以将任意的一个2-3-4树转换为红黑树，并且可以确定红黑树的颜色。但是因为3节点的存在，所以一个2-3-4树能转换为不同的红黑树，一个红黑树不能转换为多个2-3-4树。</p>
<h5 id="红黑树的性质解析"><a href="#红黑树的性质解析" class="headerlink" title="红黑树的性质解析"></a>红黑树的性质解析</h5><p>​    红黑树的性质上面已经说过了，并且也已经了解了2-3-4树和红黑树的互相转换，可以开始解析对应的五条性质了。</p>
<ul>
<li><p><strong>节点是要么红色或要么是黑色。</strong>这个性质还是比较好理解的，红黑树只存在黑色和红色，如果有其他颜色也就不叫红黑树了。需要注意的是如果一个红黑树全部存在黑色或者红色呢？也不是不可以，但是红黑树是来源于2-3-4树，全是黑色或者全是红色显然无法分辨出是2节点还是3节点，一个红黑树也就对应多个2-3-4树了。不符合要求，并且代码也无法实现。</p>
</li>
<li><p><strong>根一定是黑色节点。</strong>这个性质可能要思考一下，红黑树来源于2-3-4树，通过上面的转换不难发现无论是2、3还是4节点，最后转换为红黑树都是黑色节点在上。所以根节点就无论如何都是黑色的了。</p>
</li>
<li><p><strong>每个叶子结点都带有两个空的黑色结点（称之为NIL节点，它又被称为黑哨兵）。</strong>这个性质我现在还不是很理解，找了一下，大部分的解释是为了区分某些不属于红黑树的特殊情况，这里也留个坑吧，也欢迎大佬给出解答。而这也是为什么链表中通常会有哨兵节点的原因，就是为了避免各种判空，这样既容易出错也会让代码一团糟。</p>
</li>
<li><p><strong>每个红色节点的两个子节点都是黑色（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点）。</strong>这个性质也需要思考一会，还是那句话，红黑树来源于2-3-4树，看看2-3-4树什么情况下会转换为红色树，只有3和4节点，之前也说过红树是结合父树来看的，如果3节点增加红树，对应的就是4节点，但是4节点只存在唯一的情况，所以不行。4节点就更容易理解了，添加一个红树，变为5节点，但是5节点是临时态，实际是不应该存在的，最后还是会转换为其他形态。解释如下图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314150143548.png" alt="image-20210314150143548"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314150159674.png" alt="image-20210314150159674"></p>
</li>
<li><p>  <strong>从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点。</strong>这个性质也是能够理解的，通过上面的转换可以看到只有黑色节点代表一层，红色节点其实和父黑色节点同属于一层，所以黑色节点代表层数。同时红黑树是做了平衡的，和2-3-4树一样，到达子节点的层数都是一致的，即到达任何一个子节点的黑色节点树相同。</p>
</li>
</ul>
<h4 id="红黑树的操作及其分析"><a href="#红黑树的操作及其分析" class="headerlink" title="红黑树的操作及其分析"></a>红黑树的操作及其分析</h4><p>​    讲解完了红黑树的来源和性质，下面就可以讲解一下红黑树具体的操作和对这些操作的分析。</p>
<p>​    红黑树的平衡操作有三种：左旋转、右旋转、染色。下面就一一解析这些操作。具体的插入和操作放到下一片博客讲。</p>
<h5 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h5><p>​    左旋转的作用就是将一个向右倾斜的二叉树平衡，转化为左链接。如下示意图。（插入顺序为1-2-3）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310195710789.png" alt="image-20210310195710789"></p>
<p>​    通过将这个二叉树左旋，就是将1节点变为2节点的左节点，同时改变颜色（这一步骤其实不涉及染色）。变成如下图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310200014187.png" alt="image-20210310200014187"></p>
<h5 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h5><p>​    举一反三，看过上面就大致猜到了右旋转就是将左倾斜的二叉树平衡，转化为右链接。如下示意图。（插入顺序为3-2-1）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310200442968.png" alt="image-20210310200442968"></p>
<p>​    和上面的相反，将二叉树右旋，将3节点变为2节点的右节点。变成如下图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310200635557.png" alt="image-20210310200635557"></p>
<h5 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h5><p>​    旋转完后或者插入节点后，很大概率红黑树的节点颜色是不符合要求的，所以需要将红黑树节点的颜色进行改变，变成符合五条性质的红黑树。还是以上面的左旋转为例。</p>
<p>​    旋转完毕，但是不染色。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310201209652.png" alt="image-20210310201209652"></p>
<p>​    很明显不符合红黑树的性质4，所以要对节点的颜色进行变换，变成符合要求的如下的红黑树。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310200635557.png" alt="image-20210310200635557"></p>
<p>​    </p>
<p>​    红黑树为了平衡的三个操作都已经了解了，剩下的就是实践了，这一部分比较耗费时间和画图。。。所以不再博客中叙述。只需要记住一点，无论经过什么操作，红黑树需要满足自身的平衡要求并且也要符合红黑树的五条性质，剩下的自己就是慢慢画和理解了。</p>
<p>​    这一部分也借鉴了其他人的成果，这里放上链接。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023715473?utm_source=sf-related">红黑树的操作解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树的在线演示图，可以在这里验证自己的思路</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8HashMap%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="ckupl1rqk000v6rupbgux4cr6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/红黑树在HashMap中的应用（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8HashMap%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2021-10-13T13:28:21.188Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="红黑树在HashMap中的应用（二）"><a href="#红黑树在HashMap中的应用（二）" class="headerlink" title="红黑树在HashMap中的应用（二）"></a>红黑树在HashMap中的应用（二）</h2><p>​    上一篇博客讲述了红黑树的历史来源，阐述了红黑树的五条性质，并且解释了五条性质的原因。下面就来实际操作一下，讲解一下红黑树对于节点的插入和删除。</p>
<p>[TOC]</p>
<h3 id="红黑树的插入和删除"><a href="#红黑树的插入和删除" class="headerlink" title="红黑树的插入和删除"></a>红黑树的插入和删除</h3><p>​    在之前不止一次的说过红黑树来源于2-3-4树，所以插入和删除也是，不了解2-3-4树的插入、删除操作，很难直接上手红黑树。本文的结构就如此，先介绍2-3-4树的插入、删除操作，再去解析红黑树的对应操作。</p>
<h4 id="2-3-4树的插入、删除操作"><a href="#2-3-4树的插入、删除操作" class="headerlink" title="2-3-4树的插入、删除操作"></a>2-3-4树的插入、删除操作</h4><h5 id="2-3-4树的节点插入"><a href="#2-3-4树的节点插入" class="headerlink" title="2-3-4树的节点插入"></a>2-3-4树的节点插入</h5><p>​    2-3-4树的插入分为几个情况，2节点、3节点、4节点。下面就一一解释和画图举例。</p>
<ul>
<li>2节点插入。这个比较简单，直接将2节点转换为3节点即可。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314162205713.png" alt="image-20210314162205713"></p>
<ul>
<li>3节点插入。这个和2节点差不多，因为最大允许4节点，所以直接插入即可。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314163816142.png" alt="image-20210314163816142"></p>
<ul>
<li>4节点插入。这个需要做一下变换，因为5节点是不存在的，所以需要将3个元素的中间元素上移，在放置插入元素即可。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314164631591.png" alt="image-20210314164631591"></p>
<p>到这里，2-3-4的插入就完成了，下面就要讲一下删除了。</p>
<h5 id="2-3-4树的节点删除"><a href="#2-3-4树的节点删除" class="headerlink" title="2-3-4树的节点删除"></a>2-3-4树的节点删除</h5><p>​    删除操作比较复杂一点，分为2节点删除和3、4节点删除，为什么分为两个，下面就清楚了。</p>
<ul>
<li><p>3、4节点删除。直接删除即可。因为是大于2的节点，所以这个时候树的高度没有发生变化，只需要合并子节点或者将子节点用于补位即可。这里就不再画图了，因为情况有些多。</p>
</li>
<li><p>2节点删除。2节点删除网上也有许多方案，这里使用下面这个思路：将当前节点变为大于2节点。或者说，不让删除节点出现在2节点中。分为三个情况。</p>
<ul>
<li>父节点和兄弟节点都大于2.这个情况将父节点中的一个元素下调至删除节点，形成一个3节点。兄弟节点将一个元素上调到父节点。完成删除。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210315201220749.png" alt="image-20210315201220749"></p>
<ul>
<li>父节点为大于2节点，兄弟节点为2节点。父节点下调一个元素，和删除元素、兄弟节点一起组成4节点，最后删除要删除的元素。完成删除。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210315201735601.png" alt="image-20210315201735601"></p>
<ul>
<li>父节点和兄弟节点都为2节点。父节点下调和删除节点、兄弟节点组成临时节点，删除要删除的节点。完成。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210315201929131.png" alt="image-20210315201929131"></p>
</li>
</ul>
<p>​    删除到这里就结束了，当删除元素为2节点并且没有兄弟节点时，无论父节点为几节点，直接删除即可。</p>
<p>​    2-3-4树的插入和删除到这里就暂时结束了，开始编写解析红黑树的插入和删除了。这里水平有限，有些地方可能想的不是很全面，欢迎大佬们的指正。这里借鉴了知乎的回答。连接如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/312327402/answer/1560653215">知乎关于红黑树的回答</a></p>
<h4 id="红黑树的插入、删除操作"><a href="#红黑树的插入、删除操作" class="headerlink" title="红黑树的插入、删除操作"></a>红黑树的插入、删除操作</h4><p>​    终于讲解到红黑树的插入和删除了，和上面的一样，先分析红黑树的插入（比较简单），然后再去分析红黑树的删除。这里红黑树的基本操作：左旋转、右旋转和染色默认大家都已经清楚了，如果不是很清楚，可以看一下上一篇博客。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38533859/article/details/114789173?spm=1001.2014.3001.5501">红黑树在HashMap中的应用（一）</a></p>
<p>​    因为红黑树也分为多种，这里以左倾红黑树为例。</p>
<h5 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h5><p>​    红黑树的插入的节点默认为红色，上面也能看出，2-3-4树的插入默认都是当前节点，所以红黑树的插入的节点都是临时节点，默认为红色。插入有两种大情况，插入元素的父亲是红色、插入元素的父亲是黑色。下面就一一解析。</p>
<ul>
<li> <strong>插入元素比黑父小</strong>。因为是左倾红黑树，所以当黑父的左节点不存在时，一定没有右节点。所以这种情况直接插入即可。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323100150896.png" alt="image-20210323100150896"></p>
<ul>
<li><strong>插入元素比黑父大</strong>。这时分为两个情况。<ul>
<li><strong>当黑父没有左节点时</strong>，直接左旋转黑父、再将父节点和插入节点换色即可。</li>
<li><strong>当黑父有左节点时</strong>，因为这个时候没有破坏红黑树的性质，所以也是直接插入即可。</li>
</ul>
</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323100513177.png" alt="image-20210323100513177"></p>
<p>​    因为红父是要结合它的黑父节点一起看的，并且红黑树来源于2-3-4树，所以存在红父的情况只有3节点、4节点。3节点和4节点的区别只有红父是否存在兄弟节点。所以红父的情况分为了四种：插入节点有叔父节点且比红父小、插入节点有叔父节点且比红父大、插入节点没有叔父节点且比红父小、插入节点没有叔父节点且比红父大。</p>
<p>​    注意：此时叔父节点不可能为黑色，要不然插入之前的树就不符合红黑树的定义五。</p>
<ul>
<li><strong>插入节点有叔父节点且比红父小。</strong>这个形态对应的是2-3-4树的4节点，所以要此时的临时5节点分裂，将树的高度加一，即将叔父节点和红父节点的颜色与祖父节点互换。因为比红父小，所以符合左倾红黑树要求。但是这时，祖父节点因为变换了颜色，所以将祖父节点当作插入节点，再执行修复操作。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323103124602.png" alt="image-20210323103124602"></p>
<ul>
<li><strong>插入节点有叔父节点且比红父大。</strong>这个形态和上面类似，不过因为比红父大，所以不符合左倾红黑树的要求，需要再做一个转换。这里就不再画图了，脑中过一遍就能理解。</li>
<li><strong>插入节点没有叔父节点且比红父小。</strong>这个形态对应2-3-4树的3节点，插入此节点不会导致高度的变化，所以就是需要将红父进行右旋转。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323111003906.png" alt="image-20210323111003906"></p>
<ul>
<li><strong>插入节点没有叔父节点且比红父大。</strong>此时树应该是右倾的，所以需要将树变为左倾，再转换为上面步骤即可，如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323112156656.png" alt="image-20210323112156656"></p>
<p>​    这些插入结束后需要注意一点，因为祖父节点产生了变化，所以需要对祖父节点进行回溯，即将祖父节点当作插入节点，在执行这个步骤，直到根节点符合要求。    </p>
<p>至此，红黑树的插入就全部例举完毕了，同时需要注意还有一点是不是对红黑树的理解又加深了？因为本人水平有限，可能有些地方有误或者不清晰，欢迎大佬的指正。</p>
<h5 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h5><p>​    红黑树的删除比较复杂，考虑的情况要比插入多一些。这里也是举例说明，希望自己能够理清，也欢迎大家指正。</p>
<h6 id="了解删除前需要了解的"><a href="#了解删除前需要了解的" class="headerlink" title="了解删除前需要了解的"></a>了解删除前需要了解的</h6><p>​    了解删除前需要了解一些知识点。关于二叉树通用的删除策略。</p>
<ul>
<li>删除某个节点时，可以选择该节点的前驱节点或者后继节点来替代它。这个需要思考一下，并不是很难。<ul>
<li>前驱节点：该节点的左子树的最右节点。</li>
<li>后继节点：该节点的右子树的最左节点。</li>
</ul>
</li>
</ul>
<h6 id="红黑树删除的情况"><a href="#红黑树删除的情况" class="headerlink" title="红黑树删除的情况"></a>红黑树删除的情况</h6><p>​    红黑树删除分为三个大情况，三个大情况又各自进行细分。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323182608315.png" alt="image-20210323182608315"></p>
<p>​    下面就需要对没有子节点的情况进行分析。</p>
<ul>
<li> 删除节点为红色：因为红色对应着2-3-4树的3、4节点，由上面可知，直接删除即可。没有什么好说的。结果如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323182954212.png" alt="image-20210323182954212"></p>
<ul>
<li><p>删除节点为黑色。因为黑色其实代表了一个2-3-4中的一个层级，删除层级肯定对红黑树的实际高度有影响，所以需要做一定的调整。并且按照上面的步骤，删除的黑色节点其实对应了2-3-4树中删除2节点，所以删除红黑树的黑色子叶节点需要观察父节点和兄弟节点，这也是网上大家都这样说的原因。这样就简单了，按照2-3-4树进行理解和分析吧。</p>
<p>还是先说说情况，总共有六种，但是中间一些情况的处理时一样的。情况如下图：（因为为左倾红黑树，所以不存在兄弟节点为红色）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323204709003.png" alt="image-20210323204709003"></p>
<ul>
<li>当兄没有红子节点时，无论父是否为红，最后都变为父黑兄红。其实对应了2-3-4树中的删除2节点时，兄弟节点也为2节点。最后都是父节点和兄弟节点组成一个三节点的子树。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323211215752.png" alt="image-20210323211215752"></p>
<ul>
<li>当兄有一个红色节点时，无论父是否为红，最后都是兄弟节点代替父节点、父节点代替删除节点、兄弟子节点代替兄弟节点。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323211409899.png" alt="image-20210323211409899"></p>
<ul>
<li>当兄弟有两个红色时，无论父是否红，最后都是兄弟节点代替父节点、父节点代替删除节点、兄弟节点的左节点挂在删除节点下、兄弟节点的右节点代替兄弟节点、最后父节点再左旋转。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323211559996.png" alt="image-20210323211559996"></p>
</li>
</ul>
<p>​    至此，红黑树的删除也讲完了。这一块不是很容易理解，我画的图也不会动，所以最后还是需要靠自己去一点点想象（。。。）中间也看了很多的博客，对于自己的理解有很大的帮助，下面就放上链接。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023715473?utm_source=sf-related">删除操作类举比较详细</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/312327402/answer/1560653215">红黑树的插入讲的不错</a></p>
<p>​    上面的链接只是个人的判断，当你理解其含义后，各个方法也就能懂其意思了。</p>
<p>​    讲完了红黑树的插入和删除，下面就要上实现代码了，这里直接阅读JDK的源码，分析一下HashMap中红黑树的实现（讲到现在终于靠题了）。这篇博客花了很长的时间，后面也会单独分析一下原因，技术应该没有如此难学。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8HashMap%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="ckupl1rqk000w6rupd1399q5y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/HashMap中红黑树的代码解析（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/HashMap%E4%B8%AD%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="HashMap中红黑树的代码解析"><a href="#HashMap中红黑树的代码解析" class="headerlink" title="HashMap中红黑树的代码解析"></a>HashMap中红黑树的代码解析</h3><p>​    看到这里，红黑树的基本概念和操作都已经清楚了，如果条件允许的话，你说不定已经实际操作或者编写代码了。下面就来看一下JDK源码中对于红黑树的实现，再次巩固一下上面的知识。</p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>​    </p>
<p>​    如果当前节点链表超过8个，就调用树化方法、如果当前tab长度没有超过32，就扩容，如果超过32就将链表红黑树化</p>
<p>​    循环遍历将节点链表按照先后顺序复制给hd，然后将hd树化（梳理）</p>
<p>（断言检测不清楚作用）</p>
<p>​    取下一个节点</p>
<h4 id="使用情景和细节"><a href="#使用情景和细节" class="headerlink" title="使用情景和细节"></a>使用情景和细节</h4><p>红黑树颜色的作用是搭配起来使用的，</p>
<p>红黑树的维护平衡有很多方法，主要就是维护高度和节点颜色</p>
<p><a target="_blank" rel="noopener" href="http://www.doczj.com/doc/cffdb8b4e009581b6ad9eb1c-4.html">http://www.doczj.com/doc/cffdb8b4e009581b6ad9eb1c-4.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf">https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/HashMap%E4%B8%AD%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/" data-id="ckupl1rq4000a6rupgt2j8ovm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/HashMap源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><p>​    今天来看一下HashMap的源码，学习一下相关的知识点。不多啰嗦了，直接开始吧。</p>
<p>​    先看一段代码，是使用HashMap的代码，比较简单，先从代码入手。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Date&gt; test = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">test.put(<span class="string">&quot;test1&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">test.put(<span class="string">&quot;test2&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">test.put(<span class="string">&quot;test1&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">Date date = test.get(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">System.err.println(date);</span><br></pre></td></tr></table></figure>

<p>​    代码比较简单，建立一个map，存放date，先后放了三次，代表三个场景，第一次当map为空时放入、第二次放入不同的key，第三次放入相同key，但是value不同。最后取出第一次放入的key的value并且打印出来。下面就来具体看看源码，看看HashMap到底做了什么。</p>
<p>​    先看第一行代码，看到声明了一个map，执行了key和value的类型。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210228215831632.png" alt="image-20210228215831632"></p>
<p>​    构造函数只有一行，指定了负载系数，下面看一下这个负载系数是什么东西。<code>负载因子是在自动增加其哈希表容量之前允许哈希表获得的满度的度量。</code>不难理解，这个负载系数是map自动扩增的一个阈值。好像这个构造函数比较简单，只是简单的赋值了，也没有什么初始化的操作，别急，看看第二行代码吧。</p>
<p>​    第二行代码就是放入一个key为test，value为当前时间的操作。来看看<code>put(K key, V value)</code>做了什么。<code>put(K key, V value)</code>的代码只有一行。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210301161338805.png" alt="image-20210301161338805"></p>
<p>​    <code>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</code>是一个实现，看一下传参的含义，需要注意的参数不多，就一个hash值，下面看一下hash方法。<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210301161814463.png" alt="image-20210301161814463"></p>
<p>​    方法注释如下：<strong>计算key.hashCode（）并将哈希的较高位（XOR）扩展为较低。 由于该表使用2的幂次掩码，因此仅在当前掩码上方的位中发生变化的哈希集将始终发生冲突。 （众所周知的示例是在小表中包含连续整数的Float键集。）因此，我们应用了一种变换，将向下扩展较高位的影响。 在速度，实用性和位扩展质量之间需要权衡。 由于许多常见的哈希集已经合理分布（因此无法从扩展中受益），并且由于我们使用树来处理容器中的大量冲突集，因此我们仅以最便宜的方式对某些移位后的位进行XOR，以减少系统损失，以及合并最高位的影响，否则由于表范围的限制，这些位将永远不会在索引计算中使用。</strong>这边说一下自己的理解：这个方法返回的是int类型，四个字节，后面是用来确定key在数组中的下标，但是map中数组长度是有限制的，一般小于2^16，即65536。获取key下标的代码如下：<code>tab[i = (n - 1) &amp; hash]</code>（hash%n等价于(n - 1) &amp; hash）,也就是说只可能会和四个字节的低两个字节进行位运算，所以这里的hash方法作用也就不难判断出来，将hash值变得更加散乱，减少哈希冲突。这里的实现就是让hashCode和高16位进行异或运算（异或的运算不偏向于0或者1）。<code>hashCode()</code>方法调用底层C的代码，这里能力有限，就不再列出来叙述了。到这里，明白了HashMap并不是将hashCode直接拿来用，还是有一定的运算。这里参考了一片博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42034205/article/details/90384772">讲解hash方法</a></p>
<p>​    回到<code>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</code>方法，代码比较多，这里直接粘贴出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里初看代码有些不知道看哪里，可以按照最开始编写的代码去跑这个代码逻辑。下面就开始按照第二行代码梳理。</p>
<p>​    代码先是判断数组存不存在，数组每个位置存放的是一个节点链表。如果数组为空，就调用初始化方法<code>resize()</code>,这个方法可以放在后面讲，现在暂时略过，方法作用很简单，就是初始化或者增加表大小。下面就是根据哈希值获取key所在的下标，因为这里第一次放入，代码肯定位空，所以直接新建节点并且放入，next节点置为空。接着就来到了最后，判断当前负载系数是否超过最开始设置的值（默认0.75），如果超过，就再执行一次<code>resize()</code>.最后返回一个空。以上解析就是HashMap在放入第一个值时做的事，看着还是挺多的，下面接着看最开始编写的第三行代码。</p>
<p>​    第三行代码放入了一个不同的key，不同的value。按照上面的代码再走一遍，不过这个时候数组已经有了，不需要再次创建。但是因为key不相同，所以哈希值不相同（假设没有哈希冲突），所以后面的步骤就和上面的一样了：新建一个节点，放入到数组中。同时在最后也会对数组长度做判断，达到负载系数就扩容。那就来看第四行代码。</p>
<p>​    第四行代码是继续放入一个相同的key，但是value不同。仍然走上面的代码，发现数组已经创建，但是通过计算下标发现该下标已经有节点，执行了else部分。先是判断key是否相同，这里判断方法为：<code>hash值是否相等&amp;&amp;(两个key相等||两个key的eques方法返回true)</code>。看到这里，是不是也清楚了：重写eques方法一定要重写hashCode方法。因为如果这里没有重写hashCode方法，即哈希值不一定相同，就会造成相同的key，却有两个下标，导致后续的put无法覆盖掉原有的key。回到源码，看到else最后将原有的value取出，将新的放进去，并且将原有value返回，结束本次放入。（这里可能理解不太对，欢迎大佬们指正）</p>
<p>​    到了最后一行，将放入到值取出。看看源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码可以比较清晰的看到HashMap中<code>节点</code>这个概念的存储结构，先是找到哈希值所在的下标，再去判断节点的第一个到key是否相同（和上面所到判断方法一致），到这里，也就理解了：哈希值相同，eques方法不一定返回true。如果不是第一个元素，在开始遍历节点中的链表，一直到找到为止。到这里，最开始编写的代码也就全部解析完毕。中间的一些逻辑分支没有细说，东西都是大差不差，没有什么需要特别说的点。下面根据这个方法我找到了一个流程图。和下面的图片来源一样。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302141253511.png" alt="image-20210302141253511"></p>
<p>​    最后开始填上面的坑，resize方法。这个方法是比较重要的，属于map的扩容机制。先提一点，通过上面的解析，现在也大致清楚了HashMap中的结构，不仅仅的是一个数组，是将链表和数组的形式结合了起来。类似于下面这个形式。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302110441809.png" alt="image-20210302110441809"></p>
<p>​    这个图片来源于:<a target="_blank" rel="noopener" href="https://blog.csdn.net/login_sonata/article/details/76598675">Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法）</a>,后面的解析也参考了这个博客，讲解的比较清晰。</p>
<p>​    当数组到了一定的容量后，需要对数组进行扩容，扩容后也需要对元素的下标进行重新计算，resize方法完成的就是这些内容。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里按照讲解put方法的方式分析，按照两种情况进行解析。1.数组没有初始化的时候扩容。2.数组负载系数达到阈值时，对数组进行扩容。</p>
<ul>
<li><p>当数组没有初始化，先是将数组长度和长度阈值设置好，然后直接创建数组，将数组给全局变量就完成这一步骤。初始化比较简单，主要就是各个参数的设置。</p>
</li>
<li><p>当数组需要扩容时就比较复杂了，判断是否需要扩容这一部分就不再细说了，就是各个逻辑的梳理，按照代码来即可，没有什么可说的点。只需要记得扩容后就是将原有数组长度乘2，所以HashMap的数组长度只能是2的幂次方（包括你自己设置为13，也会自动寻找最近的2的幂次方）需要重点说的就是扩容后，将原有数组移植到新数组中。这里有两个分支不需要讲：1.链表长度超过8时转换为红黑树的实现（这部分包括put方法里面涉及红黑树的会单独写一个博客，留坑）。2.链表只有一个节点时的情况，比较简单，重新计算下标即可。重点中的重点就是，链表节点树为多个的情况。就是最后一个else里面的代码。</p>
<p>先看一个解析。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302113927205.png" alt="image-20210302113927205"></p>
<p>这个解析比较清晰，所以判断一个链表中改位置需不需要移动，就可以直接用<code>(e.hash &amp; oldCap) == 0</code>来判断，即直接将数组长度和哈希值与一下就能判断出高位是否会变化。如果等于零就不需要移动，不等于零，就需要移动到新的位置，新的数组下标为多少，上面的解析也能看出来，就是加8，即加上旧数组长度。这样的话，看这段代码就比较容易看懂了。循环遍历链表，再判断该节点是否需要移动，需要移动就放到高位节点链表中，不需要移动就放到低位节点链表中。创建四个节点也是为了方便放入，最后遍历完毕，将高低位的头节点放入到指定下标即可，完成了数组的迁移。</p>
</li>
</ul>
<p>​    至此，关于最开始编写的代码的解析都已经完毕了，剩下的红黑树实现和哈希表的原理因为能力有限，放到后面讲，要不然博客就太长了。在最后，欢迎各位大佬指正和批评。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckupl1rq5000b6ruphsf41j33" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/JUC学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/JUC%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java中虚假唤醒的问题</p>
<p>if只会判断一次，但是while唤醒后还是会继续判断</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/JUC%E5%AD%A6%E4%B9%A0/" data-id="ckupl1rq6000c6rupfi8f766e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java中Lambda表达式学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java中Lambda表达式学习"><a href="#Java中Lambda表达式学习" class="headerlink" title="Java中Lambda表达式学习"></a>Java中Lambda表达式学习</h2><p>​    上一篇博客了解了线程的相关学习，学习的过程中看到一个注解<code>@FunctionalInterface</code>，本次的博客就来学习一下函数式接口。函数式接口可以用Lambda来创建，所以函数式接口的学习应该在Lambda表达式前面。</p>
<p>​    先来看一下函数式接口的文档定义：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210218093905631.png" alt="image-20210218093905631"></p>
<p>可以发现几个重要的点：</p>
<ul>
<li>函数式接口只有一个抽象方法。</li>
<li>默认方法和覆盖方法都不计入抽象方法数目。</li>
<li>可以用Lambda表达式、方法引用、构造函数引用来创建函数式接口实例。</li>
<li>注解并不一定是必须的，只要符合要求，编译器会自动将接口视为函数式接口。</li>
</ul>
<p>​    下面看一个jdk中自带的函数式接口的实现，<code>Comparator</code>接口。发现里面有很多方法的实现，但是也使用了<code>@FunctionalInterface</code>注解，仔细再看，可以看到只有两个抽象方法，其他都是静态方法或者默认方法，都有实现。再看两个抽象方法，一个是继承了Object类的<code>equals</code>方法，所以最后这个接口只有一个抽象方法，符合函数式接口的定义。</p>
<p>​    下面就来看一下如何使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Description: 使用lambda表达式作为转换为函数式接口传递到Arrays.sort中第二个参数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2019-07-18</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arraySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String[] arrays = &#123;<span class="string">&quot;1237&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">       Arrays.sort(arrays, (first, second) -&gt; second.length() - first.length());</span><br><span class="line">       System.err.println(arrays[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    方法描述已经比较详细的介绍了这个方法的作用，因为<code>sort(T[] a, Comparator&lt;? super T&gt; c)</code>方法不是本篇博客的重点，所以不再叙述太多，简单理解为将数组中的元素按照给定的方法比较排序即可。这里第二个参数就是函数式接口，可以看到这里的传值为<code>(first, second) -&gt; second.length() - first.length()</code>,这个就是典型的Lambda表达式的应用，函数式接口的实现内容就是：返回用第二个参数的长度减去第一个参数的长度得到的值。但是我们还是有很多疑问的。下面一一去寻找答案。</p>
<ul>
<li><code>(first, second) -&gt; second.length() - first.length()</code>是什么意思，为什么这样写？换个方式<code>(String first, String second) -&gt; &#123;return second.length() - first.length();&#125;</code>这样是不是就可以看出大概了，知道这个是<code>Comparator</code>中接口方法<code>int compare(T o1, T o2);</code>的实现。</li>
<li>为什么不用声明参数类型，代码是如何知道我传入的类型？这个需要看一下方法<code>public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</code>，可以看到在调用soft方法时就已经声明了参数的类型，所以编译器就知道了这里是否正确，也是可以省略参数类型的原因。</li>
</ul>
<p>​    Lambda表达式的特征如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210218113001221.png" alt="image-20210218113001221"></p>
<p>​    下面开始编写自己的一个函数式接口的demo。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 测试使用的代码，分别要传入各自的参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Eatable e)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(e);</span><br><span class="line">		e.taste();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Flyable f)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我正在驾驶：&quot;</span>+f);</span><br><span class="line">		f.fly(<span class="string">&quot;【碧空如洗的日子】&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Addable add)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;5与3的和为：&quot;</span>+add.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 主方法，其中的方法参数都是使用lambda表达式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		demo1 demo1=<span class="keyword">new</span> demo1();</span><br><span class="line">		<span class="comment">//lambda表达式的代码只只有一句，可以省略“&#123;&#125;”</span></span><br><span class="line">		<span class="comment">//这里的lambda表达式实际上被当成任意的类型，具体的类型取决于运行环境的需要</span></span><br><span class="line">		demo1.eat(()-&gt;System.out.println(<span class="string">&quot;苹果的味道不错&quot;</span>));</span><br><span class="line">		<span class="comment">//方法的形参只有一个，可以省略“()”  weather是接口方法的形参</span></span><br><span class="line">		demo1.drive(weather-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;今天的天气是：&quot;</span>+weather);</span><br><span class="line">			System.out.println(<span class="string">&quot;直升机飞行平稳&quot;</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//代码只有一句，可以省略“&#123;&#125;”,同时也可以省略return关键字 a+b是返回值</span></span><br><span class="line">		demo1.test(Integer::sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试使用的接口,只有一个抽象方法的接口（函数式接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String weather)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    现在看这些代码是不是很容易就明白了。这里也就不再将代码进行详细解析。</p>
<p>​    函数式接口和其如何使用都已经了解了，下面就开始了解函数式接口有哪些使用方式，从最开始的文档中可以了解到，有三种方式去创建函数式接口实例。lambda表达式，方法引用或构造函数引用。Lambda表达式刚才已经看到并且使用到了，下面详细说一下方法引用和构造函数引用。</p>
<ul>
<li><p>方法引用。方法引用分为实例方法引用、静态方法引用和特定类型的方法引用。语法分别为：</p>
<ul>
<li>实例方法引用：<code>new instMethod()::method</code></li>
<li>静态方法引用：<code>类名::staticMethod</code></li>
<li>特定类型的方法引用：<code>类名::instMethod</code>（个人认为不常用）</li>
</ul>
<p>举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LambdaTrain6.java</span></span><br><span class="line"><span class="comment"> * Description: 博客中使用的练习demo，将方法引用汇集在一起</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTrain6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 第一个&lt;T&gt; 声明范型的类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2021-02-18</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T s)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是一个静态方法引用，有参数，但是没有返回值：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个普通方法引用，没有参数，但是返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是特定类型的方法引用&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态方法引用</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = LambdaTrain6::hello;</span><br><span class="line">        consumer.accept(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//普通方法引用</span></span><br><span class="line">        Supplier&lt;String&gt; supplier = <span class="keyword">new</span> LambdaTrain6()::put;</span><br><span class="line">        System.err.println(supplier.get());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.抽象方法的第一个参数类型刚好是实例方法的类型（函数式接口的抽象方法必须要有输入参数）。2.抽象方法剩余</span></span><br><span class="line"><span class="comment">         * 的参数恰好可以当做实例方法的参数。如果函数式接口的实现能由上面说的实例方法调用来实现的话，</span></span><br><span class="line"><span class="comment">         * 那么就可以使用对象方法的引用(两个条件都要满足)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BiConsumer&lt;LambdaTrain6, String&gt; biConsumer = LambdaTrain6::fun;</span><br><span class="line">        biConsumer.accept(<span class="keyword">new</span> LambdaTrain6(), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>构造方法引用 ，构造方法引用的语法就只有一种：<code>类名::new</code></p>
<p>举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LambdaTrain5.java</span></span><br><span class="line"><span class="comment"> * Description: lambda表达式练习，练习方法引用的构造方法引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTrain5</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果函数式接口的实现恰好可以通过调用一个类的构造方法来实现，那么就可以使用构造方法引用</span></span><br><span class="line"><span class="comment">     * 语法</span></span><br><span class="line"><span class="comment">     * 类名::new</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 主方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-08-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Person&gt; supplier = () -&gt; <span class="keyword">new</span> Person();</span><br><span class="line">        Supplier&lt;Person&gt; supplier1 = Person::<span class="keyword">new</span>;</span><br><span class="line">        supplier.get();</span><br><span class="line">        supplier1.get();</span><br><span class="line"></span><br><span class="line">        Consumer&lt;Integer&gt; consumer = (i) -&gt; <span class="keyword">new</span> Student(i);</span><br><span class="line">        Consumer&lt;Integer&gt; consumer1 = Student::<span class="keyword">new</span>;</span><br><span class="line">        consumer.accept(<span class="number">1</span>);</span><br><span class="line">        consumer1.accept(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有参构造器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Function&lt;String, Integer&gt; function = s -&gt; s.length();</span><br><span class="line">        Function&lt;String, Integer&gt; function1 = String::length;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + function.apply(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + function1.apply(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Function&lt;String, Student&gt; function2 = Student::<span class="keyword">new</span>;</span><br><span class="line">        function2.apply(<span class="string">&quot;hahahah&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 重写构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-08-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is Person&#x27;s construction method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have no parameter &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    学习了函数式接口的使用方式和练习了一些基本的demo，现在回头看Lambda表达式是不是就更加清楚其意思了。但是什么时候或者什么地方该用Lambda呢？这个问题我现在也没有很明白，后续会慢慢补充。<code>java.util.function</code>包下都是jdk自带的函数式接口，阅读完这些接口的含义可能会对函数式接口有了一个更加清晰的认识，说到底，Lambda表达式和函数式接口的存在还是为了让写代码更加清晰和简洁。万变不离其意。要在开发中你感觉可以使用Lambda的地方使用它，使用的多了，了解也就更加的深入了。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/" data-id="ckupl1rq6000d6rupeb1pfv9b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java中基础知识记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java中基础运算符和知识点记录"><a href="#Java中基础运算符和知识点记录" class="headerlink" title="Java中基础运算符和知识点记录"></a>Java中基础运算符和知识点记录</h2><p>​    在阅读源码和其他的一些代码后，发现自己一些基础的运算符老是忘记（其实就是不懂。。。），所以专门写一篇博客记录一下，防止后续自己忘记。不多啰嗦，直接开始。</p>
<p>​    <code>&amp;</code>：与运算符，位运算符的一种，表示同一位都为1时，最后结果才为1。例子：<code>4&amp;6=4</code>（使用计算器将两个数都显示出来更加能够理解透彻）</p>
<p>​    <code>|</code>：或运算符，位运算符的一种，表示同一位只要有一个为1，最后结果就为1。例子：<code>4|6=6</code>。</p>
<p>​    <code>~</code>：非运算符，位运算符的一种，该位为1时，结果为0，该位为0时，结果为1。例子：<code>(byte)~4=0xFB</code></p>
<p>​    <code>^</code>：异或运算符，位运算的一种，表示同一位相同时最后结果为0，同一位不同时最后结果为1.例子：<code>4^6=2</code></p>
<p>​    <code>&gt;&gt;</code>：右移运算符，位运算符的一种，表示将操作数向右移动，移出的全部丢弃，左边的看符号位进行补全，如何符号为位0，则补0，反之补1。例如：<code>4&gt;&gt;2=2</code></p>
<p>​    <code>&lt;&lt;</code>：左移运算符，运算符的一种，表示将操作数向左移动，移出位置全部丢弃，右边全部补0.例如：<code>2&lt;&lt;2=4</code></p>
<p>​    <code>&gt;&gt;&gt;</code>：无符号右移运算符。位运算符的一种，表示将操作数向右移动，移出位置全部丢弃，左边全部补0.例如<code>-4&gt;&gt;&gt;2=1073741823</code></p>
<ul>
<li>补充：计算机中存储负数不是简单的符号位加后面的数，存储的是负数的补码，这样是方便两个数相加。例如-4的补码是0xFFFFFFFC,所以负数的无符号右移会和预想中的不一致。可以自己写写代码看一下。</li>
</ul>
<p>​    <code>布尔表达式?表达式1:表达式2</code>：三目运算符。如果布尔表达式为true，执行表达式1，为false，执行表达式2。例如：<code>a=1&gt;2?1:2</code>,最后a=2.</p>
<p>​    <code>&amp;&amp;</code>：逻辑与，逻辑运算符的一种。当两个条件都为true时，最后结果才为true，有一个不为true，最后结果就为false。</p>
<p>​    <code>||</code>：逻辑或，逻辑运算符的一种。当两个条件任意一个为true时，最后结果就为true，只有两个条件都为false，最后结果才为false。</p>
<p>​    <code>bread和continue的区别</code>：break跳出本层嵌套的循环，continue跳出本次的循环，并没有跳出循环体。</p>
<p>​    暂时就想到这些了，后续还会慢慢补充。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" data-id="ckupl1rq7000e6ruphoqu3j01" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java中的参数传递类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java中的参数传递类型"><a href="#Java中的参数传递类型" class="headerlink" title="Java中的参数传递类型"></a>Java中的参数传递类型</h2><p>​    在阅读HashMap中的源码过程中，阅读到一些方法之间的调用涉及到参数传递，有些情况下感觉最后的结果和我想的不一样，所以特地了解了一下参数传递，在这里也记录一下，防止自己忘记。</p>
<p>[TOC]</p>
<h3 id="了解一些基础概念"><a href="#了解一些基础概念" class="headerlink" title="了解一些基础概念"></a>了解一些基础概念</h3><p>​    在学习参数传递之前需要先了解一些基础概念，这里也会给出实例代码。方便理解。</p>
<h4 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h4><p>​    参数传递在程序中是比较常见的。参数传递涉及到两个概念。形式参数和实际参数。下面就说一下两者的区别。</p>
<blockquote>
<p>形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数，简称“形参”。<br>实际参数：在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”，简称“实参”。</p>
</blockquote>
<p>​    Java也不例外，也存在形式参数和实际参数，在这里分别举个例子。</p>
<h4 id="形参和实参的举例"><a href="#形参和实参的举例" class="headerlink" title="形参和实参的举例"></a>形参和实参的举例</h4><p>​    形式参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(StringBuffer s, <span class="keyword">int</span> a)</span><span class="comment">//形式参数s和a</span></span></span><br></pre></td></tr></table></figure>

<p>​    实际参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">test(s, a);<span class="comment">//实际参数s和a</span></span><br></pre></td></tr></table></figure>

<p>​    看了上面的例子，是不是了解了形式参数和实际参数的区别。</p>
<h4 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h4><p>​    在程序语言中的参数传递类型有两种，分别为值传递和引用传递。两者的概念和区别如下：</p>
<blockquote>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<p>​    这里的举例用C来举例，用C的代码分别举例值传递和引用传递。</p>
<h4 id="值传递和引用传递的举例"><a href="#值传递和引用传递的举例" class="headerlink" title="值传递和引用传递的举例"></a>值传递和引用传递的举例</h4><p>​    值传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bef swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">    swap(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pass by value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    引用传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bef swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">    swap2(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass by reference</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面两个例子就是值传递和引用传递的区别，运行后也是不同的效果，还是比较明显的。c这一块不是很熟悉，代码可能有误，但是思想我认为传达到了。</p>
<h3 id="了解Java中的传递类型"><a href="#了解Java中的传递类型" class="headerlink" title="了解Java中的传递类型"></a>了解Java中的传递类型</h3><p>​    终于到了本文的正题了，开始讲解一下Java中的参数传递的机制和原理。在讲解之前，需要先了解一下JVM中的堆和栈的区别。</p>
<ul>
<li>栈内存。栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</li>
<li>堆内存。存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li>
</ul>
<p>​    可以简单的理解为方法中的变量都存储在栈中，实际的对象都存储在堆中。方法之间是不能够互相修改变量的。所以也就有了这种说法。<strong>Java中只存在值传递，不存在引用传递</strong>，因为本质上都是复制了一份副本，所以都是值传递。下面就开始讲解。</p>
<h4 id="对于传递类型的解析"><a href="#对于传递类型的解析" class="headerlink" title="对于传递类型的解析"></a>对于传递类型的解析</h4><p>​    Java中的参数分为两种，基本类型参数和引用数据类型，基本数据类型基本上没有什么分歧，都认为是值传递。主要分歧都在引用数据类型上。</p>
<p>​    在方法之间传递一个引用数据类型是，类似于这种<code>foo(User user)</code>,变量user相当于一个指针，指向了堆中实际的存储对象。在传递过程中，将指针进行复制，传递到foo方法中，两个变量是有区别的，但是指想的都是堆中同一个对象。</p>
<p>​    说的可能不太好理解，举一些例子来说明一下。</p>
<h4 id="举一些小例子"><a href="#举一些小例子" class="headerlink" title="举一些小例子"></a>举一些小例子</h4><ul>
<li>例子一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nativetrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferHKTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 调用海康SDK的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferHKTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        test(user);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user.name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    User(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    运行结果如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210317153823967.png" alt="image-20210317153823967"></p>
<p>​    这个运行结果好像和我们说的不一致，其实细想一下就明白了，方法传递的是一个指针的副本，最后指向的都是堆中的对象。修改这个对象后在主方法中当然可以起效。但是和引用传递还是有区别的，区别就是引用传递能修改真正的参数，但是Java中的传递并不行。可以再看一下下面一个代码示例。</p>
<ul>
<li>例子二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nativetrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferHKTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 调用海康SDK的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferHKTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        test(user);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    User(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210317154636836.png" alt="image-20210317154636836">    </p>
<p>​    只是简单的修改了一下，最后的结果就不一样了。这里将参数传递的变量进行初始化，相当于在堆中又创建了一个User对象，和主方法中的user对象所指向的对象是两个完全不同的对象，所以这里的修改也就没有起效。两次的打印也就不一样。</p>
<p>​    到这里，是不是对于Java中参数传递类型就更加清楚了一些。能力有限，如果文中有些错误，欢迎大佬指正。</p>
<p>​    本文也借鉴了一些博客，博客地址：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sum-41/p/10799555.html">深入理解Java中方法的参数传递机制</a></p>
<p>​    就这样吧，结束。</p>
<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B/" data-id="ckupl1rq8000f6rup9xvs2ken" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java代码实现ping命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0ping%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java代码实现ping命令"><a href="#Java代码实现ping命令" class="headerlink" title="Java代码实现ping命令"></a>Java代码实现ping命令</h2><p>​    在一个项目中，遇到了一个问题，需要查看某个IP是否能够ping通，这里就直接使用Java代码实现了，记录一下。</p>
<p>​    先说一下实现的几个方法。</p>
<ul>
<li><p>Jdk1.5的InetAddresss方式</p>
</li>
<li><p>调用本机CMD</p>
</li>
<li><p>Java调用控制台执行ping命令</p>
</li>
</ul>
<p>​    下面也就不不废话了，直接上代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> network_train;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NetWorkTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 网络测试demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTrain</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 主方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ipAddress = <span class="string">&quot;192.168.16.127&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Jdk1.5的InetAddresss方式</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Jdk1.5的InetAddresss方式&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;主机的状态，&quot;</span> + pingforInetAddresss(ipAddress));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 直接调用CMD</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.err.println(<span class="string">&quot;直接调用CMD&quot;</span>);</span><br><span class="line">            <span class="comment">//pingForCMD(ipAddress);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;更加完善的调用CMD方法&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;主机的状态&quot;</span> + pingForExec(ipAddress, <span class="number">5</span>, <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: Jdk1.5的InetAddresss方式，返回值是true时，说明host是可用的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">pingforInetAddresss</span><span class="params">(String ipAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//超时应该在3秒以上</span></span><br><span class="line">        <span class="keyword">int</span> timeOut = <span class="number">3000</span>;</span><br><span class="line">        <span class="comment">// 当返回值是true时，说明host是可用的，false则不可。</span></span><br><span class="line">        <span class="keyword">boolean</span> status = InetAddress.getByName(ipAddress).isReachable(timeOut);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 直接调用CMD,方法直接将CMD窗口的信息打印出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pingForCMD</span><span class="params">(String ipAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process pro = Runtime.getRuntime().exec(<span class="string">&quot;ping &quot;</span> + ipAddress);</span><br><span class="line">            BufferedReader buf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    pro.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> ((line = buf.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">                System.out.println(line);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 更加完善的调用CMD方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pingTimes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeOut</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">pingForExec</span><span class="params">(String ipAddress, <span class="keyword">int</span> pingTimes, <span class="keyword">int</span> timeOut)</span> </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将要执行的ping命令,此命令是windows格式的命令</span></span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        String pingCommand = <span class="string">&quot;ping &quot;</span> + <span class="string">&quot;-c &quot;</span> + pingTimes + <span class="string">&quot; &quot;</span> + ipAddress;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">// 执行命令并获取输出</span></span><br><span class="line">            System.out.println(pingCommand);</span><br><span class="line">            Process p = r.exec(pingCommand);</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逐行检查输出,计算类似出现=23ms TTL=62字样的次数</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line">            <span class="keyword">int</span> connectedCount = <span class="number">0</span>;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connectedCount += getCheckResult(line);</span><br><span class="line">                <span class="comment">// 如果出现类似=23ms TTL=62这样的字样,出现的次数=测试次数则返回真</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> connectedCount == pingTimes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();   <span class="comment">// 出现异常则返回假</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != in) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 若line含有=18ms TTL=16字样,说明已经ping通,返回1,否則返回0.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> line</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCheckResult</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;控制台输出的结果为:&quot; + line);</span></span><br><span class="line">        String trueZF = <span class="string">&quot;time=&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (line.contains(trueZF)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行的截图如下：</p>
<p>​    成功的：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200615154620793.png" alt="image-20200615154620793"></p>
<p>​    失败的：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200615154550305.png" alt="image-20200615154550305"></p>
<p>​    下面就说说中间的问题。</p>
<p>​    一个是不同的电脑系统，代码中的命令是不一样的，我这里的是Mac os，所以命令和Windows上面的有所不同。</p>
<ul>
<li><p>Mac os（或者Linux）:ping -c 5 127.0.0.1 </p>
</li>
<li><p>Windows： ping 127.0.0.1 -n 5 -w 1000</p>
</li>
</ul>
<p>​    所以不同的系统要拼接的命令也是不一样的。然后就是需要注意最后结果的分析，我这里的代码是直接判断有没有<code>time=</code>,有就是成功了。大家也可以根据自己的需求对延迟做一定对要求，我这里比较简单，就没有写的太复杂。到这里就基本完成了。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0ping%E5%91%BD%E4%BB%A4/" data-id="ckupl1rq8000g6rupbh84cfxd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E6%8D%AE%E4%BD%8D%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E8%AE%B0%E5%BD%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>