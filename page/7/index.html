<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java基础/Java核心技术卷" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="卷二"><a href="#卷二" class="headerlink" title="卷二"></a>卷二</h1><h2 id="第1章-Java-SE-8的流库"><a href="#第1章-Java-SE-8的流库" class="headerlink" title="第1章 Java SE 8的流库"></a>第1章 Java SE 8的流库</h2><ul>
<li>流和集合的区别<ul>
<li>流并不存储元素</li>
<li>流的操作不会修改其数据源</li>
<li>流的操作是尽可能惰性执行        </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String wordsString = <span class="keyword">new</span> String(Files.readAllBytes(Paths.get(<span class="string">&quot;/Users/Desktop/dev/aaa.txt&quot;</span>)), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">//以非字母分隔符</span></span><br><span class="line">    List&lt;String&gt; wordsList = Arrays.asList(wordsString.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用迭代的方式查询大于12的单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String word : wordsList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt; <span class="number">12</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">&quot;使用迭代的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用流的方式查询大于12的单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//单线程运行</span></span><br><span class="line">    count = wordsList.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br><span class="line">    System.err.println(<span class="string">&quot;使用单线程的流的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">//多线程运行</span></span><br><span class="line">    count = wordsList.parallelStream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br><span class="line">    System.err.println(<span class="string">&quot;使用多线程的流的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流是使用stream和parallelStream方法来创建的，filter方法用来对流进行转化，count</span></span><br><span class="line"><span class="comment">     * 方法用来终结操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>流的创建方法<br>  JavaAPI中有大量的方法可以产生流，这里不再全部叙述，也不太现实。就直接以一个demo的形式叙述一下我了解的创建流的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> streamtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SetUpStream.java</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetUpStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;/Users/pengshiquan/Desktop/dev/aaa.txt&quot;</span>);</span><br><span class="line">        String wordsString = <span class="keyword">new</span> String(Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">        String[] arrayString = &#123;<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;ddd&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream方法创建流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(wordsString);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream1 = Stream.of(<span class="string">&quot;hahah&quot;</span>, <span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;Stream.of&quot;</span>, stringStream1);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Array.stream(array,from,to)可以创建一个流，从数组中的from到to</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream2 = Arrays.stream(arrayString, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        show(<span class="string">&quot;Arrays.stream&quot;</span>, stringStream2);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream.empty()用来创建一个不包含任何元素的流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream3 = Stream.empty();</span><br><span class="line">        show(<span class="string">&quot;Arrays.stream&quot;</span>, stringStream3);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream两个创建无限流的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//使用lambda表达式重写Supplier&lt;T&gt;函数表达式</span></span><br><span class="line">        Stream&lt;String&gt; stringStream4 = Stream.generate(() -&gt; <span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;Stream.generate&quot;</span>, stringStream4);</span><br><span class="line">        <span class="comment">//lambda表达式中的实例方法引用</span></span><br><span class="line">        Stream&lt;Double&gt; stringStream5 = Stream.generate(Math::random);</span><br><span class="line">        show(<span class="string">&quot;Stream.generate&quot;</span>, stringStream5);</span><br><span class="line">        <span class="comment">// 前面是种子，反复调用函数，应用到之前到结果上    顺序如下： 0，1，2，3，4</span></span><br><span class="line">        Stream&lt;BigInteger&gt; integerStream = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br><span class="line">        show(<span class="string">&quot;Stream.iterate&quot;</span>, integerStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * pattern中的splitAsStream方法将字符串分割为一个一个单词</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream6 = Pattern.compile(<span class="string">&quot;a&quot;</span>).splitAsStream(wordsString);</span><br><span class="line">        show(<span class="string">&quot;splitAsStream&quot;</span>, stringStream6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回一个包含了文件所有行的stream</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; stringStream7 = Files.lines(path, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            show(<span class="string">&quot;Files.lines&quot;</span>, stringStream7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 添加了&lt;T&gt;的展示方法，添加&lt;T&gt;可以使得方法参数类型不受对象范型类限制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/4/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(String title, Stream&lt;T&gt; stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">        List&lt;T&gt; headList = stream.limit(SIZE + <span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">        System.err.print(title + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (T t : headList) &#123;</span><br><span class="line">            System.err.print(t);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对流的操作的方法</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7/" data-id="ckuqw9s6l000hxcuphbvz56rv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/Java线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ul>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口，实现run方法。</li>
<li>使用Callable和Future创建线程。主要就是让线程有返回值，线程也可以抛出异常了。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的第三种方法，使用Callable和Future创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">//创建Callable对象  1</span></span><br><span class="line">      demo3 rt=<span class="keyword">new</span> demo3();</span><br><span class="line">      <span class="comment">//先使用Lambda表达式创建Callable&lt;Integer&gt;对象  1</span></span><br><span class="line">      <span class="comment">//使用Futuretask来包装Callable对象</span></span><br><span class="line">      FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">         <span class="comment">//这里的方法相当于call()方法    1 call()方法可以有返回值  2 call()方法也可以声明抛出异常 </span></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//通过currentThread()来获得当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//返回值</span></span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//主线程</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//实质还是Callable对象创建线程的，执行者还是Thread</span></span><br><span class="line">            <span class="keyword">new</span> Thread(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//也可以获取异常</span></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//获取子线程的返回值get()方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot;子线程的返回值为：&quot;</span>+task.get());</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">         ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现Runnbale接口和Callable接口获取当前线程都需要调用<code>Thread.currentThread()</code>方法。</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。通过Future可以了解任务的执行情况和任务是否完成、也可以取消任务。</li>
</ul>
<h3 id="线程的状态流转图"><a href="#线程的状态流转图" class="headerlink" title="线程的状态流转图"></a>线程的状态流转图</h3><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210510164508318.png" alt="image-20210510164508318"></p>
<p>​    一个线程刚开始创建就是new状态，只是简单的赋值，没有什么其它操作。调用线程的start方法后，线程进入运行态，如果此时的线程没有什么其它要求，就只是简单打印一句话，线程执行完毕后就进入了终止态。但是如果有特殊情况，它在语句中调用了object.wait()，这时它会进入等待状态，同时也进入了等待队列，就是waiting，另外一个线程如何调用了这个对象的notify()方法，最开始进入等待状态的线程会重新获取锁，进入运行态。如何这个时候等待锁的线程比较多，没有获取到的就进入阻塞状态，也就进入到了同步队列，一直等待获取到锁，然后进入运行态。还有一个状态就是超时等待状态，以线程的sleep方法为例，线程运行中执行这个方法，睡眠10秒，然后线程就进入了这个状态，10秒过完后，就再次回到运行态。但是这里不会放弃锁，会一直保持。</p>
<ul>
<li>所有的状态都是先进入就绪态，再进入运行中。</li>
<li>sleep方法不会放弃锁。</li>
<li>线程不能抛出任何异常，遇到异常，应该设置异常处理器。将异常的信息打印到日志中或者后续处理。</li>
<li>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。线程状态为可运行态。</li>
<li>Thread.join方法会让当前线程进入到等待状态，执行t，完毕后再执行当前线程。本质仍然是执行了 wait() 方法，而锁对象就是 Thread t 对象本身。</li>
<li>park和unpark实现的原理则是使用线程内部的计数器。</li>
<li>用 jdk 的 Lock 接口中的 lock，如果获取不到锁，线程将挂起，状态则变为等待状态。</li>
<li>jdk 中锁的实现，是基于 AQS 的，而 AQS 的底层，是用 park 和 unpark 来挂起和唤醒线程。</li>
</ul>
<h3 id="线程池相关知识点"><a href="#线程池相关知识点" class="headerlink" title="线程池相关知识点"></a>线程池相关知识点</h3><p>​    创建一个线程池，现在里面没有任何运行的线程。提交一个任务，如果小于核心线程数，会一直创建新的核心线程。直到核心线程数满了，线程池还有一个任务队列，核心数满了后，会将提交的任务放到任务队列里面。当任务队列也满了后，会创建非核心线程数，当非核心线程数也满了后，就会走拒绝策略，将后面提交的任务全部拒绝。当非核心线程慢慢没有任务后，过一段时间就会对非核心线程进行销毁。核心线程则会一直运行中。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210607200224525.png" alt="image-20210607200224525"></p>
<ul>
<li>但是，敦促程序员使用更方便的Executors工厂方法Executors.newCachedThreadPool （无边界线程池，具有自动线程回收）， Executors.newFixedThreadPool （固定大小的线程池）和Executors.newSingleThreadExecutor （单个后台线程），这些方法可以预先配置设置。</li>
<li>当在方法execute(Runnable)提交新任务，并且正在运行的线程少于corePoolSize线程时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理请求。 如果运行的线程数大于corePoolSize但小于maximumPoolSize，则仅在队列已满时才创建新线程。 通过将corePoolSize和maximumPoolSize设置为相同，可以创建固定大小的线程池。 通过将maximumPoolSize设置为一个本质上不受限制的值（例如Integer.MAX_VALUE ，可以允许池容纳任意数量的并发任务。 最典型地，核心和最大池大小仅在构造时设置，但也可以使用setCorePoolSize和setMaximumPoolSize动态更改。</li>
<li>使用ThreadFactory创建新线程。 如果没有另外指定，则使用Executors.defaultThreadFactory ，该线程创建的线程全部位于相同的ThreadGroup并且具有相同的NORM_PRIORITY优先级和非守护程序状态。 通过提供其他ThreadFactory，可以更改线程的名称，线程组，优先级，守护程序状态等。如果ThreadFactory在从newThread返回null返回要求时未能创建线程，执行器将继续执行，但可能无法执行执行任何任务。 线程应具有“ modifyThread” RuntimePermission 。 如果使用该池的工作线程或其他线程不具有此许可权，则服务可能会降级：配置更改可能不会及时生效，并且关闭池可能保持在可能终止但未完成的状态。</li>
<li>如果当前池中的线程数超过corePoolSize，则多余的线程将在空闲时间超过keepAliveTime时终止（请参见getKeepAliveTime(TimeUnit) ）。 当不积极使用池时，这提供了一种减少资源消耗的方法。 如果池稍后变得更活跃，则将构建新线程。 也可以使用setKeepAliveTime(long, TimeUnit)方法动态更改此参数。 使用Long.MAX_VALUE TimeUnit.NANOSECONDS的值Long.MAX_VALUE有效地使空闲线程永远不会在关闭之前终止。 默认情况下，仅当corePoolSize线程数多时，保持活动策略才适用。 但是，只要keepAliveTime值不为零，方法allowCoreThreadTimeOut(boolean)还可用于将此超时策略应用于核心线程。</li>
<li>有三种一般的排队策略：<ul>
<li>直接交接。 工作队列的一个很好的默认选择是SynchronousQueue ，它可以将任务移交给线程，而不必另外保留它们。 在这里，如果没有立即可用的线程来运行任务，则尝试将任务排队的尝试将失败，因此将构造一个新线程。 在处理可能具有内部依赖项的请求集时，此策略避免了锁定。 直接切换通常需要无限制的maximumPoolSizes以避免拒绝新提交的任务。 反过来，当平均而言，命令继续以比其可处理的速度更快到达时，这可能会带来无限线程增长的可能性。</li>
<li>无限队列。 使用无界队列（例如，没有预定义容量的LinkedBlockingQueue ）将在所有corePoolSize线程繁忙时使新任务在队列中等待。 因此，将仅创建corePoolSize线程。 （因此，maximumPoolSize的值没有任何作用。）当每个任务完全独立于其他任务时，这可能是适当的，因此任务不会影响彼此的执行。 例如，在网页服务器中。 尽管这种排队方式对于消除短暂的请求突发很有用，但它承认当命令平均继续以比处理速度更快的速度到达时，无限制的工作队列增长是可能的。</li>
<li>有界队列。 当与有限的maximumPoolSizes一起使用时，有界队列（例如ArrayBlockingQueue ）有助于防止资源耗尽，但调优和控制起来会更加困难。 队列大小和最大池大小可能会相互折衷：使用大队列和小池可以最大程度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为地降低吞吐量。 如果任务频繁阻塞（例如，如果它们受I / O约束），则系统可能能够安排比您原先允许的线程更多的时间。 使用小队列通常需要更大的池大小，这会使CPU繁忙，但可能会遇到无法接受的调度开销，这也会降低吞吐量</li>
</ul>
</li>
<li> 在任一情况下， execute方法调用RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)其的方法RejectedExecutionHandler 。 提供了四个预定义的处理程序策略：</li>
<li>在默认的ThreadPoolExecutor.AbortPolicy ，处理程序在拒绝时会抛出运行时RejectedExecutionException 。</li>
<li>在ThreadPoolExecutor.CallerRunsPolicy ，调用execute自己的线程运行任务。 这提供了一种简单的反馈控制机制，该机制将减慢新任务的提交速度。</li>
<li>在ThreadPoolExecutor.DiscardPolicy ，简单地删除了无法执行的任务。</li>
<li>在ThreadPoolExecutor.DiscardOldestPolicy ，如果未关闭执行程序，则将丢弃工作队列开头的任务，然后重试执行（该操作可能再次失败，导致重复执行此操作）。</li>
</ul>
<h4 id="参数讲解"><a href="#参数讲解" class="headerlink" title="参数讲解"></a>参数讲解</h4><ul>
<li><p>corePoolSize – 要保留在池中的线程数，即使它们处于空闲状态，除非设置了allowCoreThreadTimeOut</p>
</li>
<li><p>maximumPoolSize – 池中允许的最大线程数</p>
</li>
<li><p>keepAliveTime – 当线程数大于核心数时，这是多余空闲线程在终止前等待新任务的最长时间。</p>
</li>
<li><p>unit – keepAliveTime参数的时间单位</p>
</li>
<li><p>workQueue – 用于在执行任务之前保存任务的队列。 这个队列将只保存execute方法提交的Runnable任务。</p>
</li>
<li><p>threadFactory – 执行程序创建新线程时使用的工厂</p>
</li>
<li><p>handler – 执行被阻塞时使用的处理程序，因为达到了线程边界和队列容量。</p>
</li>
<li><p>线程池的状态：</p>
<ul>
<li>RUNNING：接受新任务并处理排队的任务</li>
<li>SHUTDOWN：不接受新任务，但处理排队的任务</li>
<li>STOP：不接受新任务，不处理排队的任务，并中断进行中的任务</li>
<li>TIDYING：所有任务都已终止，workerCount为零，线程转换到TIDYING状态将运行Terminated（）挂钩方法。</li>
<li>TERMINATED：terminald（）已完成。</li>
</ul>
</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>execute(Runnable command)：在未来的某个时间执行给定的任务。</li>
<li>shutdown()：启动有序关闭，其中执行先前提交的任务，但不会接受新任务。 如果已经关闭，调用没有额外的效果。</li>
<li>shutdownNow() ：尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表。 </li>
<li>submit():提交一个返回值的任务以供执行，并返回一个表示任务未决结果的 Future.</li>
</ul>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadPoolTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 线程池练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executorService = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            TestTask testTask = <span class="keyword">new</span> TestTask(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            executorService.execute(testTask);</span><br><span class="line">            System.err.println(<span class="string">&quot;当前线程池核心线程数：&quot;</span> + executorService.getPoolSize());</span><br><span class="line">            System.err.println(<span class="string">&quot;队列中等待的任务数为：&quot;</span> + executorService.getQueue().size());</span><br><span class="line">            <span class="comment">//返回已完成执行的大致任务总数。</span></span><br><span class="line">            System.err.println(<span class="string">&quot;当前线程池完成的任务数为：&quot;</span> + executorService.getCompletedTaskCount());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;当前正在执行线程：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;线程：&quot;</span> + name + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试的问题"><a href="#面试的问题" class="headerlink" title="面试的问题"></a>面试的问题</h3><ul>
<li>等待状态和阻塞状态的区别</li>
</ul>
<p>​    线程的等待状态是主动的，自己调用wait方法将线程切换为等待状态，并且这个时候也会占用cpu，阻塞状态是被动的，获取不到锁就变成阻塞状态，这个时候会放弃cpu的执行权，等待某个时间将其唤醒。</p>
<ul>
<li>重复调用start方法会怎么样？</li>
</ul>
<p>​    会抛出异常，就在start方法的第一行，判断状态如果不是new的话，会直接抛出一个异常。</p>
<ul>
<li>线程池的创建方式有几种</li>
</ul>
<p>​    创建线程池第一种就是自定义创建，指定参数，创建线程池。还有一种就是通过Executors工具类创建指定好的线程池。一般三种类型的，线程数没有限制的、线程数固定大小的、线程数为一个的。看自己业务的需求，但是阿里的编码规范里面说不要使用工具类创建，是为了防止内存溢出。不知道我们公司线程池的使用是那种方式？</p>
<ul>
<li>线程池的拒绝策略有哪些？</li>
</ul>
<p>​    我了解的拒绝策略有一下啊几种：1.队列满了后直接抛出异常。2.无法执行的任务丢弃掉。3.使用调用者线程执行任务，这样能够减慢任务的提交速度。4.将队列头部的任务丢弃掉。</p>
<ul>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B/" data-id="ckuqw9s6m000ixcupcullbuxx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/Java线程深入学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java线程深入学习"><a href="#Java线程深入学习" class="headerlink" title="Java线程深入学习"></a>Java线程深入学习</h2><p>​    上一篇博客讲了一下并发，但是没有达到自己的效果，所以这篇博客想从上一篇博客中的线程讲起，打算写一篇有着自己风格和能够让自己满意的博客。也是想深入了解一下线程的工作原理。</p>
<p>​    线程是程序中的执行线程。 Java虚拟机允许应用程序具有多个并发运行的执行线程。Java创建线程有两种方式（Java文档中这样说的，网上说应该还有一种,总共三种）一种是继承<code>Thread</code>类，一种是实现<code>Runnable</code>接口。下面先就第一种创建方法来说一下线程具体的流程。现在上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一种创建线程的方法，通过继承Thread类创建线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;<span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//run方法就是线程执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当线程类继承Thread类时，直接使用this可以获得当前线程</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//获取当前线程的名字</span></span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 运行的时候发现main的i不一定会到20，线程的启动是计算机调度的，具有一定的随机性</span></span><br><span class="line"><span class="comment">             * 两个子线程的i不是共享的，不会连续打印</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//currentThread()总是返回当前正在执行的线程对象</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">//通过start()方法启动第一个线程</span></span><br><span class="line">                <span class="keyword">new</span> demo1().start();</span><br><span class="line">                <span class="comment">//启动第二个线程</span></span><br><span class="line">                <span class="keyword">new</span> demo1().start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    最后运行的截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210112173640626.png" alt="image-20210112173640626">    </p>
<p>​    基础的知识就不再详细介绍了，继承<code>Thread</code>类，重写<code>run()</code>方法，通过调用该类对象的<code>start()</code>方法（不是<code>run(</code>)方法）来启动线程。剩下就没有什么需要讲解的了，但是这篇博客是深入了解线程，所以会继续深挖一下，了解背后的原理。下面就开始阅读线程类的源码。</p>
<p>​    上面的过程涉及了几个地方，一个是创建一个对象，一个就是调用了<code>start()</code>方法。下面就一步一步来，先是new了一个对象，看到源码中是调用了初始化方法，只是初始化了线程的相关设置，和我们的关系好像不大。（其中涉及的感觉都是JVM相关的东西）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210112175323837.png" alt="image-20210112175323837"></p>
<p>​    下面就是<code>start()</code>方法了，先看该方法的介绍，显示该方法会使线程开始执行，Java虚拟机将会调用此线程的run方法，结果是产生两个线程（调用start方法的线程和执行run方法的线程），线程一旦完成就可能不会重启。再来看代码，发现代码不是很复杂：将该线程放入线程组，再调用<code>start0()</code>方法，然后到这里就断了，这里就调用了底层C的代码，再看下去就不是很容易懂了。好像到这里就暂时断了。</p>
<p>​    回过头来，就不难发现为什么线程的名称是<code>Thread-0</code>,因为初始化时没有传参所以系统给默认的了。同时也能解释代码中注释的疑问：运行次数多不难发现，不一定运行到20就开始打印子线程？和主线程的打印和子线程是随机不确定间隔打印的。（因为线程的启动时随机的，主线程和子线程是两个独立的线程）</p>
<p>​    下面就来看看创建线程的第二种方式。实现<code>Runnable</code>接口，直接上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建线程的第二种方法</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i;<span class="comment">//初始值为0</span></span><br><span class="line">   <span class="comment">//线程执行体</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//当实现Runnable接口时，只能使用Thread.currentThread().getName()获得当前线程</span></span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            demo2 dt=<span class="keyword">new</span> demo2();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 最终的执行者还是Thread</span></span><br><span class="line"><span class="comment">             * 发现新线程1和新线程2的i值是连续的，因为Thread共享了同一个target(就是Runnable对象)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//通过new Thread(target,name)来创建新线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(dt,<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dt,<span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码也是比较简单，但是创建线程这里不太一样，通过创建实现了Runnable接口的对象，但是实际还是调用Thread线程类的<code>start()</code>方法。看源码发现虽然调用的是不同的构造函数，但是最后调用的都是同一个初始化函数，而且传入的Runnable好像也没有用到，只是赋值了一下，就不再处理，那使用接口和不使用接口有什么区别呢？继续阅读源码。</p>
<p>​    如果实现接口，代码中并没有重写Thread类的<code>run()</code>方法，只是重写了Runnable的<code>run()</code>方法，回到Thread类的run方法，发现有这样的代码。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210113174447700.png" alt="image-20210113174447700"></p>
<p>​    这样就明白了，Thread是先调用Runnable的run方法，也就是说线程的创建还是在Thread中，Runnable只是将自己作为接口放到了Thread的上面。回到最上面也可以看到Thread是实现了Runnable接口的。Runnable接口也比较简单，就只有一个run方法。</p>
<p>​    回到刚才的问题，使用接口和继承Thread有什么区别，其实就是代码为什么这样设计的问题。看了一下Runnable的文档，如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210113175122171.png" alt="image-20210113175122171"></p>
<p>​        说白了，就是更加的灵活，Thread有一千行代码，其中很多代码可能是大家用不到的，这样也体现了一种思想，去除无用（自己想的）。让代码中尽量少一些无用代码。</p>
<p>​    代码其实比较简单，但是其中的一些设计思想需要消化一下。能力有限，只能考虑到这些，欢迎大家补充。</p>
<p>​    最后来看一下网上说的第三种创建线程的方式，使用Callable和Future创建线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的第三种方法，使用Callable和Future创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">//创建Callable对象  1</span></span><br><span class="line">      demo3 rt=<span class="keyword">new</span> demo3();</span><br><span class="line">      <span class="comment">//先使用Lambda表达式创建Callable&lt;Integer&gt;对象  1</span></span><br><span class="line">      <span class="comment">//使用Futuretask来包装Callable对象</span></span><br><span class="line">      FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">         <span class="comment">//这里的方法相当于call()方法    1 call()方法可以有返回值  2 call()方法也可以声明抛出异常 </span></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//通过currentThread()来获得当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//返回值</span></span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//主线程</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//实质还是Callable对象创建线程的，执行者还是Thread</span></span><br><span class="line">            <span class="keyword">new</span> Thread(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//也可以获取异常</span></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//获取子线程的返回值get()方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot;子线程的返回值为：&quot;</span>+task.get());</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">         ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    按照上面的方式继续阅读这段代码，不难发现<code>FutureTask&lt;V&gt;</code>其实是实现了Runnable的子类，这样的话和第二种方法就没有什么区别，这里也不再继续跟进。所以最开始文档中说的对，实现线程的方式只有两种。</p>
<p>​    这篇博客写到这里算是一个完结，因为目前能力有限，可能一些理解不太合适。也想了一下这种情况，个人来说很难学习一个知识点就直接学习到深处，很多东西都是循序渐进的，这样也就能解释之前的博客水平不咋地。一个高度就会有一个理解，不同高度的博客很难相比较。所以后续肯定也会回头看这篇博客。</p>
<p>​    博客是分两天写完的，中间间断了一下，但是最后的结果感觉还不是很满意，中间的语句和语序都有一些问题，也留一个结论。博客最好一天写完，可以后续完善，但是一定要一天定下文章的结构和大体框架。算是写作的一个小提示吧。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" data-id="ckuqw9s6n000jxcup14zxcw84" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/Java虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM基础概念"><a href="#JVM基础概念" class="headerlink" title="JVM基础概念"></a>JVM基础概念</h2><p>​    Java源文件通过编译器产生class文件，字节码文件再通过Java虚拟机中的解释器，编译成特定机器上的机器码。这也是Java跨平台的原因。</p>
<h3 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h3><p>​    Java内存模型分为两大类，线程私有和共享数据。线程私有：程序计数器、虚拟机栈、本地方法栈。共享数据有：常量池（方法区的一部分）、方法区、Java堆。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_21E692D0E9A8-1.jpeg" alt="IMG_21E692D0E9A8-1"></p>
<ul>
<li>程序计数器：当前线程执行的字节码行号指示器。</li>
<li>虚拟机栈：Java方法执行的内存模型，生命周期和线程一致。栈帧是进行方法执行的数据结构。虚拟机栈主要有两种异常：堆栈异常和内存超出异常。</li>
<li>本地方法栈：虚拟机使用到的native方法的内存空间。抛出的异常也是堆栈异常和内存超出异常。</li>
<li>堆：主要存放着对象的实例和数组的数据。抛出的异常为内存溢出异常。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A22B848C2C43-1.jpeg" alt="IMG_A22B848C2C43-1"></p>
<ul>
<li>方法区：主要存放虚拟机加载的类信息、常量、静态变量、编译后的代码。主要抛出内存溢出异常。</li>
<li>运行时常量池：属于方法区的一部分，主要存放编译器生成的各种字面量和符号的引用。不会抛出内存溢出异常。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>标记清除算法：将存活的对象标记，然后将为标记的对象的内存空间进行回收。</li>
<li>复制算法：将内存空间分为两块，一块用满后，将存活对象复制到另外一块，然后直接将之前的内存空间清理掉。</li>
<li>标记整理算法：将存活对象进行标记，然后将存活的对象都移动到一端，再将边界后面的内存空间清理。</li>
<li>分代收集算法：将内存分为两个区域：新年代和老年代。比例为1:2.新年代又分为Eden、From、To三个区域，比例为：8:1:1.每次进行回收时，将Eden和From存活对象复制到To中，然后将Eden和From清理。老年代因为对象存活时间久，执行的是标记整理算法。<ul>
<li>当标记对象达到15次时，就会移动到老年代。</li>
<li>当To的空间不足时，会将对象移动到老年代。</li>
<li>当老年代也满了或者空间不够了，会触发新年代和老年代的GC，两者分别为：MinorGC和FullGC。</li>
</ul>
</li>
</ul>
<h3 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h3><ul>
<li>引用计数法：有地方引用这个对象，计数器久加一，引用失效久减一。但是不能解决相互引用的问题。</li>
<li>可达性分析算法：以根作为起始点，沿着节点向下搜索，如果一个对象没有可以搜索到的路径，认为该对象不可达，即该对象不可用，可以回收。</li>
</ul>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p>​    通过new关键字创建的引用就是强引用，强引用就算内存不足，gc也不会删除它。软引用可以和ReferenceQueue一块使用，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。弱引用通过WeakReference类实现，弱引用的生命周期比软引用短，无论当前内存空间是否足够，弱引用都会被删除。虚引用也叫幻象引用，通过PhantomReference类来实现。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<h3 id="垃圾收集器的种类"><a href="#垃圾收集器的种类" class="headerlink" title="垃圾收集器的种类"></a>垃圾收集器的种类</h3><ul>
<li>Serial垃圾收集器：单线程、复制算法。进行垃圾回收的同时，必须暂停其他所有工作线程。</li>
<li>ParNew垃圾收集器：Serial收集器的多线程版本。也是需要暂停其他线程，在垃圾回收过程中。</li>
<li>Paraller Scavenge垃圾收集器：多线程复制算法、高效。</li>
<li>Serial Old垃圾收集器：单线程标记整理算法。主要回收老年代。</li>
<li>Paraller Old垃圾收集器：多线程标记整理算法。</li>
<li>CMS收集器：多线程标记清楚算法。有四个阶段：1）初始标记。2）并发标记。3）重新标记。4）并发清楚。</li>
<li>G1垃圾收集器：基于标记整理算法，不产生内存碎片。可以精确控制停顿时间，在不牺牲吞吐量的情况下实现低停顿垃圾回收。</li>
</ul>
<h3 id="JVM调优的工具"><a href="#JVM调优的工具" class="headerlink" title="JVM调优的工具"></a>JVM调优的工具</h3><ul>
<li>jconsole：对jvm中的内存、线程和类进行监控</li>
<li>jvisualvm：可以分析内存快照、线程快照、程序死锁、监控内存变化、gc等</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>​    类加载机制分为五个部分：加载-验证-准备-解析-初始化。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_B2026A3771A2-1.jpeg" alt="IMG_B2026A3771A2-1"></p>
<ul>
<li><p>加载：生成该类的Class对象。</p>
</li>
<li><p>验证：主要是确保Class文件是否符合要求。</p>
</li>
<li><p>准备：为类变量分配内存空间。</p>
</li>
<li><p>解析：虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
</li>
<li><p>初始化：执行类中定义的Java代码。</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>​    对于任意一个类，需要加载它的类加载器和这个类本身一同确立这个类在JVM中的唯一性，每一个类加载器都有一个独立的类名称空间。类加载器就是通过完全限定名将class文件加载到jvm中，再转换为class对象。</p>
<p>  类加载器有三种：启动类加载器、扩展类加载器、应用类加载器。</p>
<ul>
<li>双亲委派模型：类加载器接收到类加载任务时，会交给父类加载器完成，这样，所有的加载请求都会传递到启动类加载器，只有当父类无法完成加载请求，子加载器才会去尝试加载类。好处就是无论哪个类加载器进行加载，最后得到的都是jvm中唯一的class对象。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>对于两个类的情况，即一个父类和一个子类，执行顺序如下。执行父类的静态初始化块。执行子类的静态初始化块。执行父类的非静态初始化块。执行父类的构造器。执行子类的非静态初始化块。执行子类的构造器。</li>
<li>编译是javac test.java。运行是java test。</li>
<li>静态域,main(),构造代码块,构造方法。</li>
<li>Java通过垃圾回收回收不再引用的变量，垃圾回收时对象的finallize（）不一定会得到执行。</li>
<li>判断对象是否可以回收有两个算法，引用计数算法和根搜索算法。垃圾回收算法则有四种，标记清楚算法、复制算法、标记整理算法、分代收集算法Minor GC 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会频繁执行，一般回收速度也比较快。Full GC 也称 Major GC，指发生在老年代的垃圾回收操作。出现了 Full GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。优先在新生代区存放对象，大对象直接放在老年代区，新生代区的对象经历15次GC后就会进入老年代区。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-id="ckuqw9s6o000kxcupfpescftw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/Java输入与输出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="输入输出基础知识"><a href="#输入输出基础知识" class="headerlink" title="输入输出基础知识"></a>输入输出基础知识</h2><p>​    字符编码（英语：Character encoding）也称字集码，是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。常见的例子包括将拉丁字母表编码成摩斯电码和ASCII。其中，ASCII将字母、数字和其它符号编号，并用7比特的二进制来表示这个整数。通常会额外使用一个扩充的比特，以便于以1个字节的方式存储。</p>
<p>​    字符编码就是将字符和一串二进制编码对应起来，例如ASCII编码就是将各种字符和实际的数字（转换的二进制编码）对应起来。</p>
<p>​    常用的字符编码有ASCII、GBK、Unicode等。</p>
<p>​    GBK 采用双字节表示，总体编码范围为 8140-FEFE，首字节在 81-FE 之间，尾字节在 40-FE 之间，剔除 xx7F 一条线。总计 23940 个码位，共收入 21886 个汉字和图形符号，其中汉字（包括部首和构件）21003 个，图形符号 883 个。</p>
<p>​    我们日常接触到的文件分ASCII和Binary两种。ASCII是“美国信息交换标准编码”的英文字头缩写，可称之为“美标”。美标规定了用从0到127的128个数字来代表信息的规范编码，其中包括33个控制码，一个空格码，和94个形象码。形象码中包括了英文大小写字母，阿拉伯数字，标点符号等。</p>
<p>​    Unicode其实就是宽字节字符集，它对每个字符都固定使用两个字节即16位表示，于是当处理字符时，不必担心只处理半个字符。UTF-8是Unicode编码的一种实现，因为Unicode对于一个字符的表示比较长，所以UTF-8采用了动态长度的方法进行编码。UTF-8是兼容ASCII，第一个字节与ASCII相容，理论上可以达到四个字节。</p>
<p>​    读入一个字节序列的对象叫做输入流，写出一个字节序列对象叫做输出流。实际传输的都是01，但是Java分为字节流和字符流。</p>
<p>处理字节的Stream类结构。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_894224ED70D2-1.jpeg" alt="IMG_894224ED70D2-1"></p>
<p>处理字符的Reader和Writer：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_C3D453ADB75A-1.jpeg" alt="IMG_C3D453ADB75A-1"></p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>​    对象序列化就是将Java中的对象转换为固定格式的字节。想要实现序列化必须实现Serializable接口。</p>
<p>​    序列化的机制：每个对象都用一个序列号保存，即每个对象都关联一个序列号。当序列化时，遇到这个对象第一次时正常序列化，保存其对象。当第二次遇到时，只需要写出之前对象关联的序列号即可。读会对象则是相反，遇到一个序列号时，构建这个对象，并使用流中的数据初始化它。当遇到和这个序列号相同的对象时，获取这个对象引用即可。</p>
<p>​    使用transient关键字可以将某些域声明为不可序列化。</p>
<p>​    Java中存在三种复制，第一种直接赋值，第二种浅拷贝，第三种深拷贝。</p>
<p>​    直接赋值如：A a = a2;当a2变化时，a也会变化。</p>
<p>​    浅拷贝：clone方法，当对象里面还有引用对象时，只是复制引用不复制引用对象。所以当对对象里面的引用对象进行修改时，两者都会变化。</p>
<p>​    深拷贝：无论值还是对象里面的引用对象都进行了拷贝。复制后的对象的修改不影响双方。可以使用序列化来实现。</p>
<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>​    这一部分没啥可讲的，就正常操作文件就行，使用File类，注意操作文件时使用的字符串和当时的机器环境即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" data-id="ckuqw9s6o000lxcupg0g2cq7j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/Java集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合的框架图"><a href="#集合的框架图" class="headerlink" title="集合的框架图"></a>集合的框架图</h3><p>集合框架中继承关系：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_0ABE1119FACC-1.jpeg" alt="IMG_0ABE1119FACC-1"></p>
<p>常用的各个集合的作用和特点：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_62E779E2DD25-1.jpeg" alt="IMG_62E779E2DD25-1"></p>
<h3 id="LIst相关知识点"><a href="#LIst相关知识点" class="headerlink" title="LIst相关知识点"></a>LIst相关知识点</h3><ul>
<li>List是有序的Collection（指的是插入顺序）</li>
<li>ArrayList是常用的List，通过数组实现。允许对元素快速访问。扩容是当前容量*1.5+1,当元素满的时候扩容。线程不安全。</li>
<li>Vector也是通过数组实现的，但是它支持多线程访问。速度比ArrayList慢。初始化为10，同步的实现原理是synchronized.</li>
<li>LinkedList通过双向循环链表数据结构，插入和删除比较方便，随机访问比较慢。</li>
</ul>
<h3 id="Set相关知识点"><a href="#Set相关知识点" class="headerlink" title="Set相关知识点"></a>Set相关知识点</h3><ul>
<li>Set主要存放的无序的元素（指的是插入的顺序），值不能重复，只允许插入一个空元素。</li>
<li>HashSet是按照Hash值来存取元素的，只能通过迭代器访问元素。</li>
<li>TreeSet是使用二叉树的原理对元素进行顺序排序。</li>
<li>LinkedHashSet继承HashSet又基于LinkedHashMap实现。</li>
</ul>
<h3 id="Map相关知识点"><a href="#Map相关知识点" class="headerlink" title="Map相关知识点"></a>Map相关知识点</h3><ul>
<li>HashMap就是键值映射，能够存储null值和一个null的key，线程不安全。其他可以看看博客。线程安全问题存在扩容情况，就是多个线程扩容时，会造成环链的情况，导致无限循环。</li>
<li>Hashtable 是一个哈希表，该类继承自Dictionary类，实现了 Map 接口。HashMap是基于哈希表实现的，该类继承AbstractMap，实现Map接口。Hashtable 线程安全的，而 HashMap 是线程不安全的。HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li>
<li>ConcurrentHashMap支持并发操作，采用的是分段锁的形式。Segment代表一个段，一个Segment又代表了一个小型的HashMap，默认并发度为16即16个Segment。</li>
<li>TreeMap是排序map，能够将存储的元素进行排序，默认是升序，需要插入的元素实现Comparable接口。</li>
<li>LinkHashMap继承HashMap，保存了插入的顺序。</li>
<li>重写equals时一定要重写hashcode，因为不重写会导致，map中判断相同的对象无法达到覆盖的目的。equals判断为true，hashcode可能为false。</li>
<li>WeakHashMap使用的是弱引用保存键。</li>
</ul>
<h3 id="迭代器相关知识点"><a href="#迭代器相关知识点" class="headerlink" title="迭代器相关知识点"></a>迭代器相关知识点</h3><ul>
<li>使用迭代器的原因就是可以在迭代过程中删除元素。还有就是解耦合，将遍历Collection和具体的实现抽离出来。</li>
<li>具体使用代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; abc = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">            add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Iterator&lt;String&gt; it  = abc.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.err.println(it.next());</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ListIteratort只能遍历List，Iterator不仅可以遍历List也可以遍历Set。Iterator只能单向遍历，ListIterator可以双向遍历。ListIterator也添加了其他的功能，添加一个元素、替换一个元素、获取前面的元素或者后面的元素。</li>
</ul>
<h3 id="集合的其他知识点"><a href="#集合的其他知识点" class="headerlink" title="集合的其他知识点"></a>集合的其他知识点</h3><ul>
<li>foreach循环内部实现是使用迭代器的，但是最好不要在里面执行元素的删除</li>
<li>迭代器的remove方法会删除指针的前一个元素。调用这个方法时一定要调用next方法控制指针</li>
<li>可以通过instanceof RandomAccess接口来判断当前集合是否支持高效的随机访问。</li>
<li>链表添加元素一般都是在末尾，使用迭代器可以在特定位置添加元素。（ListIterator）</li>
<li>优先级队列可以按任意顺序插入，但是最后删除时是排序的，会获取最小的元素。</li>
<li>映射视图和MySQL中的视图类似，将键、值、键值组成不同的视图。如果在视图上调用remove方法，会删除，但是不能增加元素。</li>
<li>Hashtable和HashMap作用一样，不过前者是同步的，后者是不同步的。</li>
<li>java中的sub一般都是第一个包含在内，第二个参数不包含在内。</li>
<li>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。</li>
<li>队列先进先出，栈先进后出</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/" data-id="ckuqw9s6p000mxcup0pilekoe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/枚举类练习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%BB%83%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="枚举类了解及练习"><a href="#枚举类了解及练习" class="headerlink" title="枚举类了解及练习"></a>枚举类了解及练习</h2><p>​    工作中遇到一个类，发现使用到了枚举，这次也顺带着了解一下。很多东西虽然自己知道但是没有再工作中遇到，也没有去想什么地方能遇到。后面也会对这类知识点在工作中的使用专门写一些博客。</p>
<p>​    枚举类型比较特殊，算是Java中一个比较特殊的类。下面就列一个简单的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> enumtrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClothesSize.java</span></span><br><span class="line"><span class="comment"> * Description: 衣服大小枚举类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ClothesSize</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类,利用构造方法传参。这里的四个码号其实相当于四个实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    S(<span class="string">&quot;S号&quot;</span>), L(<span class="string">&quot;L号&quot;</span>), XL(<span class="string">&quot;XL号&quot;</span>), XXL(<span class="string">&quot;XXL号&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 构造方法，将枚举项的值赋值给枚举类的普通属性，再通过公共方法获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-07-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ClothesSize(String size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面就是一个简单的枚举类的例子。可以看到其实枚举相当于Java中的常量，类似下面代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ABA = <span class="string">&quot;气温&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​    但是枚举类要丰富的很多，里面可以写一些方法和变量，相对于上面的常量的定义要灵活的多。下面也给个例子如何使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> train;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> enumtrain.ClothesSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClothesSizeTest.java</span></span><br><span class="line"><span class="comment"> * Description:  枚举类测试方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClothesSizeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印枚举值的值和name</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClothesSize clothesSize = ClothesSize.XL;</span><br><span class="line">        System.err.println(<span class="string">&quot;根据构造方法获取枚举类型的值：&quot;</span> + clothesSize.getSize());</span><br><span class="line">        System.err.println(<span class="string">&quot;直接获取枚举类型的name&quot;</span> + clothesSize.toString());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取全部的枚举值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClothesSize[] clothesSizes = ClothesSize.values();</span><br><span class="line">        <span class="keyword">for</span> (ClothesSize clothesSize1 : clothesSizes) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;枚举值name为：&quot;</span> + clothesSize1.toString() + <span class="string">&quot;，枚举值value为：&quot;</span> + clothesSize1.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据键盘的输入取对应的枚举值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String input = scanner.next().toUpperCase();</span><br><span class="line">        ClothesSize clothesSize1 = Enum.valueOf(ClothesSize.class, input);</span><br><span class="line">        System.err.println(<span class="string">&quot;输入的枚举值name为：&quot;</span> + clothesSize1.toString() + <span class="string">&quot;，输入的枚举值value为：&quot;</span> + clothesSize1.getSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行的截图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200630233928092.png" alt="image-20200630233928092"></p>
<p>说到底，还是简单的使用。一旦到了工作中还是会忘记，因为还是没有在工作中使用，所以忘记的比较快。下面也给出一个代码，希望自己不要忘记。后面也会列举出工作中的使用。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200630234426659.png" alt="image-20200630234426659"></p>
<p>​    有大佬知道这段代码的作用也可以给菜鸟说一下。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%BB%83%E4%B9%A0/" data-id="ckuqw9s6p000nxcup8x658qjd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/第七章、异常、断言和日志" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第7章-异常、断言和日志"><a href="#第7章-异常、断言和日志" class="headerlink" title="第7章 异常、断言和日志"></a>第7章 异常、断言和日志</h2><p>​    之前写过异常的文章，部分内容不是很正确，而且整篇文章结构也有些不恰当，这里修改了文章，添加了一些内容。</p>
<h4 id="错误的产生原因"><a href="#错误的产生原因" class="headerlink" title="错误的产生原因"></a>错误的产生原因</h4><p>​    没有人能写出没有BUG的程序，除非这个程序太过于简单。BUG其实就是程序的一些错误，可能是代码的问题，也可能是输入的问题。Java中的异常机制其实也是为了解决这些问题，其他语言也有类似的机制。</p>
<h4 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h4><p>​    Java中，异常都是基于Throwable，Throwable下面又有两个基类。Error和Exception。</p>
<p>​    Error代表Java运行时系统的内部错误和资源耗尽错误，其实就是Java虚拟机出错了。</p>
<p>​    Exception则又分为两类，RuntimeException和其他异常。RuntimeException就是运行时异常，一般都是程序代码有问题。例如：</p>
<blockquote>
<p>错误的类型转换。</p>
<p>数组访问越界。</p>
<p>访问 null 指针。</p>
</blockquote>
<p>其他异常则相反，不是程序代码的问题。所以也叫其他异常。一般有以下几种：</p>
<blockquote>
<p>试图在文件尾部后面读取数据。</p>
<p>试图打开一个不存在的文件。</p>
<p>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。</p>
</blockquote>
<p>​    Java将其他异常称为受查异常，Error和RuntimeException统称为非受查异常。为什么这样分？因为受查异常是没法考虑周全的，所以编译器在编写代码时会检查所有的受查异常是否都有异常处理器（就是那个try块）。非受查异常一般可以通过代码来避免（RuntimeException），也有代码处理不了的（Error）。所以对于非受查异常来说代码其实能做的不多，所以你很少见到代码会throw一个非受查异常，非受查异常一般都是通过捕获来进行处理。</p>
<p>​    总的来说，方法应该尽可能声明会抛出的受查异常，非受查异常要么不可控，要么不应该出现。如果方法没有声明或者捕获受查异常，编译器也会有一个警告。</p>
<h4 id="异常的处理办法"><a href="#异常的处理办法" class="headerlink" title="异常的处理办法"></a>异常的处理办法</h4><p>​    这里说的异常的处理方法其实就是指捕获，捕获的代码格式比较简单。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//可能发生异常的代码</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="comment">//捕获的异常和捕获后要做的事</span></span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//最后要做的事</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    这种结构的代码大家估计看的很多了，这里提几个需要注意的点：</p>
<ul>
<li>try语句后面可以只有finally语句，没有catch语句。也就是说必须要有其中一个。</li>
<li>finally语句的返回值会覆盖掉原始的返回值。</li>
<li>finally是在return执行之后，语句返回之前执行的。(可能比较绕，直接看下面代码)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Train</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;finally&quot;</span>+a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    输出结果是<code>finally11\n10</code>，也就是说返回的是10，但是在finally语句开始前，a已经变为11了。</p>
<p>​    对于关闭资源来说，有可能关闭资源的方法也会出现错误，所以要写两个try块，其实也可以这样写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">    out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，无论怎么退出，资源都会关闭。</p>
<p>​    异常的结构和一些注意的点都说了，下面说一下异常机制的一些小技巧。</p>
<ul>
<li>异常处理不能代替简单的测试</li>
<li>不要过分的细化异常</li>
<li>利用异常层次结构</li>
<li>不要压制异常</li>
<li>在监测错误时，严格要比放任好</li>
<li>不要害怕传递异常</li>
</ul>
<h4 id="处理错误的其他方法"><a href="#处理错误的其他方法" class="headerlink" title="处理错误的其他方法"></a>处理错误的其他方法</h4><p>​    错误的产生最后形式可能不仅仅是异常，如何处理其他的错误呢？下面介绍两种，断言和日志。</p>
<h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><p>​    断言我其实用的很少（几乎没有）。只有在源码中才会看到断言。断言机制其实是测试中间会用到的一种检查，测试时，断言能够对语句或者变量进行检查，代码发布后，这些语句将会自动移走以增加程序的运行速度。其实IDE的调试功能可能会好用一些。大家感兴趣也可以查查，这里了解的不多，也就不再叙述用法和详解了。</p>
<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>​    日志在开发中用的比较多，日志相对于直接打印优点比较多，这里不再累述了。日志框架也比较多，之前也做过分析和介绍。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38533859/article/details/107210715?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162203960016780261995962%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162203960016780261995962&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-107210715.nonecase&utm_term=%E6%97%A5%E5%BF%97&spm=1018.2226.3001.4450">SpringBoot集成Log4j2日志框架</a>。后续也会更新一下日志框架的相关博客。这里也是不再累述了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    总的来说，异常机制、断言、日志都是为了让我们代码调试过程中更加方便。下面再说一下调试的一些技巧。</p>
<ul>
<li>每个类可以放一个主函数方便调试，也可以通过写测试类来实现。</li>
<li>多用日志。</li>
<li>利用Throwable提供的printStackTrace可以打印堆栈信息，方便调试。</li>
<li>也可以使用一些Java虚拟机调试工具来监控和管理Java程序。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" data-id="ckuqw9s6q000oxcup8rif1pum" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/第九章、集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第9章-集合"><a href="#第9章-集合" class="headerlink" title="第9章 集合"></a>第9章 集合</h2><p>​    集合平时使用的比较多，但是自己很少往深处去看看其实现和原理，这次趁着这个机会了解一下，完全搞懂还是要看自己后续的使用和深挖。</p>
<h3 id="集合框架了解"><a href="#集合框架了解" class="headerlink" title="集合框架了解"></a>集合框架了解</h3><p>​    想要了解集合，就需要先了解集合框架，这里也以最熟悉的队列（queue）为例来介绍集合框架。</p>
<ul>
<li><p>集合的接口与实现分离</p>
<p>和大多数的设计思想一样，集合的接口和实现也是分离的。队列接口指出了可以在队列的尾部添加元素，在头部删除元素，查找队列中元素的个数。队列的实现通常存在两种形式，一种是使用循环数组，一种是使用链表。这样设计的目的是为了：构建集合时不需要知道使用哪种实现，只有在使用集合对象时，才会确定具体的类。同时也是为了保证：一旦程序改变了想法，只需要在一个地方就可以快捷的改变，即改变调用构造器的地方。</p>
</li>
<li><p><code>Collection</code>接口</p>
<p>集合类的基本接口是<code>Collection</code>接口，这个接口有很多方法，详细可以看一下这个网址：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a>.</p>
<p>同时，<code>Collection</code>接口又继承了<code>Iterable</code>接口。说到这里就不得不提<code>Iterator</code>和<code>Iterable</code>接口的关系，前者是迭代器对象，后者则是定义了如何返回迭代器方法的接口。</p>
<p>迭代器接口有四个方法。<code>hasNext();,next();,remove(),forEachRemaining(Consumer&lt;? super E&gt; action)</code>.方法的作用看名称就能看出来，不需要多讲什么。需要注意的就是：迭代器的指针是位于两个元素之间的，不是正好指向元素的位置。所以调用<code>next()</code>方法是先越过下一个元素，再返回越过元素的引用。</p>
</li>
<li><p>范型使用方法</p>
<p>不难看出，集合框架中的接口都是范型接口，所以也可以编写一些实用的范型方法，现实也确实这么做了。<code>Collection</code>接口中声明了很多方法。作为实现者来说可以通过实现<code>AbstractCollection</code>接口来定制化自己的需求，同时也不用提供其他不需要的例行方法。具体实现的细节可以看看源码。</p>
</li>
<li><p>集合框架中的接口</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_8073B96B2C46-1.jpeg" alt="IMG_8073B96B2C46-1"></p>
<p>上图已经很明白这个接口之间的关系了。</p>
<h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_2A63A75F65C0-1.jpeg" alt="IMG_2A63A75F65C0-1"></p>
<p>​    下面就来详细介绍一下各个集合的信息和部分集合的用法。</p>
</li>
<li><p>链表</p>
<p>链表的优点就是删除和增加元素时消耗不大（只是修改前后元素的引用），但是随机访问时的消耗要比数组大的多。</p>
<p>在Java语言中，所有的链表实际都是双向链表，即后一个元素存放着前一个元素的引用。</p>
<p>Java中的链表中的add方法是将元素添加到链表尾部，但是实际使用中很少遇到这种需求，都是在链表中部添加元素。所以这种对于指定位置添加元素的方法都可以交给迭代器去处理。但是使用迭代球也需要注意：可以给一个容器添加多个迭代器，但是应该只有一个迭代器能够读写，其他迭代器尽量不要读写，只给读的权限即可。光说也体现不出什么，实际撸代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedListTrain.java</span></span><br><span class="line"><span class="comment"> * Description:  链表练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; a = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        a.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        a.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        a.add(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        List&lt;String&gt; b = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        b.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        ListIterator&lt;String&gt; aIter = a.listIterator();</span><br><span class="line">        Iterator&lt;String&gt; bIter = b.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bIter.hasNext()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在当前位置前添加一个元素</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (aIter.hasNext()) aIter.next();</span><br><span class="line">            aIter.add(bIter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(a);</span><br><span class="line">        bIter = b.iterator();</span><br><span class="line">        <span class="keyword">while</span> (bIter.hasNext()) &#123;</span><br><span class="line">            bIter.next();</span><br><span class="line">            <span class="keyword">if</span> (bIter.hasNext()) &#123;</span><br><span class="line">                bIter.next();</span><br><span class="line">                <span class="comment">//删除前一个元素</span></span><br><span class="line">                bIter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(b);</span><br><span class="line"></span><br><span class="line">        a.removeAll(b);</span><br><span class="line">        System.err.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在敲这段代码的时候先猜一下实际会打印什么，我第一次猜的时候错的离谱。</p>
</li>
<li><p>数组列表</p>
<p>这个没有啥好讲的，ArrayList用的比较多，需要注意的就是：需要同步时使用Vector，不需要同步时使用ArrayList。</p>
</li>
<li><p>散列集</p>
<p>用处就是随机访问集合中的任意元素，并且概率相同。涉及到数据结构。</p>
<p>原理就是散列表为每一个对象计算一个散列码（hash code），散列码是由对象的实例产生的一个整数。具体使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SetTrain.java</span></span><br><span class="line"><span class="comment"> * Description: Set练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (!in.hasNext(<span class="string">&quot;eof&quot;</span>)) &#123;</span><br><span class="line">                String word = in.next();</span><br><span class="line">                <span class="comment">//因为电脑的性能不同，这里可能会是0</span></span><br><span class="line">                <span class="keyword">long</span> callTime = System.currentTimeMillis();</span><br><span class="line">                System.err.println(callTime);</span><br><span class="line">                words.add(word);</span><br><span class="line">                callTime = System.currentTimeMillis() - callTime;</span><br><span class="line">                System.err.println(callTime);</span><br><span class="line">                l += callTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;String&gt; iterator = words.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span> &amp;&amp; iterator.hasNext(); i++) &#123;</span><br><span class="line">            System.err.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        System.err.println(words.size() + <span class="string">&quot;时间花费&quot;</span> + l + <span class="string">&quot;时间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树集</p>
<p>涉及到数据结构，之前学的都忘的差不多了。和红黑树类似，后续可以算法那部分继续了解，这里只是简单的上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ItemTest.java</span></span><br><span class="line"><span class="comment"> * Description:  树集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemTest</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ItemTest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> partNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemTest</span><span class="params">(String adescription, <span class="keyword">int</span> apartNumber)</span> </span>&#123;</span><br><span class="line">        description = adescription;</span><br><span class="line">        partNumber = apartNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ItemTest&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, partNumber=&quot;</span> + partNumber +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比较，需要注意的是对象可能是个null对象，但是仍然要返回true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ItemTest other = (ItemTest) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(description, other.description) &amp;&amp; partNumber == other.partNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(description, partNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ItemTest o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比较int的大小和string的长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> diff = Integer.compare(partNumber, o.partNumber);</span><br><span class="line">        <span class="keyword">return</span> diff != <span class="number">0</span> ? diff : description.compareTo(o.description);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.NavigableSet;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedSet;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSetTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 树集练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 代码写完，还是不明白，后续了解。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SortedSet&lt;ItemTest&gt; itemTests = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        itemTests.add(<span class="keyword">new</span> ItemTest(<span class="string">&quot;A&quot;</span>, <span class="number">123</span>));</span><br><span class="line">        itemTests.add(<span class="keyword">new</span> ItemTest(<span class="string">&quot;B&quot;</span>, <span class="number">456</span>));</span><br><span class="line">        itemTests.add(<span class="keyword">new</span> ItemTest(<span class="string">&quot;C&quot;</span>, <span class="number">789</span>));</span><br><span class="line">        System.err.println(itemTests);</span><br><span class="line"></span><br><span class="line">        NavigableSet&lt;ItemTest&gt; itemTests1 = <span class="keyword">new</span> TreeSet&lt;&gt;(Comparator.comparing(ItemTest::getDescription));</span><br><span class="line">        itemTests1.addAll(itemTests);</span><br><span class="line">        System.err.println(itemTests1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>优先级队列</p>
<p>优先级队列就是一个可以自我调整的二叉树，对树执行添加和删除操作时，可以让最小的元素移动到根，而不必花费时间对元素进行排序。代码的使用很简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PriorityQueueTest.java</span></span><br><span class="line"><span class="comment"> * Description: 优先级队列练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;LocalDate&gt; localDates = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        localDates.add(LocalDate.MAX);</span><br><span class="line">        localDates.add(LocalDate.MIN);</span><br><span class="line">        localDates.add(LocalDate.of(<span class="number">1903</span>, <span class="number">12</span>, <span class="number">10</span>));</span><br><span class="line">        localDates.add(LocalDate.of(<span class="number">1902</span>, <span class="number">12</span>, <span class="number">10</span>));</span><br><span class="line">        localDates.add(LocalDate.of(<span class="number">1903</span>, <span class="number">11</span>, <span class="number">10</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;打印&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (LocalDate localDate : localDates) &#123;</span><br><span class="line">            System.err.println(localDate);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 只取出最小的删除，无论如何操作。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!localDates.isEmpty()) &#123;</span><br><span class="line">            System.err.println(localDates.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>​    有时集合并不是很适合，例如我们知道某些键的信息，但是想查询与键对应的值。映射就是为了解决这类问题或场景而设计的。</p>
<ul>
<li><p>映射基本用法</p>
<p>映射的两个通用实现分别为：HashMap,TreeMap。名字已经很清楚了。一个时散列映射，一个是树映射。散列只能将键散列，树映射也是对键的整体顺序排序。</p>
<p>映射中有一些常用的方法，例如：<code>get(k),put(k,v),remove(k),size(),forEach()</code>，映射中键是唯一的，同一个键重复赋值，后一次的赋值会覆盖掉前一次的赋值。</p>
<p>需要注意的就是如果代码中有更新映射的需求，需要先判断这个键是否存在，在执行对应的逻辑，代码中很容易就实现了，这里不在列举出详细代码。</p>
<p>使用起来也是比较简单，这个还是比较常用的，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; stringStringMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">stringStringMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">stringStringMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">stringStringMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">stringStringMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">  </span><br><span class="line">System.err.println(stringStringMap);</span><br><span class="line">  </span><br><span class="line">stringStringMap.remove(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">  </span><br><span class="line">stringStringMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">System.err.println(stringStringMap.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 还是需要再了解和使用lambda表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stringStringMap.forEach((k, v) -&gt; System.err.println(<span class="string">&quot;key&quot;</span> + k + <span class="string">&quot;===&quot;</span> + <span class="string">&quot;value&quot;</span> + v));</span><br></pre></td></tr></table></figure></li>
<li><p>视图和其他映射</p>
<p>视图就是将映射中的元素存放到集合中（官方认为映射不是一个集合）。有三种映射，键集、值集合和键/值对集。需要注意的时键集中删除某个键，映射中也会删除这个键和其对应的值，但是添加则不行。</p>
<p>弱散列映射，当对键的唯一引用来自于散列条目时，这一数据结构将与垃圾回收器协同工作一起删除键/值对。WeakHashMap使用弱引用来保存键。弱引用其实是将强引用包装，想要获得该对象需要用get方法，具体这里的实现原理可以看一下WeakHashMap的源码，这里水平太差，估计要放到后面留个坑了。</p>
<p>链接散列集与映射，类似于一个双向链表，调用get和put时，会影响该元素在映射中的位置。其实可以修改这个映射，将用的多的元素放到缓存中。这里不再列举代码了。</p>
<p><code>EnumSet</code>是枚举元素集，实现是用位序列，如果对应的值在集中，则相应的位置被置位1。</p>
<p>标志散列映射，<code>IdentityHashMap</code>类比较特殊，键的散列值不是用<code>hashCode()</code>计算的，是使用<code>identityHashCode()</code>计算的，这个方法和<code>hashCode()</code>的区别看一看看源码，大概就是比较时一个使用的是<code>==</code>，一个是<code>equals()</code>。</p>
</li>
</ul>
<h3 id="视图和包装器"><a href="#视图和包装器" class="headerlink" title="视图和包装器"></a>视图和包装器</h3><p>​    这一部分感觉设计到设计模式，这一块目前还不是很熟悉，很多用法不知道为什么这样设计以及这样做的好处。就简单介绍记录一下吧。</p>
<p>​    视图有几种，子范围的视图、不可修改的视图、同步视图、受查视图。作用名称已经很清楚了。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    上面也说过了，映射和集合是一种数据结构，自然离不开算法，看到现在也大致了解了，这些的集合和映射的实现离不开算法。但是感觉现在自己学起来还是比较空，就再给自己留个坑吧。</p>
<p>就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81%E9%9B%86%E5%90%88/" data-id="ckuqw9s6r000pxcup1o7g3xri" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/第八章、范型程序设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E8%8C%83%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2021-10-14T10:09:31.647Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第8章-范型程序设计"><a href="#第8章-范型程序设计" class="headerlink" title="第8章 范型程序设计"></a>第8章 范型程序设计</h2><p>​    范型要解决的问题就是让编写的代码可以被很多不同的类型所重用。例如<code>List&lt;String&gt;</code>,就是一个简单的范型的使用。</p>
<p>​    下面就列举一个简单的范型的代码例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型练习类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParadigmTrain1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate[] dates = &#123;LocalDate.of(<span class="number">1996</span>, <span class="number">12</span>, <span class="number">9</span>), LocalDate.of(<span class="number">1997</span>, <span class="number">5</span>, <span class="number">15</span>), LocalDate.of(<span class="number">1998</span>, <span class="number">5</span>, <span class="number">15</span>)&#125;;</span><br><span class="line">        Pair&lt;LocalDate&gt; result = minmax(dates);</span><br><span class="line">        System.err.println(result.getFirst());</span><br><span class="line">        System.err.println(result.getSecond());</span><br><span class="line">      	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里可以通过参数的形式来推断出范型的类型，所以不需要输入范型的类型参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>);	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 输入的参数必须要实现Comparable。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> paradigmtrain.Pair&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个范型是对参数进行限制，第二个是返回的类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((a == <span class="keyword">null</span>) || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T min = a[<span class="number">0</span>];</span><br><span class="line">        T max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> aLength = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aLength; i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 比较大小，通过compareTo方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以通过对范型参数添加<code>extends</code>，来限制范型参数的类型。如下：</p>
<p><code>public static &lt;T extends Comparable &amp; Serializable&gt; Pair&lt;T&gt; minmax(T[] a) &#123;</code></p>
</li>
<li><p>范型的原理。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_4294825AB109-1.jpeg" alt="IMG_4294825AB109-1"></p>
<p>注意：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_4DB8B172B25A-1.jpeg" alt="IMG_4DB8B172B25A-1"></p>
</li>
<li><p>为了解决类型擦除于多态的冲突，需要生成一个桥方法。（比较复杂，了解即可）</p>
</li>
<li><p>关于范型的事实。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_9B4D064EA133-1.jpeg" alt="IMG_9B4D064EA133-1"></p>
</li>
<li><p>范型的约束和局限</p>
<ul>
<li><p>不能用基本类型实例化类型参数。类型擦除后，变为Object，但是Object不能存储基本类型的值。</p>
</li>
<li><p>运行时类型查询只适用于原始类型。即这个代码是错误的。<code>if(a instanceof Pair&lt;String&gt;)</code>（无法判断）。</p>
</li>
<li><p>不能创建参数化类型的数组。数组会记住它的元素类型，如果试图存储其他类型的元素会报异常。</p>
</li>
<li><p>不能构造范型数组。</p>
</li>
<li><p>不能实例化类型变量。</p>
</li>
<li><p>范型类的静态上下文中类型变量无效。</p>
</li>
<li><p>不能抛出或捕获范型类的实例。</p>
</li>
</ul>
</li>
<li><p>范型类型的继承规则。Employee是Manager的父类，但是<code>Pair&lt;Employee&gt;</code>不是<code>Pair&lt;Manager&gt;</code>的父类。</p>
</li>
<li><p>通配符类型中，允许类型参数变化。</p>
<p>看书是有点枯燥的，尤其这种难读的东西，下面写个例子，把上面的东西串联起来。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain2.java</span></span><br><span class="line"><span class="comment"> * Description:  综合练习，把范型知识点串联起来</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParadigmTrain2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Manager ceo = <span class="keyword">new</span> Manager(<span class="string">&quot;zhangshan&quot;</span>, <span class="number">8000</span>, <span class="number">24</span>);</span><br><span class="line">        Manager cfo = <span class="keyword">new</span> Manager(<span class="string">&quot;lisi&quot;</span>, <span class="number">9000</span>, <span class="number">25</span>);</span><br><span class="line">        Pair&lt;Manager&gt; managerPair = <span class="keyword">new</span> Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">        printBuddies(managerPair);</span><br><span class="line"></span><br><span class="line">        ceo.setMoney(<span class="number">10000</span>);</span><br><span class="line">        cfo.setMoney(<span class="number">20000</span>);</span><br><span class="line">        Manager[] managers = &#123;ceo, cfo&#125;;</span><br><span class="line">        Pair&lt;Manager&gt; managerPair1 = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">        minMaxBonus(managers, managerPair1);</span><br><span class="line">        System.err.println(<span class="string">&quot;minMaxBonus:&quot;</span> + managerPair1.getFirst().getName() + <span class="string">&quot;==&quot;</span> + managerPair1</span><br><span class="line">                .getSecond().getName());</span><br><span class="line">        maxMinBonus(managers, managerPair1);</span><br><span class="line">        System.err.println(<span class="string">&quot;minMaxBonus:&quot;</span> + managerPair1.getFirst().getName() + <span class="string">&quot;==&quot;</span> + managerPair1</span><br><span class="line">                .getSecond().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 通配符类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; pair)</span> </span>&#123;</span><br><span class="line">        Employee employee = pair.getFirst();</span><br><span class="line">        Employee employee1 = pair.getSecond();</span><br><span class="line">        System.err.println(<span class="string">&quot;printBuddies&quot;</span> + employee.getName() + <span class="string">&quot;====&quot;</span> + employee1.getName() + <span class="string">&quot;=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 通配符的超类型限定，限定父类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> managers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minMaxBonus</span><span class="params">(Manager[] managers, Pair&lt;? <span class="keyword">super</span> Manager&gt; pair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (managers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Manager min = managers[<span class="number">0</span>];</span><br><span class="line">        Manager max = managers[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; managers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min.getMoney() &gt; managers[i].getMoney()) min = managers[i];</span><br><span class="line">            <span class="keyword">if</span> (max.getMoney() &lt; managers[i].getMoney()) max = managers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        pair.setFirst(min);</span><br><span class="line">        pair.setSecond(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxMinBonus</span><span class="params">(Manager[] managers, Pair&lt;? <span class="keyword">super</span> Manager&gt; pair)</span> </span>&#123;</span><br><span class="line">        minMaxBonus(managers, pair);</span><br><span class="line">        PairAlg.swapHelper(pair);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairAlg</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 无限定通配符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNull</span><span class="params">(Pair&lt;?&gt; pair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pair.getFirst() == <span class="keyword">null</span> || pair.getSecond() == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; pair)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; tPair)</span> </span>&#123;</span><br><span class="line">        T t = tPair.getFirst();</span><br><span class="line">        tPair.setFirst(tPair.getSecond());</span><br><span class="line">        tPair.setSecond(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E8%8C%83%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" data-id="ckuqw9s6r000qxcup34mv6ej4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C%E5%AD%A6%E4%B9%A0/">C学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker%E5%AD%A6%E4%B9%A0/">Docker学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/netty/">netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storm%E5%AD%A6%E4%B9%A0/">storm学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/">ElasticSearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/PostgreSQL/">PostgreSQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/">Redis</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%8F%E8%AE%AE/">协议</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%8F%E8%AE%AE/HTTP/">HTTP</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E5%BE%97/">心得</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/Dubbo%E6%A1%86%E6%9E%B6/">Dubbo框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/">Spring相关框架</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/elasticsearch%E6%90%AD%E5%BB%BA%E5%92%8Capi%E4%BD%BF%E7%94%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E4%BA%86%E8%A7%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/SQL%E8%AF%AD%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/PostgreSQL/Centos%E5%AE%89%E8%A3%85Postgresql%E5%92%8Cposogis%E6%8F%92%E4%BB%B6/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>