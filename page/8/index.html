<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java反射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><ul>
<li>编译时的类型由声明对象来决定，运行时类型由赋值对象来决定。即编译看左边，运行看右边。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>静态代理：就是在运行前就存在代理的代码，代理类和原始类的关系在运行前就已经确定了。缺点时维护成本高，修改原始类时还要修改代理类。</li>
<li>动态代理：在程序运行期间，通过JVM反射等机制动态的生成代理类的代码，代理类和原始类的关系是在运行后才确定的。</li>
</ul>
<h3 id="反射基础概念"><a href="#反射基础概念" class="headerlink" title="反射基础概念"></a>反射基础概念</h3><p>反射指的是在运行状态中，对于任意一个类能够知道这个类的所有属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectionTrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射小练习</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//通过类的路径来获取Class</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 1 class.forName(&quot;类的路径&quot;)</span></span><br><span class="line"><span class="comment">          * 2 类名.Class</span></span><br><span class="line"><span class="comment">          * 3 实例.getClass</span></span><br><span class="line"><span class="comment">          */</span>          </span><br><span class="line">         Class a=Class.forName(<span class="string">&quot;ReflectionTrain.Sub&quot;</span>);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 1 newInstance: 弱类型。低效率。只能调用无参构造。</span></span><br><span class="line"><span class="comment">          * 2 new: 强类型。相对高效。能调用任何public构造。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         Base b=(Base)a.newInstance();</span><br><span class="line">         <span class="comment">//为什么打印的是 Sub？</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 子类强转为父类，向上转换</span></span><br><span class="line"><span class="comment">          * 通过向上转换，我们能够在编写程序时采用通用程序设计的思想，</span></span><br><span class="line"><span class="comment">          * 在需要使用子类对象的时候，通过把变量定义为父类型，我们可以通过一个变量，使用该父类型的所有子类型实例</span></span><br><span class="line"><span class="comment">          * 子类可以转换为父类，即父类引用指向子类对象。引用的属性是父类的，方法若果被子类重写则是子类的方法。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         b.f();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> * 测试类，测试子类与父类的关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub2</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Sub2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射相关的类：</p>
<ul>
<li>Class类：用来表示类的信息。</li>
<li>Field类：表示类的成员变量。</li>
<li>Method类：表示类的方法。</li>
<li>Constructor类：用来表示类的构造方法。</li>
</ul>
<p>获取Class的三种方法</p>
<p>​    获取Class对象有三种方法：1）通过对象方法。object.getClass();。2）调用类的Class属性，即：Object.class。3）通过Class类中的ForName方法获取，即：Class.forName(“类的全路径”).</p>
<p>​    创建对象的两种方式：调用类的newInstance()方法来创建、通过Class获取Constructor对象，再调用newInstance()方法，这种方法可以选定构造方法。</p>
<p>​    Java有5种方式来创建对象： 1、使用 new 关键字（最常用）： ObjectName obj = new ObjectName(); 2、使用反射的Class类的newInstance()方法： ObjectName obj = ObjectName.class.newInstance(); 3、使用反射的Constructor类的newInstance()方法： ObjectName obj = ObjectName.class.getConstructor.newInstance(); 4、使用对象克隆clone()方法： ObjectName obj = obj.clone(); 5、使用反序列化（ObjectInputStream）的readObject()方法： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }</p>
<h3 id="反射需要注意的"><a href="#反射需要注意的" class="headerlink" title="反射需要注意的"></a>反射需要注意的</h3><ul>
<li>子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。（可以通过反射获取父类的字段）</li>
<li>编译时的类型由声明对象来决定，运行时类型由赋值对象来决定。即编译看左边，运行看右边。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>静态代理：就是在运行前就存在代理的代码，代理类和原始类的关系在运行前就已经确定了。缺点时维护成本高，修改原始类时还要修改代理类。</li>
<li>动态代理：在程序运行期间，通过JVM反射等机制动态的生成代理类的代码，代理类和原始类的关系是在运行后才确定的。</li>
<li>Spring中的IOC使用到了反射，通过反射获取到配置里面类的实例对象，存入到Spring的bean容器中。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/" data-id="ckupl1rq9000h6rupc8h8f2ni" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><p>​    简单范型的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型练习类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParadigmTrain1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate[] dates = &#123;LocalDate.of(<span class="number">1996</span>, <span class="number">12</span>, <span class="number">9</span>), LocalDate.of(<span class="number">1997</span>, <span class="number">5</span>, <span class="number">15</span>), LocalDate.of(<span class="number">1998</span>, <span class="number">5</span>, <span class="number">15</span>)&#125;;</span><br><span class="line">        Pair&lt;LocalDate&gt; result = minmax(dates);</span><br><span class="line">        System.err.println(result.getFirst());</span><br><span class="line">        System.err.println(result.getSecond());</span><br><span class="line">      	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里可以通过参数的形式来推断出范型的类型，所以不需要输入范型的类型参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>);	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 输入的参数必须要实现Comparable。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> paradigmtrain.Pair&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个范型是对参数进行限制，第二个是返回的类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((a == <span class="keyword">null</span>) || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T min = a[<span class="number">0</span>];</span><br><span class="line">        T max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> aLength = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aLength; i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 比较大小，通过compareTo方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>范型方法类型变量要放在方法修饰符后面，返回类型前面。</li>
<li>范型里面，尖括号里面是类代表一个点，如果带有问号，代表一个范围。</li>
<li>限定列表中如果存在类，则必须为限定列表中的第一个。（接口需要放在类后面）</li>
<li>基本数据类型不能用于范型。</li>
<li>范型的查询只能判断原始类型，例如: <code>a instanceof Pair&lt;String&gt;</code> 只能判断a是否是任意一个类型的Pair。</li>
<li>编译器会将范型类型转换为原始类型（类型擦除），有限定类型就使用第一个限定类型，没有就用object代替。返回类型时，由于返回的为限定类型或者为Object，会将限定类型或者Object强制转换为对应的类型。</li>
<li>不允许创建参数化类型的数组。例如<code>Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]</code> 这样是错误的。（可以通过注解消除这个警告）因为范型擦除的存在，所以会将类型进行擦除，导致存储的元素可能不一致。（存储Integer和String都是可以的）</li>
<li>推荐通过功能性接口（Supplier）来实例化类型变量，反射也可以实现，但是比较麻烦。</li>
<li>不能构造范型数组，例如<code>public static &lt;T&gt; T[] minmax(T[] t)</code>这种写法是错误的。这里也是可以利用函数式接口实现。</li>
<li>范型类中，静态代码中的类型变量无效。（因为类型擦除的原因，返回的Onject不知道转换为那种类型）</li>
<li>不能抛出或者捕获范型类的实例。</li>
<li>范型类之间不存在继承关系，无论S和T什么关系，<code>Pair&lt;S&gt;和Pair&lt;T&gt;不存在继承关系</code></li>
<li>如上面所说，<code>Pair&lt;Object&gt;和Pair&lt;String&gt;</code>不存在继承关系，但是方法中想要使用这样的关系如何写呢？这个时候就要用到通配符类型，即？,代码如下：<code>public static void test(Pair&lt;? extends Object&gt; p)</code>这样就可以传String和Integer.通配符类型上届使用extends，下届用super。上届一般用于读取，下届一般用于写入。</li>
<li>桥方法是为了保持多态，具体的原因如下代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * paradigmTrain3.java</span></span><br><span class="line"><span class="comment"> * Description: 范型方法桥方法练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">paradigmTrain3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base&lt;Date&gt; base = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">//这里调用的应该是setFirst(Date date),但是实际会调用setFirst(Object date)</span></span><br><span class="line">        base.setFirst(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是子类的覆盖方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里编译后会生成一个桥方法，为了维持多态</span></span><br><span class="line"><span class="comment">//    public void setFirst(Object date)&#123;</span></span><br><span class="line"><span class="comment">//        setFirst((Date) date);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul>
<li>封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。</li>
<li>继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。</li>
<li>多态：按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。即父对象可以根据赋值的不同子对象调用不同的方法。即调用子对象重写的方法。</li>
<li>抽象：抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法。即将生活中的万物形容成一个个类。</li>
</ul>
<ul>
<li>类与类之间最常见的关系主要有三种：依赖(uses-a)、聚合(has-a)和继承(is-a)。依赖就是屠夫使用刀、聚合就是大雁组成雁群，大雁相对于雁群是聚合关系（两个不同的类）、继承就是儿子继承父亲的家业。</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>简单的内部类代码：</p>
<ul>
<li>内部类就是定义在一个类中的类，最开始的作用就是简化代码，比较便捷。还有就是内部类完善了多重继承，每个内部类都可以独立继承一个接口的实现，但是感觉相对于它所带来的复杂程度而言，带来的便捷性其实不是很好，也可能是我学的比较浅。</li>
<li>内部类对象有一个隐式的引用，指向了实例化该内部类对象的外部类对象。</li>
<li>不需要内部类引用外部类的时候，可以使用静态内部类。</li>
<li>静态内部类创建实例的形式和普通内部类不太一样 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通内部类</span></span><br><span class="line">Out out=<span class="keyword">new</span> Out();</span><br><span class="line">out.in in=out.<span class="function">new <span class="title">in</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line">Out.In in=<span class="keyword">new</span> Out.In();</span><br></pre></td></tr></table></figure>

<ul>
<li>双括号初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双括号的使用方法，匿名列表，适用于只使用一次的数组列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;String&gt; test = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;hah&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><ul>
<li><p>成员内部类</p>
<ul>
<li>成员内部类不能使用static方法和变量</li>
<li>只有创建了外部类才能创建内部类</li>
</ul>
</li>
<li><p>局部内部类</p>
<ul>
<li>可以引用局部变量，但是局部变量必须声明为final（jdk1.8之前）</li>
</ul>
</li>
<li><p>匿名内部类</p>
<ul>
<li>匿名内部类不能有构造方法（构造方法必须和类名相同）</li>
<li>匿名内部类没有访问修饰符</li>
</ul>
</li>
<li><p>静态内部类</p>
<ul>
<li>静态内部类只能访问外部类的静态成员和方法</li>
<li>静态内部类的创建不需要依赖于外部类的对象</li>
</ul>
</li>
</ul>
<h2 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h2><ul>
<li><code>==</code>当两边的是基本类型时，对比的是值，当两边是引用类型时，比较的内存地址。当两边一个基本一个引用时，因为Java自动拆包，所以也是判断值是否相等。</li>
<li>count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0。</li>
<li>非new生成的Integer和new生成的Integer结果只能为false，两个非new比较时，都在-128-127内，比较值，否则比较地址。</li>
<li>+=会自动装箱，将运算的结果转换为相应的类型。<code>byte a = 127;byte b = 126;b = a + b;(错误) b+=a;(正确)</code></li>
<li>自动装箱只能装相应的类型，没法自动转换。</li>
<li>三元运算符会自动做类型提升。</li>
<li>&amp;是逻辑与，会计算两边的等式，&amp;&amp;是短路与，某些情况下只计算左边的等式。｜和｜｜的区别类似。</li>
<li>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。</li>
<li>while循环就是当条件不满足时，跳出，无论while还是dowhile，只不过dowhile第一次无论如何都会执行。</li>
<li>如果不加break，是从case语句匹配的位置往下一直执行</li>
<li>取余取头，取模取尾。java中的%是取余运算，看头。即最后结果的符号看运算符的前面还是后面。</li>
<li>同名方法，不同参数是重载，父类和子类之间是重写。</li>
<li>重写方法时，访问权限不能比父类中被重写的方法的访问权限更低，父类为public，子类不能为private。</li>
<li>编译看左边，运行看右边。 ClassA a = new ClassB();编译时为ClassA，运行时为ClassB。</li>
<li>finally是在return执行之后，语句返回之前执行的。</li>
<li>二维数组定义，一维长度必须定义，二维可以后续定义。</li>
<li>类中的变量可以不用初始化，但是方法中的变量声明后一定要初始化。</li>
<li>try块后面可以不加catch块，但是必须要有finally和catch之一。</li>
<li>Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整。</li>
<li>str.split(&quot;,&quot;)方法是把str字符串根据分割符&quot;,&quot;划分成一个字符串数组，如果str字符串中找不到分隔符&quot;,&quot;，则把整个str字符串放入字符</li>
<li>replaceAll方法的第一个参数是一个正则表达式，.代表所有字符。</li>
<li>如果字符串长度没有初始化长度大，capacity返回初始化的长度，如果append后的字符串长度超过初始化长度，capacity返回增长后的长度。</li>
<li>JSP中：application可以被web应用程序访问，session可以被同一对话访问，request可以被同一请求访问，pageContext可以被当前页面访问。</li>
<li>子类抛出的异常不能比父类的更加广泛，更加广泛的异常类的catch块要放在下面。</li>
<li>所有的异常都是继承Throwable，下层分为Error和Exception，Error描述了Java运行时系统的内部错误和资源耗尽错误。Exception分为运行时异常和其他异常。</li>
<li>Error和Exception都是集成Throwable,其中Exception又被IOException和RuntimeException继承。</li>
<li>枚举类默认的toString方法会将字符串打印出来。</li>
<li>串数组的第一个元素。</li>
<li>静态代码块可以分开写。</li>
<li>导包只可以导到当前层。</li>
<li>包装类的值都是不可变的。</li>
</ul>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><ul>
<li>抽象类是类的抽象化，接口则是抽象方法的集合。抽象类可以被实现类继承，接口则只能被实现类实现。抽象类是自下而上的设计理念，接口则是自上而下的设计理念。两个都不能被实例化。</li>
<li>接口就是在不同层面对一类事物的抽象描述。例如：在生物层面，人和猪都是会吃东西的。但是不同的层面，人和猪可能就不是同一类事物。</li>
<li>抽象类可以存在普通成员变量和静态成员变量，也可以存在静态方法和构造方法、普通方法。接口可以存在成员变量，但都是静态的。接口在1.8之后可以定义静态方法。</li>
</ul>
<h2 id="继承相关的"><a href="#继承相关的" class="headerlink" title="继承相关的"></a>继承相关的</h2><ul>
<li>在构造方法中如果使用关键字 <code>this</code> 调用其他构造方法，则 <code>this(参数列表)</code> 语句必须出现在其他语句之前。super是调用父类的某个构造函数，也必须在第一行。两者不能同时出现在一个函数里面。两者都不能在static中使用。</li>
<li>不会初始化子类的几种、调用的是父类的static方法或者字段、调用的是父类的final方法或者字段、通过数组来引用。</li>
<li>如果构造方法没有显式地调用同一个类中其他的构造方法或父类的构造方法，将隐性地调用父类的无参数构造方法，即编译器会把 <code>super()</code> 作为构造方法的第一个语句。</li>
<li>静态代码块只执行一次，构造代码块只要创建对象就会执行。</li>
<li>java语言是静态多分派，动态单分派的。 如果是重载方法之间的选择，则是使用静态类型。 如果是父类与子类之间的重写方法的选择，则是使用动态类型。 如A a = new B(); 会使用类型B去查找重写的方法，使用类型A去查找重载的方法。</li>
</ul>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>byte的数值为-128-127，因为-0表示为128</p>
<ul>
<li><p>原码：计算机中将一个数字转换为二进制，并在其最高位加上符号的一种表示方法。</p>
</li>
<li><p>反码：根据表示规定，正数的反码就是本身，而负数的反码，除符号位外，其余位依次取反。</p>
</li>
<li><p>补码：根据表示规定，正数的补码就是本身，而负数的补码，是在其反码的末位加1。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/" data-id="ckupl1rq9000i6rupfaajgj5v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E5%B9%B6%E5%8F%91/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="并发的基本特性"><a href="#并发的基本特性" class="headerlink" title="并发的基本特性"></a>并发的基本特性</h3><ul>
<li>并行指多个cpu同时执行多个任务，并发是指一个cpu按照时间片轮流执行多个任务。</li>
<li>进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。例如qq就是操作系统中的一个进程。切换进程的开销比较大。线程是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个进程内部可能存在多个线程。线程的切换开销要比进程小的多。qq上面能够同时听音乐和看视频就是不同的线程。</li>
<li>并发的三个特点：原子性、可见性、有序性。原子性是指一个线程内的多个操作要么全部执行，要么都不执行。可见性是指当一个线程修改了一个变量的值时，其他线程要立即看到修改的值。有序性指代码在机器中的执行顺序和代码的编写顺序一致。</li>
<li>线程池整体流程：首先设置核心线程数和最大线程数，然后提交任务，任务小于核心线程数时，是慢慢创建线程执行任务的，当执行的任务超过了核心线程数，就将后续的任务放入队列中，当队列满了时，创建非核心线程。当峰值过了后，将非核心线程数超时销毁。如果更多，就直接执行拒绝策略，通知任务提交失败，执行失败后的方法。</li>
<li>饿汉单例模式和双检锁单例模式是线程安全的，懒汉式线程模式是线程非安全的。</li>
</ul>
<h3 id="关于锁"><a href="#关于锁" class="headerlink" title="关于锁"></a>关于锁</h3><ul>
<li>死锁：两个或两个以上的线程在执行过程中，因为争夺对方手中的资源而导致相互等待的现象。比如AB两个线程，A线程拿到1资源，B线程拿到2资源。互相需要对方的21资源，结果两个线程都在等待，造成死锁。</li>
<li>死锁的解决办法。1）让线程步骤一致的获取资源。2）让多个线程尽量不要获取相同的资源。3）如果发现自己需要的资源上锁了，放弃手中的资源，再等待。</li>
<li>synchronized的实现：每一个对象都有一个锁，并且该锁也只有一个内部条件。如果使用synchronized声明方法，该对象的锁就会保护整个方法。静态方法也可以使用synchronized声明，声明后，其他线程无法使用这个类的全部静态方法。普通方法和其他静态方法仍然可以使用。synchronized无论执行完毕或者抛出异常，都会放弃锁。</li>
<li>synchronized和Lock的区别：Lock可以设定超时时间、synchronized无法获得锁的状态，Lock获取锁时会给失败还是成功、synchronized锁的条件比较单一。synchronized使用的是非公平锁，Lock支持非公平锁（默认）和公平锁。</li>
<li>volatile不能保证数据的修改具有原子性。只能保证可见性和有序性。线程1修改一个共享变量时，JVM 会把该线程1对应的本地内存中的共享变量值立即刷新到主内存。当线程2读取时，JMM 会把该线程2对应的本地内存置为无效。线程2接下来将从主内存中读取共享变量。有序性就是代码不会被重新编排。</li>
<li>Happens-Before原则就是为了解决可见性的问题，制定了8个原则，这8个原则梳理出分割线，给程序的运行制定了指导方向。程序顺序规则、锁定规则、volatile变量规则、线程启动规则、线程结束规则、中断规则、终结器规则、传递性规则。</li>
<li>synchronized和volatile的区别：voaltile只能用在变量级别，synchronized可以用在方法和类上。volatile只能保证变量的可见性和有序性，不能保证原子性，synchronized可以保证原子性。volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>悲观锁就是在修改数据的时候默认其他线程也会修改，所以在修改数据时会上锁，修改完毕后将锁释放。乐观锁就是修改数据时默认其他线程不会修改数据，修改完毕后要更新时，如果发现数据被修改了，丢弃自己的操作，如果没有修改，则执行更新。</li>
<li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。但是CAS存在ABA问题，即线程修改为B后又修改回A。可以通过添加版本号的形式来解决这个问题。</li>
<li>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li>
<li>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li>
<li>阻塞队列的流程如下：许多线程向阻塞队列中取出指令并且执行相应命令，如果有生产者插入队列中新的元素但是队列长度已经满了，生产者的插入就会被阻塞。消费者移除一个元素时，阻塞队列如果为空，移除操作也会阻塞。</li>
<li>原子操作意为不可中断的一个操作。在Java中通过锁和循环CAS实现原子操作。原子类有很多，例如AtomicInterge、AtomicArray。</li>
<li>ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。</li>
<li>CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转，翻译成人话就是循环，一般是用一个无限循环实现。这样一来，一个无限循环中，执行一个 CAS 操作，当操作成功，返回 true 时，循环结束；当返回 false 时，接着执行循环，继续尝试 CAS 操作，直到返回 true。</li>
<li>AQS是指抽象队列的同步器。定义了一套多线程访问共享资源的同步框架，</li>
</ul>
<h3 id="关于集合中的线程安全问题"><a href="#关于集合中的线程安全问题" class="headerlink" title="关于集合中的线程安全问题"></a>关于集合中的线程安全问题</h3><ul>
<li><p>HashMap是线程不安全的，它的不安全主要体现在扩容时，因为多个线程的操作，可能会导致环链，即头尾向连，无限循环。具体的实现原理可以看集合那一篇。</p>
</li>
<li><p>ConcurrentHashMap是线程安全的。它是通过分段锁的形式来解决并发读写的问题的。多个线程读写不同的Segment，是没有影响的。AB同时读写同一个Segment，也是没有影响的。AB同时写，会导致AB中间一个阻塞。保证可见性则是使用voliate关键字。ConcurrentHashMap是采用CAS+Synchronized来实现锁的。segment的多少也指ConcurrentHashMap的并发度，一般是16.</p>
</li>
<li><p>String效率较低，StringBuffer和StringBuilder修改频繁时效率较高并且占用内存少，前者线程线程安全，后者多线程状态下可能会出现问题。</p>
</li>
<li><p>SynchronizedMap是通过锁住一整张表来实现线程安全的，效率相对于ConcurrentHashMap很低。</p>
</li>
<li><p>CopyOnWriteArrayList，写数组的拷贝，支持高效率并发且是线程安全的,读操作无锁的ArrayList。所有可变操作都是通过对底层数组进行一次新的复制来实现。CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里。</p>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>实现原理：每个线程都有一个ThreadLocalMap，这个map的key就是弱引用指向的ThreadLocal对象，value就是你要放入值。每个线程都可以获取自己线程独有的map，从而获取对应ThreadLocal对象的值。也就是value。</p>
<p>可能出现的问题：可能出现的问题就是内存溢出。因为Thrad中map存放的key是弱引用，所以在垃圾回收的时候会将这个弱引用回收，导致key为null。无法获取value，时间长了，慢慢就会导致内存溢出。可以在使用完毕后，调用remove方法解决这个问题，同时在ThreadLocal的get方法也会清楚nullkey。</p>
<p>缓存</p>
<p>当ThreadLocal不用时，将其置为空，因为Thread中的map的key是弱引用，所以在下一次垃圾回收时，会直接将这个对象回收，避免造成内存溢出。如果强引用的话，因为key一直指向ThreadLocal，所以一直不会回收。</p>
<p>当key为null时，这个时候无法访问到value，所以可能会造成内存溢出。可以通过remove方法来避免。本身调用get方法到时候也会将null值回收。</p>
<h3 id="HashMap中存在的线程安全问题"><a href="#HashMap中存在的线程安全问题" class="headerlink" title="HashMap中存在的线程安全问题"></a>HashMap中存在的线程安全问题</h3><p>​    安全问题有几点：扩容时出现链表死循环的现象、扩容的时候出现数据丢失的情况、size在多线程操作的时候也会出现不正确的情况、put方法时，hash冲突会出现数据丢失的情况。</p>
<p>​    负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p>
<p>hashmap如何putnull值，会将这个元素放在第0个坐标。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E5%B9%B6%E5%8F%91/" data-id="ckupl1rqa000j6rup2g2t62mv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java核心技术卷" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="卷二"><a href="#卷二" class="headerlink" title="卷二"></a>卷二</h1><h2 id="第1章-Java-SE-8的流库"><a href="#第1章-Java-SE-8的流库" class="headerlink" title="第1章 Java SE 8的流库"></a>第1章 Java SE 8的流库</h2><ul>
<li>流和集合的区别<ul>
<li>流并不存储元素</li>
<li>流的操作不会修改其数据源</li>
<li>流的操作是尽可能惰性执行        </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String wordsString = <span class="keyword">new</span> String(Files.readAllBytes(Paths.get(<span class="string">&quot;/Users/Desktop/dev/aaa.txt&quot;</span>)), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">//以非字母分隔符</span></span><br><span class="line">    List&lt;String&gt; wordsList = Arrays.asList(wordsString.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用迭代的方式查询大于12的单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String word : wordsList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt; <span class="number">12</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">&quot;使用迭代的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用流的方式查询大于12的单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//单线程运行</span></span><br><span class="line">    count = wordsList.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br><span class="line">    System.err.println(<span class="string">&quot;使用单线程的流的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">//多线程运行</span></span><br><span class="line">    count = wordsList.parallelStream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br><span class="line">    System.err.println(<span class="string">&quot;使用多线程的流的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流是使用stream和parallelStream方法来创建的，filter方法用来对流进行转化，count</span></span><br><span class="line"><span class="comment">     * 方法用来终结操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>流的创建方法<br>  JavaAPI中有大量的方法可以产生流，这里不再全部叙述，也不太现实。就直接以一个demo的形式叙述一下我了解的创建流的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> streamtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SetUpStream.java</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetUpStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;/Users/pengshiquan/Desktop/dev/aaa.txt&quot;</span>);</span><br><span class="line">        String wordsString = <span class="keyword">new</span> String(Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">        String[] arrayString = &#123;<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;ddd&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream方法创建流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(wordsString);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream1 = Stream.of(<span class="string">&quot;hahah&quot;</span>, <span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;Stream.of&quot;</span>, stringStream1);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Array.stream(array,from,to)可以创建一个流，从数组中的from到to</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream2 = Arrays.stream(arrayString, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        show(<span class="string">&quot;Arrays.stream&quot;</span>, stringStream2);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream.empty()用来创建一个不包含任何元素的流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream3 = Stream.empty();</span><br><span class="line">        show(<span class="string">&quot;Arrays.stream&quot;</span>, stringStream3);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream两个创建无限流的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//使用lambda表达式重写Supplier&lt;T&gt;函数表达式</span></span><br><span class="line">        Stream&lt;String&gt; stringStream4 = Stream.generate(() -&gt; <span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;Stream.generate&quot;</span>, stringStream4);</span><br><span class="line">        <span class="comment">//lambda表达式中的实例方法引用</span></span><br><span class="line">        Stream&lt;Double&gt; stringStream5 = Stream.generate(Math::random);</span><br><span class="line">        show(<span class="string">&quot;Stream.generate&quot;</span>, stringStream5);</span><br><span class="line">        <span class="comment">// 前面是种子，反复调用函数，应用到之前到结果上    顺序如下： 0，1，2，3，4</span></span><br><span class="line">        Stream&lt;BigInteger&gt; integerStream = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br><span class="line">        show(<span class="string">&quot;Stream.iterate&quot;</span>, integerStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * pattern中的splitAsStream方法将字符串分割为一个一个单词</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream6 = Pattern.compile(<span class="string">&quot;a&quot;</span>).splitAsStream(wordsString);</span><br><span class="line">        show(<span class="string">&quot;splitAsStream&quot;</span>, stringStream6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回一个包含了文件所有行的stream</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; stringStream7 = Files.lines(path, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            show(<span class="string">&quot;Files.lines&quot;</span>, stringStream7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 添加了&lt;T&gt;的展示方法，添加&lt;T&gt;可以使得方法参数类型不受对象范型类限制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/4/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(String title, Stream&lt;T&gt; stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">        List&lt;T&gt; headList = stream.limit(SIZE + <span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">        System.err.print(title + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (T t : headList) &#123;</span><br><span class="line">            System.err.print(t);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对流的操作的方法</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7/" data-id="ckupl1rqc000k6rup5xajfo5k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ul>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口，实现run方法。</li>
<li>使用Callable和Future创建线程。主要就是让线程有返回值，线程也可以抛出异常了。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的第三种方法，使用Callable和Future创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">//创建Callable对象  1</span></span><br><span class="line">      demo3 rt=<span class="keyword">new</span> demo3();</span><br><span class="line">      <span class="comment">//先使用Lambda表达式创建Callable&lt;Integer&gt;对象  1</span></span><br><span class="line">      <span class="comment">//使用Futuretask来包装Callable对象</span></span><br><span class="line">      FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">         <span class="comment">//这里的方法相当于call()方法    1 call()方法可以有返回值  2 call()方法也可以声明抛出异常 </span></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//通过currentThread()来获得当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//返回值</span></span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//主线程</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//实质还是Callable对象创建线程的，执行者还是Thread</span></span><br><span class="line">            <span class="keyword">new</span> Thread(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//也可以获取异常</span></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//获取子线程的返回值get()方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot;子线程的返回值为：&quot;</span>+task.get());</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">         ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现Runnbale接口和Callable接口获取当前线程都需要调用<code>Thread.currentThread()</code>方法。</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。通过Future可以了解任务的执行情况和任务是否完成、也可以取消任务。</li>
</ul>
<h3 id="线程的状态流转图"><a href="#线程的状态流转图" class="headerlink" title="线程的状态流转图"></a>线程的状态流转图</h3><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210510164508318.png" alt="image-20210510164508318"></p>
<p>​    一个线程刚开始创建就是new状态，只是简单的赋值，没有什么其它操作。调用线程的start方法后，线程进入运行态，如果此时的线程没有什么其它要求，就只是简单打印一句话，线程执行完毕后就进入了终止态。但是如果有特殊情况，它在语句中调用了object.wait()，这时它会进入等待状态，同时也进入了等待队列，就是waiting，另外一个线程如何调用了这个对象的notify()方法，最开始进入等待状态的线程会重新获取锁，进入运行态。如何这个时候等待锁的线程比较多，没有获取到的就进入阻塞状态，也就进入到了同步队列，一直等待获取到锁，然后进入运行态。还有一个状态就是超时等待状态，以线程的sleep方法为例，线程运行中执行这个方法，睡眠10秒，然后线程就进入了这个状态，10秒过完后，就再次回到运行态。但是这里不会放弃锁，会一直保持。</p>
<ul>
<li>所有的状态都是先进入就绪态，再进入运行中。</li>
<li>sleep方法不会放弃锁。</li>
<li>线程不能抛出任何异常，遇到异常，应该设置异常处理器。将异常的信息打印到日志中或者后续处理。</li>
<li>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。线程状态为可运行态。</li>
<li>Thread.join方法会让当前线程进入到等待状态，执行t，完毕后再执行当前线程。本质仍然是执行了 wait() 方法，而锁对象就是 Thread t 对象本身。</li>
<li>park和unpark实现的原理则是使用线程内部的计数器。</li>
<li>用 jdk 的 Lock 接口中的 lock，如果获取不到锁，线程将挂起，状态则变为等待状态。</li>
<li>jdk 中锁的实现，是基于 AQS 的，而 AQS 的底层，是用 park 和 unpark 来挂起和唤醒线程。</li>
</ul>
<h3 id="线程池相关知识点"><a href="#线程池相关知识点" class="headerlink" title="线程池相关知识点"></a>线程池相关知识点</h3><p>​    创建一个线程池，现在里面没有任何运行的线程。提交一个任务，如果小于核心线程数，会一直创建新的核心线程。直到核心线程数满了，线程池还有一个任务队列，核心数满了后，会将提交的任务放到任务队列里面。当任务队列也满了后，会创建非核心线程数，当非核心线程数也满了后，就会走拒绝策略，将后面提交的任务全部拒绝。当非核心线程慢慢没有任务后，过一段时间就会对非核心线程进行销毁。核心线程则会一直运行中。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210607200224525.png" alt="image-20210607200224525"></p>
<ul>
<li>但是，敦促程序员使用更方便的Executors工厂方法Executors.newCachedThreadPool （无边界线程池，具有自动线程回收）， Executors.newFixedThreadPool （固定大小的线程池）和Executors.newSingleThreadExecutor （单个后台线程），这些方法可以预先配置设置。</li>
<li>当在方法execute(Runnable)提交新任务，并且正在运行的线程少于corePoolSize线程时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理请求。 如果运行的线程数大于corePoolSize但小于maximumPoolSize，则仅在队列已满时才创建新线程。 通过将corePoolSize和maximumPoolSize设置为相同，可以创建固定大小的线程池。 通过将maximumPoolSize设置为一个本质上不受限制的值（例如Integer.MAX_VALUE ，可以允许池容纳任意数量的并发任务。 最典型地，核心和最大池大小仅在构造时设置，但也可以使用setCorePoolSize和setMaximumPoolSize动态更改。</li>
<li>使用ThreadFactory创建新线程。 如果没有另外指定，则使用Executors.defaultThreadFactory ，该线程创建的线程全部位于相同的ThreadGroup并且具有相同的NORM_PRIORITY优先级和非守护程序状态。 通过提供其他ThreadFactory，可以更改线程的名称，线程组，优先级，守护程序状态等。如果ThreadFactory在从newThread返回null返回要求时未能创建线程，执行器将继续执行，但可能无法执行执行任何任务。 线程应具有“ modifyThread” RuntimePermission 。 如果使用该池的工作线程或其他线程不具有此许可权，则服务可能会降级：配置更改可能不会及时生效，并且关闭池可能保持在可能终止但未完成的状态。</li>
<li>如果当前池中的线程数超过corePoolSize，则多余的线程将在空闲时间超过keepAliveTime时终止（请参见getKeepAliveTime(TimeUnit) ）。 当不积极使用池时，这提供了一种减少资源消耗的方法。 如果池稍后变得更活跃，则将构建新线程。 也可以使用setKeepAliveTime(long, TimeUnit)方法动态更改此参数。 使用Long.MAX_VALUE TimeUnit.NANOSECONDS的值Long.MAX_VALUE有效地使空闲线程永远不会在关闭之前终止。 默认情况下，仅当corePoolSize线程数多时，保持活动策略才适用。 但是，只要keepAliveTime值不为零，方法allowCoreThreadTimeOut(boolean)还可用于将此超时策略应用于核心线程。</li>
<li>有三种一般的排队策略：<ul>
<li>直接交接。 工作队列的一个很好的默认选择是SynchronousQueue ，它可以将任务移交给线程，而不必另外保留它们。 在这里，如果没有立即可用的线程来运行任务，则尝试将任务排队的尝试将失败，因此将构造一个新线程。 在处理可能具有内部依赖项的请求集时，此策略避免了锁定。 直接切换通常需要无限制的maximumPoolSizes以避免拒绝新提交的任务。 反过来，当平均而言，命令继续以比其可处理的速度更快到达时，这可能会带来无限线程增长的可能性。</li>
<li>无限队列。 使用无界队列（例如，没有预定义容量的LinkedBlockingQueue ）将在所有corePoolSize线程繁忙时使新任务在队列中等待。 因此，将仅创建corePoolSize线程。 （因此，maximumPoolSize的值没有任何作用。）当每个任务完全独立于其他任务时，这可能是适当的，因此任务不会影响彼此的执行。 例如，在网页服务器中。 尽管这种排队方式对于消除短暂的请求突发很有用，但它承认当命令平均继续以比处理速度更快的速度到达时，无限制的工作队列增长是可能的。</li>
<li>有界队列。 当与有限的maximumPoolSizes一起使用时，有界队列（例如ArrayBlockingQueue ）有助于防止资源耗尽，但调优和控制起来会更加困难。 队列大小和最大池大小可能会相互折衷：使用大队列和小池可以最大程度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为地降低吞吐量。 如果任务频繁阻塞（例如，如果它们受I / O约束），则系统可能能够安排比您原先允许的线程更多的时间。 使用小队列通常需要更大的池大小，这会使CPU繁忙，但可能会遇到无法接受的调度开销，这也会降低吞吐量</li>
</ul>
</li>
<li> 在任一情况下， execute方法调用RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)其的方法RejectedExecutionHandler 。 提供了四个预定义的处理程序策略：</li>
<li>在默认的ThreadPoolExecutor.AbortPolicy ，处理程序在拒绝时会抛出运行时RejectedExecutionException 。</li>
<li>在ThreadPoolExecutor.CallerRunsPolicy ，调用execute自己的线程运行任务。 这提供了一种简单的反馈控制机制，该机制将减慢新任务的提交速度。</li>
<li>在ThreadPoolExecutor.DiscardPolicy ，简单地删除了无法执行的任务。</li>
<li>在ThreadPoolExecutor.DiscardOldestPolicy ，如果未关闭执行程序，则将丢弃工作队列开头的任务，然后重试执行（该操作可能再次失败，导致重复执行此操作）。</li>
</ul>
<h4 id="参数讲解"><a href="#参数讲解" class="headerlink" title="参数讲解"></a>参数讲解</h4><ul>
<li><p>corePoolSize – 要保留在池中的线程数，即使它们处于空闲状态，除非设置了allowCoreThreadTimeOut</p>
</li>
<li><p>maximumPoolSize – 池中允许的最大线程数</p>
</li>
<li><p>keepAliveTime – 当线程数大于核心数时，这是多余空闲线程在终止前等待新任务的最长时间。</p>
</li>
<li><p>unit – keepAliveTime参数的时间单位</p>
</li>
<li><p>workQueue – 用于在执行任务之前保存任务的队列。 这个队列将只保存execute方法提交的Runnable任务。</p>
</li>
<li><p>threadFactory – 执行程序创建新线程时使用的工厂</p>
</li>
<li><p>handler – 执行被阻塞时使用的处理程序，因为达到了线程边界和队列容量。</p>
</li>
<li><p>线程池的状态：</p>
<ul>
<li>RUNNING：接受新任务并处理排队的任务</li>
<li>SHUTDOWN：不接受新任务，但处理排队的任务</li>
<li>STOP：不接受新任务，不处理排队的任务，并中断进行中的任务</li>
<li>TIDYING：所有任务都已终止，workerCount为零，线程转换到TIDYING状态将运行Terminated（）挂钩方法。</li>
<li>TERMINATED：terminald（）已完成。</li>
</ul>
</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>execute(Runnable command)：在未来的某个时间执行给定的任务。</li>
<li>shutdown()：启动有序关闭，其中执行先前提交的任务，但不会接受新任务。 如果已经关闭，调用没有额外的效果。</li>
<li>shutdownNow() ：尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表。 </li>
<li>submit():提交一个返回值的任务以供执行，并返回一个表示任务未决结果的 Future.</li>
</ul>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadPoolTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 线程池练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executorService = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            TestTask testTask = <span class="keyword">new</span> TestTask(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            executorService.execute(testTask);</span><br><span class="line">            System.err.println(<span class="string">&quot;当前线程池核心线程数：&quot;</span> + executorService.getPoolSize());</span><br><span class="line">            System.err.println(<span class="string">&quot;队列中等待的任务数为：&quot;</span> + executorService.getQueue().size());</span><br><span class="line">            <span class="comment">//返回已完成执行的大致任务总数。</span></span><br><span class="line">            System.err.println(<span class="string">&quot;当前线程池完成的任务数为：&quot;</span> + executorService.getCompletedTaskCount());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;当前正在执行线程：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;线程：&quot;</span> + name + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试的问题"><a href="#面试的问题" class="headerlink" title="面试的问题"></a>面试的问题</h3><ul>
<li>等待状态和阻塞状态的区别</li>
</ul>
<p>​    线程的等待状态是主动的，自己调用wait方法将线程切换为等待状态，并且这个时候也会占用cpu，阻塞状态是被动的，获取不到锁就变成阻塞状态，这个时候会放弃cpu的执行权，等待某个时间将其唤醒。</p>
<ul>
<li>重复调用start方法会怎么样？</li>
</ul>
<p>​    会抛出异常，就在start方法的第一行，判断状态如果不是new的话，会直接抛出一个异常。</p>
<ul>
<li>线程池的创建方式有几种</li>
</ul>
<p>​    创建线程池第一种就是自定义创建，指定参数，创建线程池。还有一种就是通过Executors工具类创建指定好的线程池。一般三种类型的，线程数没有限制的、线程数固定大小的、线程数为一个的。看自己业务的需求，但是阿里的编码规范里面说不要使用工具类创建，是为了防止内存溢出。不知道我们公司线程池的使用是那种方式？</p>
<ul>
<li>线程池的拒绝策略有哪些？</li>
</ul>
<p>​    我了解的拒绝策略有一下啊几种：1.队列满了后直接抛出异常。2.无法执行的任务丢弃掉。3.使用调用者线程执行任务，这样能够减慢任务的提交速度。4.将队列头部的任务丢弃掉。</p>
<ul>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B/" data-id="ckupl1rqc000l6rup5gxk2t4c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java线程深入学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java线程深入学习"><a href="#Java线程深入学习" class="headerlink" title="Java线程深入学习"></a>Java线程深入学习</h2><p>​    上一篇博客讲了一下并发，但是没有达到自己的效果，所以这篇博客想从上一篇博客中的线程讲起，打算写一篇有着自己风格和能够让自己满意的博客。也是想深入了解一下线程的工作原理。</p>
<p>​    线程是程序中的执行线程。 Java虚拟机允许应用程序具有多个并发运行的执行线程。Java创建线程有两种方式（Java文档中这样说的，网上说应该还有一种,总共三种）一种是继承<code>Thread</code>类，一种是实现<code>Runnable</code>接口。下面先就第一种创建方法来说一下线程具体的流程。现在上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一种创建线程的方法，通过继承Thread类创建线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;<span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//run方法就是线程执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当线程类继承Thread类时，直接使用this可以获得当前线程</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//获取当前线程的名字</span></span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 运行的时候发现main的i不一定会到20，线程的启动是计算机调度的，具有一定的随机性</span></span><br><span class="line"><span class="comment">             * 两个子线程的i不是共享的，不会连续打印</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//currentThread()总是返回当前正在执行的线程对象</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">//通过start()方法启动第一个线程</span></span><br><span class="line">                <span class="keyword">new</span> demo1().start();</span><br><span class="line">                <span class="comment">//启动第二个线程</span></span><br><span class="line">                <span class="keyword">new</span> demo1().start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    最后运行的截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210112173640626.png" alt="image-20210112173640626">    </p>
<p>​    基础的知识就不再详细介绍了，继承<code>Thread</code>类，重写<code>run()</code>方法，通过调用该类对象的<code>start()</code>方法（不是<code>run(</code>)方法）来启动线程。剩下就没有什么需要讲解的了，但是这篇博客是深入了解线程，所以会继续深挖一下，了解背后的原理。下面就开始阅读线程类的源码。</p>
<p>​    上面的过程涉及了几个地方，一个是创建一个对象，一个就是调用了<code>start()</code>方法。下面就一步一步来，先是new了一个对象，看到源码中是调用了初始化方法，只是初始化了线程的相关设置，和我们的关系好像不大。（其中涉及的感觉都是JVM相关的东西）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210112175323837.png" alt="image-20210112175323837"></p>
<p>​    下面就是<code>start()</code>方法了，先看该方法的介绍，显示该方法会使线程开始执行，Java虚拟机将会调用此线程的run方法，结果是产生两个线程（调用start方法的线程和执行run方法的线程），线程一旦完成就可能不会重启。再来看代码，发现代码不是很复杂：将该线程放入线程组，再调用<code>start0()</code>方法，然后到这里就断了，这里就调用了底层C的代码，再看下去就不是很容易懂了。好像到这里就暂时断了。</p>
<p>​    回过头来，就不难发现为什么线程的名称是<code>Thread-0</code>,因为初始化时没有传参所以系统给默认的了。同时也能解释代码中注释的疑问：运行次数多不难发现，不一定运行到20就开始打印子线程？和主线程的打印和子线程是随机不确定间隔打印的。（因为线程的启动时随机的，主线程和子线程是两个独立的线程）</p>
<p>​    下面就来看看创建线程的第二种方式。实现<code>Runnable</code>接口，直接上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建线程的第二种方法</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i;<span class="comment">//初始值为0</span></span><br><span class="line">   <span class="comment">//线程执行体</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//当实现Runnable接口时，只能使用Thread.currentThread().getName()获得当前线程</span></span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            demo2 dt=<span class="keyword">new</span> demo2();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 最终的执行者还是Thread</span></span><br><span class="line"><span class="comment">             * 发现新线程1和新线程2的i值是连续的，因为Thread共享了同一个target(就是Runnable对象)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//通过new Thread(target,name)来创建新线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(dt,<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dt,<span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码也是比较简单，但是创建线程这里不太一样，通过创建实现了Runnable接口的对象，但是实际还是调用Thread线程类的<code>start()</code>方法。看源码发现虽然调用的是不同的构造函数，但是最后调用的都是同一个初始化函数，而且传入的Runnable好像也没有用到，只是赋值了一下，就不再处理，那使用接口和不使用接口有什么区别呢？继续阅读源码。</p>
<p>​    如果实现接口，代码中并没有重写Thread类的<code>run()</code>方法，只是重写了Runnable的<code>run()</code>方法，回到Thread类的run方法，发现有这样的代码。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210113174447700.png" alt="image-20210113174447700"></p>
<p>​    这样就明白了，Thread是先调用Runnable的run方法，也就是说线程的创建还是在Thread中，Runnable只是将自己作为接口放到了Thread的上面。回到最上面也可以看到Thread是实现了Runnable接口的。Runnable接口也比较简单，就只有一个run方法。</p>
<p>​    回到刚才的问题，使用接口和继承Thread有什么区别，其实就是代码为什么这样设计的问题。看了一下Runnable的文档，如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210113175122171.png" alt="image-20210113175122171"></p>
<p>​        说白了，就是更加的灵活，Thread有一千行代码，其中很多代码可能是大家用不到的，这样也体现了一种思想，去除无用（自己想的）。让代码中尽量少一些无用代码。</p>
<p>​    代码其实比较简单，但是其中的一些设计思想需要消化一下。能力有限，只能考虑到这些，欢迎大家补充。</p>
<p>​    最后来看一下网上说的第三种创建线程的方式，使用Callable和Future创建线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的第三种方法，使用Callable和Future创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">//创建Callable对象  1</span></span><br><span class="line">      demo3 rt=<span class="keyword">new</span> demo3();</span><br><span class="line">      <span class="comment">//先使用Lambda表达式创建Callable&lt;Integer&gt;对象  1</span></span><br><span class="line">      <span class="comment">//使用Futuretask来包装Callable对象</span></span><br><span class="line">      FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">         <span class="comment">//这里的方法相当于call()方法    1 call()方法可以有返回值  2 call()方法也可以声明抛出异常 </span></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//通过currentThread()来获得当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//返回值</span></span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//主线程</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//实质还是Callable对象创建线程的，执行者还是Thread</span></span><br><span class="line">            <span class="keyword">new</span> Thread(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//也可以获取异常</span></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//获取子线程的返回值get()方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot;子线程的返回值为：&quot;</span>+task.get());</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">         ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    按照上面的方式继续阅读这段代码，不难发现<code>FutureTask&lt;V&gt;</code>其实是实现了Runnable的子类，这样的话和第二种方法就没有什么区别，这里也不再继续跟进。所以最开始文档中说的对，实现线程的方式只有两种。</p>
<p>​    这篇博客写到这里算是一个完结，因为目前能力有限，可能一些理解不太合适。也想了一下这种情况，个人来说很难学习一个知识点就直接学习到深处，很多东西都是循序渐进的，这样也就能解释之前的博客水平不咋地。一个高度就会有一个理解，不同高度的博客很难相比较。所以后续肯定也会回头看这篇博客。</p>
<p>​    博客是分两天写完的，中间间断了一下，但是最后的结果感觉还不是很满意，中间的语句和语序都有一些问题，也留一个结论。博客最好一天写完，可以后续完善，但是一定要一天定下文章的结构和大体框架。算是写作的一个小提示吧。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" data-id="ckupl1rqd000m6rupg1v2fapx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM基础概念"><a href="#JVM基础概念" class="headerlink" title="JVM基础概念"></a>JVM基础概念</h2><p>​    Java源文件通过编译器产生class文件，字节码文件再通过Java虚拟机中的解释器，编译成特定机器上的机器码。这也是Java跨平台的原因。</p>
<h3 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h3><p>​    Java内存模型分为两大类，线程私有和共享数据。线程私有：程序计数器、虚拟机栈、本地方法栈。共享数据有：常量池（方法区的一部分）、方法区、Java堆。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_21E692D0E9A8-1.jpeg" alt="IMG_21E692D0E9A8-1"></p>
<ul>
<li>程序计数器：当前线程执行的字节码行号指示器。</li>
<li>虚拟机栈：Java方法执行的内存模型，生命周期和线程一致。栈帧是进行方法执行的数据结构。虚拟机栈主要有两种异常：堆栈异常和内存超出异常。</li>
<li>本地方法栈：虚拟机使用到的native方法的内存空间。抛出的异常也是堆栈异常和内存超出异常。</li>
<li>堆：主要存放着对象的实例和数组的数据。抛出的异常为内存溢出异常。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A22B848C2C43-1.jpeg" alt="IMG_A22B848C2C43-1"></p>
<ul>
<li>方法区：主要存放虚拟机加载的类信息、常量、静态变量、编译后的代码。主要抛出内存溢出异常。</li>
<li>运行时常量池：属于方法区的一部分，主要存放编译器生成的各种字面量和符号的引用。不会抛出内存溢出异常。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>标记清除算法：将存活的对象标记，然后将为标记的对象的内存空间进行回收。</li>
<li>复制算法：将内存空间分为两块，一块用满后，将存活对象复制到另外一块，然后直接将之前的内存空间清理掉。</li>
<li>标记整理算法：将存活对象进行标记，然后将存活的对象都移动到一端，再将边界后面的内存空间清理。</li>
<li>分代收集算法：将内存分为两个区域：新年代和老年代。比例为1:2.新年代又分为Eden、From、To三个区域，比例为：8:1:1.每次进行回收时，将Eden和From存活对象复制到To中，然后将Eden和From清理。老年代因为对象存活时间久，执行的是标记整理算法。<ul>
<li>当标记对象达到15次时，就会移动到老年代。</li>
<li>当To的空间不足时，会将对象移动到老年代。</li>
<li>当老年代也满了或者空间不够了，会触发新年代和老年代的GC，两者分别为：MinorGC和FullGC。</li>
</ul>
</li>
</ul>
<h3 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h3><ul>
<li>引用计数法：有地方引用这个对象，计数器久加一，引用失效久减一。但是不能解决相互引用的问题。</li>
<li>可达性分析算法：以根作为起始点，沿着节点向下搜索，如果一个对象没有可以搜索到的路径，认为该对象不可达，即该对象不可用，可以回收。</li>
</ul>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p>​    通过new关键字创建的引用就是强引用，强引用就算内存不足，gc也不会删除它。软引用可以和ReferenceQueue一块使用，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。弱引用通过WeakReference类实现，弱引用的生命周期比软引用短，无论当前内存空间是否足够，弱引用都会被删除。虚引用也叫幻象引用，通过PhantomReference类来实现。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<h3 id="垃圾收集器的种类"><a href="#垃圾收集器的种类" class="headerlink" title="垃圾收集器的种类"></a>垃圾收集器的种类</h3><ul>
<li>Serial垃圾收集器：单线程、复制算法。进行垃圾回收的同时，必须暂停其他所有工作线程。</li>
<li>ParNew垃圾收集器：Serial收集器的多线程版本。也是需要暂停其他线程，在垃圾回收过程中。</li>
<li>Paraller Scavenge垃圾收集器：多线程复制算法、高效。</li>
<li>Serial Old垃圾收集器：单线程标记整理算法。主要回收老年代。</li>
<li>Paraller Old垃圾收集器：多线程标记整理算法。</li>
<li>CMS收集器：多线程标记清楚算法。有四个阶段：1）初始标记。2）并发标记。3）重新标记。4）并发清楚。</li>
<li>G1垃圾收集器：基于标记整理算法，不产生内存碎片。可以精确控制停顿时间，在不牺牲吞吐量的情况下实现低停顿垃圾回收。</li>
</ul>
<h3 id="JVM调优的工具"><a href="#JVM调优的工具" class="headerlink" title="JVM调优的工具"></a>JVM调优的工具</h3><ul>
<li>jconsole：对jvm中的内存、线程和类进行监控</li>
<li>jvisualvm：可以分析内存快照、线程快照、程序死锁、监控内存变化、gc等</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>​    类加载机制分为五个部分：加载-验证-准备-解析-初始化。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_B2026A3771A2-1.jpeg" alt="IMG_B2026A3771A2-1"></p>
<ul>
<li><p>加载：生成该类的Class对象。</p>
</li>
<li><p>验证：主要是确保Class文件是否符合要求。</p>
</li>
<li><p>准备：为类变量分配内存空间。</p>
</li>
<li><p>解析：虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
</li>
<li><p>初始化：执行类中定义的Java代码。</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>​    对于任意一个类，需要加载它的类加载器和这个类本身一同确立这个类在JVM中的唯一性，每一个类加载器都有一个独立的类名称空间。类加载器就是通过完全限定名将class文件加载到jvm中，再转换为class对象。</p>
<p>  类加载器有三种：启动类加载器、扩展类加载器、应用类加载器。</p>
<ul>
<li>双亲委派模型：类加载器接收到类加载任务时，会交给父类加载器完成，这样，所有的加载请求都会传递到启动类加载器，只有当父类无法完成加载请求，子加载器才会去尝试加载类。好处就是无论哪个类加载器进行加载，最后得到的都是jvm中唯一的class对象。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>对于两个类的情况，即一个父类和一个子类，执行顺序如下。执行父类的静态初始化块。执行子类的静态初始化块。执行父类的非静态初始化块。执行父类的构造器。执行子类的非静态初始化块。执行子类的构造器。</li>
<li>编译是javac test.java。运行是java test。</li>
<li>静态域,main(),构造代码块,构造方法。</li>
<li>Java通过垃圾回收回收不再引用的变量，垃圾回收时对象的finallize（）不一定会得到执行。</li>
<li>判断对象是否可以回收有两个算法，引用计数算法和根搜索算法。垃圾回收算法则有四种，标记清楚算法、复制算法、标记整理算法、分代收集算法Minor GC 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会频繁执行，一般回收速度也比较快。Full GC 也称 Major GC，指发生在老年代的垃圾回收操作。出现了 Full GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。优先在新生代区存放对象，大对象直接放在老年代区，新生代区的对象经历15次GC后就会进入老年代区。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-id="ckupl1rqd000n6rup0iyx4244" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java输入与输出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="输入输出基础知识"><a href="#输入输出基础知识" class="headerlink" title="输入输出基础知识"></a>输入输出基础知识</h2><p>​    字符编码（英语：Character encoding）也称字集码，是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。常见的例子包括将拉丁字母表编码成摩斯电码和ASCII。其中，ASCII将字母、数字和其它符号编号，并用7比特的二进制来表示这个整数。通常会额外使用一个扩充的比特，以便于以1个字节的方式存储。</p>
<p>​    字符编码就是将字符和一串二进制编码对应起来，例如ASCII编码就是将各种字符和实际的数字（转换的二进制编码）对应起来。</p>
<p>​    常用的字符编码有ASCII、GBK、Unicode等。</p>
<p>​    GBK 采用双字节表示，总体编码范围为 8140-FEFE，首字节在 81-FE 之间，尾字节在 40-FE 之间，剔除 xx7F 一条线。总计 23940 个码位，共收入 21886 个汉字和图形符号，其中汉字（包括部首和构件）21003 个，图形符号 883 个。</p>
<p>​    我们日常接触到的文件分ASCII和Binary两种。ASCII是“美国信息交换标准编码”的英文字头缩写，可称之为“美标”。美标规定了用从0到127的128个数字来代表信息的规范编码，其中包括33个控制码，一个空格码，和94个形象码。形象码中包括了英文大小写字母，阿拉伯数字，标点符号等。</p>
<p>​    Unicode其实就是宽字节字符集，它对每个字符都固定使用两个字节即16位表示，于是当处理字符时，不必担心只处理半个字符。UTF-8是Unicode编码的一种实现，因为Unicode对于一个字符的表示比较长，所以UTF-8采用了动态长度的方法进行编码。UTF-8是兼容ASCII，第一个字节与ASCII相容，理论上可以达到四个字节。</p>
<p>​    读入一个字节序列的对象叫做输入流，写出一个字节序列对象叫做输出流。实际传输的都是01，但是Java分为字节流和字符流。</p>
<p>处理字节的Stream类结构。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_894224ED70D2-1.jpeg" alt="IMG_894224ED70D2-1"></p>
<p>处理字符的Reader和Writer：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_C3D453ADB75A-1.jpeg" alt="IMG_C3D453ADB75A-1"></p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>​    对象序列化就是将Java中的对象转换为固定格式的字节。想要实现序列化必须实现Serializable接口。</p>
<p>​    序列化的机制：每个对象都用一个序列号保存，即每个对象都关联一个序列号。当序列化时，遇到这个对象第一次时正常序列化，保存其对象。当第二次遇到时，只需要写出之前对象关联的序列号即可。读会对象则是相反，遇到一个序列号时，构建这个对象，并使用流中的数据初始化它。当遇到和这个序列号相同的对象时，获取这个对象引用即可。</p>
<p>​    使用transient关键字可以将某些域声明为不可序列化。</p>
<p>​    Java中存在三种复制，第一种直接赋值，第二种浅拷贝，第三种深拷贝。</p>
<p>​    直接赋值如：A a = a2;当a2变化时，a也会变化。</p>
<p>​    浅拷贝：clone方法，当对象里面还有引用对象时，只是复制引用不复制引用对象。所以当对对象里面的引用对象进行修改时，两者都会变化。</p>
<p>​    深拷贝：无论值还是对象里面的引用对象都进行了拷贝。复制后的对象的修改不影响双方。可以使用序列化来实现。</p>
<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>​    这一部分没啥可讲的，就正常操作文件就行，使用File类，注意操作文件时使用的字符串和当时的机器环境即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" data-id="ckupl1rqe000o6rup0l4p25mk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/Java集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合的框架图"><a href="#集合的框架图" class="headerlink" title="集合的框架图"></a>集合的框架图</h3><p>集合框架中继承关系：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_0ABE1119FACC-1.jpeg" alt="IMG_0ABE1119FACC-1"></p>
<p>常用的各个集合的作用和特点：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_62E779E2DD25-1.jpeg" alt="IMG_62E779E2DD25-1"></p>
<h3 id="LIst相关知识点"><a href="#LIst相关知识点" class="headerlink" title="LIst相关知识点"></a>LIst相关知识点</h3><ul>
<li>List是有序的Collection（指的是插入顺序）</li>
<li>ArrayList是常用的List，通过数组实现。允许对元素快速访问。扩容是当前容量*1.5+1,当元素满的时候扩容。线程不安全。</li>
<li>Vector也是通过数组实现的，但是它支持多线程访问。速度比ArrayList慢。初始化为10，同步的实现原理是synchronized.</li>
<li>LinkedList通过双向循环链表数据结构，插入和删除比较方便，随机访问比较慢。</li>
</ul>
<h3 id="Set相关知识点"><a href="#Set相关知识点" class="headerlink" title="Set相关知识点"></a>Set相关知识点</h3><ul>
<li>Set主要存放的无序的元素（指的是插入的顺序），值不能重复，只允许插入一个空元素。</li>
<li>HashSet是按照Hash值来存取元素的，只能通过迭代器访问元素。</li>
<li>TreeSet是使用二叉树的原理对元素进行顺序排序。</li>
<li>LinkedHashSet继承HashSet又基于LinkedHashMap实现。</li>
</ul>
<h3 id="Map相关知识点"><a href="#Map相关知识点" class="headerlink" title="Map相关知识点"></a>Map相关知识点</h3><ul>
<li>HashMap就是键值映射，能够存储null值和一个null的key，线程不安全。其他可以看看博客。线程安全问题存在扩容情况，就是多个线程扩容时，会造成环链的情况，导致无限循环。</li>
<li>Hashtable 是一个哈希表，该类继承自Dictionary类，实现了 Map 接口。HashMap是基于哈希表实现的，该类继承AbstractMap，实现Map接口。Hashtable 线程安全的，而 HashMap 是线程不安全的。HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li>
<li>ConcurrentHashMap支持并发操作，采用的是分段锁的形式。Segment代表一个段，一个Segment又代表了一个小型的HashMap，默认并发度为16即16个Segment。</li>
<li>TreeMap是排序map，能够将存储的元素进行排序，默认是升序，需要插入的元素实现Comparable接口。</li>
<li>LinkHashMap继承HashMap，保存了插入的顺序。</li>
<li>重写equals时一定要重写hashcode，因为不重写会导致，map中判断相同的对象无法达到覆盖的目的。equals判断为true，hashcode可能为false。</li>
<li>WeakHashMap使用的是弱引用保存键。</li>
</ul>
<h3 id="迭代器相关知识点"><a href="#迭代器相关知识点" class="headerlink" title="迭代器相关知识点"></a>迭代器相关知识点</h3><ul>
<li>使用迭代器的原因就是可以在迭代过程中删除元素。还有就是解耦合，将遍历Collection和具体的实现抽离出来。</li>
<li>具体使用代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; abc = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">            add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Iterator&lt;String&gt; it  = abc.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.err.println(it.next());</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ListIteratort只能遍历List，Iterator不仅可以遍历List也可以遍历Set。Iterator只能单向遍历，ListIterator可以双向遍历。ListIterator也添加了其他的功能，添加一个元素、替换一个元素、获取前面的元素或者后面的元素。</li>
</ul>
<h3 id="集合的其他知识点"><a href="#集合的其他知识点" class="headerlink" title="集合的其他知识点"></a>集合的其他知识点</h3><ul>
<li>foreach循环内部实现是使用迭代器的，但是最好不要在里面执行元素的删除</li>
<li>迭代器的remove方法会删除指针的前一个元素。调用这个方法时一定要调用next方法控制指针</li>
<li>可以通过instanceof RandomAccess接口来判断当前集合是否支持高效的随机访问。</li>
<li>链表添加元素一般都是在末尾，使用迭代器可以在特定位置添加元素。（ListIterator）</li>
<li>优先级队列可以按任意顺序插入，但是最后删除时是排序的，会获取最小的元素。</li>
<li>映射视图和MySQL中的视图类似，将键、值、键值组成不同的视图。如果在视图上调用remove方法，会删除，但是不能增加元素。</li>
<li>Hashtable和HashMap作用一样，不过前者是同步的，后者是不同步的。</li>
<li>java中的sub一般都是第一个包含在内，第二个参数不包含在内。</li>
<li>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。</li>
<li>队列先进先出，栈先进后出</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/" data-id="ckupl1rqf000p6rup6muqb46c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qq1162210866.github.io/博客/Java基础/枚举类练习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%BB%83%E4%B9%A0/" class="article-date">
  <time datetime="2021-10-13T13:28:21.187Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="枚举类了解及练习"><a href="#枚举类了解及练习" class="headerlink" title="枚举类了解及练习"></a>枚举类了解及练习</h2><p>​    工作中遇到一个类，发现使用到了枚举，这次也顺带着了解一下。很多东西虽然自己知道但是没有再工作中遇到，也没有去想什么地方能遇到。后面也会对这类知识点在工作中的使用专门写一些博客。</p>
<p>​    枚举类型比较特殊，算是Java中一个比较特殊的类。下面就列一个简单的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> enumtrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClothesSize.java</span></span><br><span class="line"><span class="comment"> * Description: 衣服大小枚举类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ClothesSize</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类,利用构造方法传参。这里的四个码号其实相当于四个实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    S(<span class="string">&quot;S号&quot;</span>), L(<span class="string">&quot;L号&quot;</span>), XL(<span class="string">&quot;XL号&quot;</span>), XXL(<span class="string">&quot;XXL号&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 构造方法，将枚举项的值赋值给枚举类的普通属性，再通过公共方法获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-07-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ClothesSize(String size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面就是一个简单的枚举类的例子。可以看到其实枚举相当于Java中的常量，类似下面代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ABA = <span class="string">&quot;气温&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​    但是枚举类要丰富的很多，里面可以写一些方法和变量，相对于上面的常量的定义要灵活的多。下面也给个例子如何使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> train;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> enumtrain.ClothesSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClothesSizeTest.java</span></span><br><span class="line"><span class="comment"> * Description:  枚举类测试方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClothesSizeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印枚举值的值和name</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClothesSize clothesSize = ClothesSize.XL;</span><br><span class="line">        System.err.println(<span class="string">&quot;根据构造方法获取枚举类型的值：&quot;</span> + clothesSize.getSize());</span><br><span class="line">        System.err.println(<span class="string">&quot;直接获取枚举类型的name&quot;</span> + clothesSize.toString());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取全部的枚举值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClothesSize[] clothesSizes = ClothesSize.values();</span><br><span class="line">        <span class="keyword">for</span> (ClothesSize clothesSize1 : clothesSizes) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;枚举值name为：&quot;</span> + clothesSize1.toString() + <span class="string">&quot;，枚举值value为：&quot;</span> + clothesSize1.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据键盘的输入取对应的枚举值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String input = scanner.next().toUpperCase();</span><br><span class="line">        ClothesSize clothesSize1 = Enum.valueOf(ClothesSize.class, input);</span><br><span class="line">        System.err.println(<span class="string">&quot;输入的枚举值name为：&quot;</span> + clothesSize1.toString() + <span class="string">&quot;，输入的枚举值value为：&quot;</span> + clothesSize1.getSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行的截图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200630233928092.png" alt="image-20200630233928092"></p>
<p>说到底，还是简单的使用。一旦到了工作中还是会忘记，因为还是没有在工作中使用，所以忘记的比较快。下面也给出一个代码，希望自己不要忘记。后面也会列举出工作中的使用。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200630234426659.png" alt="image-20200630234426659"></p>
<p>​    有大佬知道这段代码的作用也可以给菜鸟说一下。</p>
<p>​    就这样吧，结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/Java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%BB%83%E4%B9%A0/" data-id="ckupl1rqf000q6rup4eug19tt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E6%8D%AE%E4%BD%8D%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E8%AE%B0%E5%BD%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/13/qq1162210866.github.io/%E5%8D%9A%E5%AE%A2/%E6%9D%82%E9%A1%B9/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>