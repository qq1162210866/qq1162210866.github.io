<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/C%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0C/</url>
    <content><![CDATA[<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ul>
<li>c中存在大小端端问题，需要将数据掉头</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>C学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Docker%E5%AD%A6%E4%B9%A0/Docker-compose%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Docker-compose学习"><a href="#Docker-compose学习" class="headerlink" title="Docker-compose学习"></a>Docker-compose学习</h2><p>​    前两个月因为公司的事情，没有时间写写博客（其实是自己给自己找借口）。后面慢慢来，补上自己欠下的技术帐。这篇博客就是之前定的计划，但是没有机会写。下面就直接开始。</p>
<p>​    先说说Docker Compose的作用，有一部分人分不清楚Dockerfile和Docker Compose的区别，Dockerfile是用来构建镜像的构建文件，相当于告诉Docker如何构建一个自己需要的镜像。这个文件后面也会有一个博客来单独介绍。Docker Compose是用来编排容器，如果你要启动多个容器的话，使用单个命令多次执行是很繁琐的，并且每个容器需要的参数也可能不一致。Docker Compose就是解决这个问题的，使用统一编排启动多个容器，并且对多个容器进行不同的设置。下面就来简单介绍大体的结构，单个容器不同的参数配置这里就不在叙述了，可能就是简单举个例子。</p>
<p>​    首先需要先安装Docker Compose，算是Docker的一个插件，安装也很简单，mac和linux上面的安装我都安装过，但是Windows上的没有，所以找了官方的安装文档，上面各个系统都有，虽然是英文的，但是使用翻译还是能够看懂的，作为程序员，我比较后悔大学没有学好英语。<a href="https://docs.docker.com/compose/install/">Docker Compose官方安装文档</a></p>
<p>​    安装完毕，就需要了解如何使用和如何编写。一步一步来。</p>
<p>​    编写前，需要先了解Docker Compose和Docker版本的匹配图，要不然无法编写合适的Docker Compose文件。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201117143036674.png" alt="image-20201117143036674"></p>
<p>​    下面就一个简单的例子，来列举Docker Compose中对于一个容器的配置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br></pre></td></tr></table></figure>

<p>​    例子有了，现在就介绍一下这个例子中的各个参数的含义，由上往下开始说吧。<code>version</code>是指这个Docker Compose文件的版本，上面一个图也是指定不同Docker版本和Docker Compose的对应关系，这里是官网的例子，所以用的是3.8.<code>services</code>指的是该yml文件需要启动哪些服务，上面的例子是启动redis服务，redis服务中指定了镜像的来源、容器的端口、容器网络的配置、部署时的配置。在下面则是<code>networks</code>，声明了两个网络，名称分别是<code>fronted</code>和<code>backend</code>，最后则是一个卷的声明，声明了一个<code>db-data</code>，需要注意的是，这个卷需要在docker-compose启动前建立，要不然会报错，这个后面会讲。以上就是对于这个文件的一个初步讲解。可以看到这个文件对于docker里面的很多知识点都联系了起来，所以想要随心所欲的写出这样的一个文件，对于文件进行任意的修改是需要长时间docker的使用的，这里本人的技术也是有限，所以暂时讲到这里，对于一些细节的补充和知识点的错误，欢迎大家的指正。</p>
<p>​    下面就开始列举一个我自己编写的一个文件，并且讲一下其中遇到的问题和难点。文件内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http.port=9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticdata:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=12345678</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysqldata:/var/lib/mysql/</span></span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">&#x27;json-file&#x27;</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">labels:</span> <span class="string">&quot;service&quot;</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="string">&#x27;30m&#x27;</span></span><br><span class="line">        <span class="attr">max-file:</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:3.2.9</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;redis-server&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment">#- ./data:/data:z</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../conf/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;/usr/local/etc/redis/redis.conf&quot;</span> ]</span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">&#x27;json-file&#x27;</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">labels:</span> <span class="string">&quot;service&quot;</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="string">&#x27;30m&#x27;</span></span><br><span class="line">        <span class="attr">max-file:</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">elasticdata:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">driver_opts:</span></span><br><span class="line">      <span class="attr">o:</span> <span class="string">bind</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">device:</span> <span class="string">/home/program/data/elasticdata</span></span><br><span class="line">  <span class="attr">mysqldata:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">driver_opts:</span></span><br><span class="line">      <span class="attr">o:</span> <span class="string">bind</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">device:</span> <span class="string">/home/program/data/mysqldata</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>​    这里是列举了三个容器的配置文件，这里其实有很多不对的地方，但是目前能力和精力有限，也没有来得及修复。三个容器使用了卷，分别为<code>elasticdata</code>和<code>mysqldata</code>卷，网络只有ES使用了桥连接，但是也没有做好相应的设置。redis将本地的配置文件放进容器中，用来做密码和用户的设置，但是Mysql直接将密码当作环境变量，在容器启动的时候输入。上面说了，Docker Compose牵扯到许多Docker的知识点，想要随心所欲的编写文件很不容易，这里的配置许多是看了网上的配置和官方推荐的配置。自己理解的话很费时间也比较困难，只能鼓励自己慢慢爬上这座大山，也是留个坑，后面遇到这类问题也会慢慢的补充。本次的记录就到此为止了。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Docker学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Docker%E5%AD%A6%E4%B9%A0/Dockerfile%E4%BA%86%E8%A7%A3%E5%92%8C%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h2 id="Dockerfile了解和编写"><a href="#Dockerfile了解和编写" class="headerlink" title="Dockerfile了解和编写"></a>Dockerfile了解和编写</h2><p>​    这个也是之前欠下的技术帐，也是慢慢补上吧，算是对于Docker的更加深入的理解和应用。</p>
<p>​    Docker非常好用，简单快捷。但是如果想要自己构建一个独特的镜像，简单的使用显然不能够完成，需要更加深入的理解。这篇博客就是记录这个事情的。下面就开始吧。</p>
<p>​    在学习编写Dockerfile文件前，需要先了解Docker中镜像的构成。</p>
<p>​    一个镜像最开始是由父镜像生成的，这个则是由Dockerfile中<code>FROM</code>指令指定的。例如<code>FROM ubuntu:18.04</code>就是代表这个镜像是基于ubuntu镜像构建的。Docker中的镜像是由多个镜像层构成的，例如你下载的时候就会显示多个镜像层。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201120103701404.png" alt="image-20201120103701404"></p>
<p>一行就代表一个镜像层，可以看到这个镜像有8个镜像层。下载也是分别下载镜像层，这样做的好处是可以减少下载的流量，有可能不同的镜像用的是同一个镜像层。有时候你删除某个镜像，如果它依赖于java镜像，可能java镜像并不会删除。镜像层的概念就类似于此。为什么一个镜像会有多层的概念，这时就要讲到Dockerfile文件命令了，Dockerfile文件中有多少个命令，构建的镜像就会有多少层镜像层。例如下面的Dockerfile文件就会构建一个有三层的镜像。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> hello /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/hello&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>​    介绍完了简单的镜像的一些知识，下面就开始编写Dockerfile文件。Dockerfile文件通过由以下命令组成。FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOINT、VOLUME、USER、WORKDIR、ONBUILD。这些命令的使用组成了一个Dockerfile文件。再简单举个例子。这里以Docker官方的ruby文件为例。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> buildpack-deps:buster</span><br><span class="line"><span class="comment"># skip installing gem documentation</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -eux; \</span></span><br><span class="line"><span class="bash">	mkdir -p /usr/<span class="built_in">local</span>/etc; \</span></span><br><span class="line"><span class="bash">	&#123; \</span></span><br><span class="line"><span class="bash">		<span class="built_in">echo</span> <span class="string">&#x27;install: --no-document&#x27;</span>; \</span></span><br><span class="line"><span class="bash">		<span class="built_in">echo</span> <span class="string">&#x27;update: --no-document&#x27;</span>; \</span></span><br><span class="line"><span class="bash">	&#125; &gt;&gt; /usr/<span class="built_in">local</span>/etc/gemrc</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> RUBY_MAJOR <span class="number">3.0</span>-rc</span><br><span class="line"><span class="keyword">ENV</span> RUBY_VERSION <span class="number">3.0</span>.<span class="number">0</span>-preview1</span><br><span class="line"><span class="keyword">ENV</span> RUBY_DOWNLOAD_SHA256 aa7cce0c99f4ea2145fef9b78d74a44857754396790cd23bad75d759811e7a2a</span><br><span class="line"><span class="comment"># some of ruby&#x27;s build scripts are written in ruby</span></span><br><span class="line"><span class="comment">#   we purge system ruby later to make sure our final image uses what we just built</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -eux; \</span></span><br><span class="line"><span class="bash">	\</span></span><br><span class="line"><span class="bash">	savedAptMark=<span class="string">&quot;<span class="subst">$(apt-mark showmanual)</span>&quot;</span>; \</span></span><br><span class="line"><span class="bash">	apt-get update; \</span></span><br><span class="line"><span class="bash">	apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="bash">		bison \</span></span><br><span class="line"><span class="bash">		dpkg-dev \</span></span><br><span class="line"><span class="bash">		libgdbm-dev \</span></span><br><span class="line"><span class="bash">		ruby \</span></span><br><span class="line"><span class="bash">	; \</span></span><br><span class="line"><span class="bash">	rm -rf /var/lib/apt/lists/*; \</span></span><br><span class="line"><span class="bash">	\</span></span><br><span class="line"><span class="bash">	wget -O ruby.tar.xz <span class="string">&quot;https://cache.ruby-lang.org/pub/ruby/<span class="variable">$&#123;RUBY_MAJOR%-rc&#125;</span>/ruby-<span class="variable">$RUBY_VERSION</span>.tar.xz&quot;</span>; \</span></span><br><span class="line"><span class="bash">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$RUBY_DOWNLOAD_SHA256</span> *ruby.tar.xz&quot;</span> | sha256sum --check --strict; \</span></span><br><span class="line"><span class="bash">	\</span></span><br><span class="line"><span class="bash">	mkdir -p /usr/src/ruby; \</span></span><br><span class="line"><span class="bash">	tar -xJf ruby.tar.xz -C /usr/src/ruby --strip-components=1; \</span></span><br><span class="line"><span class="bash">	rm ruby.tar.xz; \</span></span><br><span class="line"><span class="bash">	\</span></span><br><span class="line"><span class="bash">	<span class="built_in">cd</span> /usr/src/ruby; \</span></span><br><span class="line"><span class="bash">	\</span></span><br><span class="line"><span class="bash"><span class="comment"># hack in &quot;ENABLE_PATH_CHECK&quot; disabling to suppress:</span></span></span><br><span class="line"><span class="comment">#   warning: Insecure world writable dir</span></span><br><span class="line">	&#123; \</span><br><span class="line">		echo <span class="string">&#x27;#define ENABLE_PATH_CHECK 0&#x27;</span>; \</span><br><span class="line">		echo; \</span><br><span class="line">		cat file.c; \</span><br><span class="line">	&#125; &gt; file.c.new; \</span><br><span class="line">	mv file.c.new file.c; \</span><br><span class="line">	\</span><br><span class="line">	autoconf; \</span><br><span class="line">	gnuArch=<span class="string">&quot;$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)&quot;</span>; \</span><br><span class="line">	./configure \</span><br><span class="line">		--build=<span class="string">&quot;$gnuArch&quot;</span> \</span><br><span class="line">		--disable-install-doc \</span><br><span class="line">		--enable-shared \</span><br><span class="line">	; \</span><br><span class="line">	make -j <span class="string">&quot;$(nproc)&quot;</span>; \</span><br><span class="line">	make install; \</span><br><span class="line">	\</span><br><span class="line">	apt-mark auto <span class="string">&#x27;.*&#x27;</span> &gt; /dev/null; \</span><br><span class="line">	apt-mark manual $savedAptMark &gt; /dev/null; \</span><br><span class="line">	find /usr/local -type f -executable -not \( -name <span class="string">&#x27;*tkinter*&#x27;</span> \) -exec ldd <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span> \</span><br><span class="line">		| awk <span class="string">&#x27;/=&gt;/ &#123; print $(NF-1) &#125;&#x27;</span> \</span><br><span class="line">		| sort -u \</span><br><span class="line">		| xargs -r dpkg-query --search \</span><br><span class="line">		| cut -d: -f1 \</span><br><span class="line">		| sort -u \</span><br><span class="line">		| xargs -r apt-mark manual \</span><br><span class="line">	; \</span><br><span class="line">	apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \</span><br><span class="line">	\</span><br><span class="line">	cd /; \</span><br><span class="line">	rm -r /usr/src/ruby; \</span><br><span class="line"><span class="comment"># verify we have no &quot;ruby&quot; packages installed</span></span><br><span class="line">	! dpkg -l | grep -i ruby; \</span><br><span class="line">	[ <span class="string">&quot;$(command -v ruby)&quot;</span> = <span class="string">&#x27;/usr/local/bin/ruby&#x27;</span> ]; \</span><br><span class="line"><span class="comment"># rough smoke test</span></span><br><span class="line">	ruby --version; \</span><br><span class="line">	gem --version; \</span><br><span class="line">	bundle --version</span><br><span class="line"><span class="comment"># don&#x27;t create &quot;.bundle&quot; in all our apps</span></span><br><span class="line"><span class="keyword">ENV</span> GEM_HOME /usr/local/bundle</span><br><span class="line"><span class="keyword">ENV</span> BUNDLE_SILENCE_ROOT_WARNING=<span class="number">1</span> \</span><br><span class="line">	BUNDLE_APP_CONFIG=<span class="string">&quot;$GEM_HOME&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $GEM_HOME/bin:$PATH</span><br><span class="line"><span class="comment"># adjust permissions of a few directories for running &quot;gem install&quot; as an arbitrary user</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p <span class="string">&quot;<span class="variable">$GEM_HOME</span>&quot;</span> &amp;&amp; chmod 777 <span class="string">&quot;<span class="variable">$GEM_HOME</span>&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;irb&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>​    可以看到上面的例子使用了四种指令，分别为<code>FROM</code>,<code>RUN</code>,<code>ENV</code>,<code>CMD</code>。<code>FROM</code>的作用就是声明基础镜像是哪个，也就是本次构建的镜像是由以哪个镜像为基础构建的。<code>RUN</code>常用就是安装软件，需要注意的就是一条指令会创建一个镜像层，所以尽可能减少多个<code>RUN</code>,让一个指令做更多的事，减少镜像层的臃肿。上面的例子也是如此，可以看到大量的用了<code>\</code>，就是为了避免创建过多的镜像层（比较考验Linux的功底）。<code>ENV</code>就是设置环境变量，需要注意的是，和Java中的类变量类似，上一层的镜像或者基于本镜像创建的镜像都可以使用这个环境变量。<code>CMD</code>是启动容器的时候被执行的命令，一个Dockerfile文件中只有一个<code>CMD</code>,可以有多个<code>RUN</code>.理解了这几个指令，再看上面的例子就能看出大概了，例子中先是声明使用了哪个基础镜像，再输入若干<code>RUN</code>和<code>ENV</code>指令去构建镜像，最好则是<code>CMD</code>指令，代表容器启动的时候镜像执行的命令。这样一个镜像的Dockerfile文件就写完了。</p>
<p>​    下面就开始执行<code>docker build</code>,构建镜像，然后就可以看到docker中有刚才构建的镜像了。构建镜像的步骤就算结束了，后续如果还有的话就是将镜像推送到云上的仓库，下一篇博客可能会讲一讲。</p>
<p>​    关于这些指令的详细介绍大家可以看看别的博客的介绍或者官网上的介绍（英文的）。后面就是官方的地址：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#dockerfile-instructions">https://docs.docker.com</a> 。后续我也会慢慢的补充，慢慢来吧。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Docker学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Docker%E5%AD%A6%E4%B9%A0/Docker%E4%B8%AD%E5%8D%B7%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Docker中卷的理解和使用"><a href="#Docker中卷的理解和使用" class="headerlink" title="Docker中卷的理解和使用"></a>Docker中卷的理解和使用</h2><p>​    最近工作的需要，了解了一下Docker的相关内容，同时接触了Docker中volume（下面都以卷来称呼）的概念，这篇博客也来记录一下自己学习到的东西。</p>
<p>​    Docker中的文件都是存储在容器层，这样做的好处是将宿主机和Docker内的容器隔离开来，但是缺点也是很明显的，当容器停止后，Docker不会存储容器运行中创建的文件，所以容器一旦停止，容器产生数据都会丢失，于是Docker提供了两个方法来将容器的文件存储到宿主机中。<em>volumes</em>, and <em>bind mounts</em>.绑定很好理解，就是声明将容器内的某个文件或者某个文件夹绑定到宿主机的某个文件或者文件夹，只需要在Docker-compose文件中声明即可（我的做法）。但是这种方法并不是Docker官方推荐的做法，官方更加推荐通过卷的形式来管理数据，理由也有以下几点。</p>
<ul>
<li><p>与绑定安装相比，卷更易于备份或迁移。</p>
</li>
<li><p>您可以使用Docker CLI命令或Docker API管理卷。</p>
</li>
<li><p>卷在Linux和Windows容器上均可工作。</p>
</li>
<li><p>可以在多个容器之间更安全地共享卷。</p>
</li>
<li><p>卷驱动程序使您可以将卷存储在远程主机或云提供程序上，以加密卷内容或添加其他功能。</p>
</li>
<li><p>可以通过容器预填充新卷的内容。</p>
<p>所以本次也来介绍卷的理解和使用。<strong>卷</strong>存储在<em>由Docker管理</em>的主机文件系统的一部分中（<code>/var/lib/docker/volumes/</code>在Linux上）。非Docker进程不应该去修改这个目录下的文件。卷是在Docker中持久保存数据的最佳方法。创建卷时，它存储在Docker主机上的目录中。将卷装入容器时，此目录就是装入容器的目录。这类似于绑定挂载的工作方式，卷由Docker管理并且与主机的核心功能隔离。说了这么多，下面就来开始使用吧。</p>
<h3 id="卷的创建"><a href="#卷的创建" class="headerlink" title="卷的创建"></a>卷的创建</h3></li>
</ul>
<p>​    卷的创建比较简单，一条命令即可。<code>docker volume create test</code>.查看Docker中的卷也是比较简单,<code>docker volume ls</code>.查看特定卷的详细信息：<code>docker volume inspect test</code>.下面列出执行结果。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200920175606271.png" alt="image-20200920175606271"></p>
<h3 id="卷的使用"><a href="#卷的使用" class="headerlink" title="卷的使用"></a>卷的使用</h3><p>​    卷最终还是要容器里使用的，下面就以一个nginx的镜像来使用刚刚创建的test卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=nginx -v <span class="built_in">test</span>:/usr/share/nginx/html nginx:latest</span><br></pre></td></tr></table></figure>

<p>​    这里需要注意，如果-v指定的卷没有创建，Docker会自动创建的。但是这个不是本次要介绍的方法，因为Docker-compose比较好用，所以工作中整合也是使用Docker-compose来自动创建卷，并且将卷挂载到哦宿主机的某个目录。Docker-compose文件内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http.port=9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticdata:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"> <span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">elasticdata:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">driver_opts:</span></span><br><span class="line">      <span class="attr">o:</span> <span class="string">bind</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">device:</span> <span class="string">/home/program/data/elasticdata</span>  </span><br></pre></td></tr></table></figure>

<p>​    因为对于Docker-compose和卷了解的还不是很清楚，所以这一部分可能会使用错误或者理解错误。这个文件会启动时会自动创建卷和将宿主机目录挂载到卷上。也欢迎大家到指正。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200920181837154.png" alt="image-20200920181837154"></p>
<p>​    这里疑惑的点有两个，一个是卷的名称和我文件中指定的不一致，还有就是上面图片显示的两个目录都存储的有ES的数据。因为自己的能力有限，目前无法理解这两个地方，后续填坑吧。</p>
<p>​    上面的知识点都是来自于官网，官网地址如下：<a href="https://docs.docker.com/storage/">Docker中数据的管理</a>，<a href="https://docs.docker.com/engine/reference/commandline/volume/">Docker中volume命令详解</a>。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Docker学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Docker%E5%AD%A6%E4%B9%A0/Docker%E4%BD%BF%E7%94%A8%E4%BA%91%E7%AB%AF%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="Docker使用云端镜像"><a href="#Docker使用云端镜像" class="headerlink" title="Docker使用云端镜像"></a>Docker使用云端镜像</h2><p>​    上一篇博客讲了如何通过Dockerfile构建自己的镜像，但是还没有具体的时间，后续可能会出一个自己实践的博客来构建自己的镜像，但是今天是来介绍一下如何将自己的镜像放到云上让大家都可以使用。下面就直接开始吧。</p>
<p>​    大家在使用镜像前都会将Docker镜像仓库的地址修改为阿里云的地址，这个镜像仓库就是本次博客要讲的东西。和git的仓库概念一样，镜像仓库也相当于git中的代码仓库，下载某个项目的代码在Docker中就相当于pull某个镜像。镜像分为两种，一种是官方的镜像，这类镜像有安全保障，镜像会及时更新，比较安全。另外一种就是单独的镜像，不能保证安全，但是不能说明这类镜像不够好，这类镜像相当大一部分都是个人做的，部分镜像也是比较好用的。今天我们就来制作一个自己的镜像，选择的是阿里云的Docker镜像服务。</p>
<p>​    登录阿里云地址，创建自己的命名空间。<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories">阿里云镜像仓库登录地址</a>，创建完命名空间后，创建自己的镜像仓库。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201123112421847.png" alt="image-20201123112421847"></p>
<p>​    创建完毕，开始在本地机器上登录你的阿里云账号。在控制台可以看到登录的命令，密码是你自己设置的。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201123161057139.png" alt="image-20201123161057139"></p>
<p>​    如果要下载私有镜像，登录完毕就可以下载了。如果需要上传镜像，需要把本地的镜像打个tag。命令格式如下图所示。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201123161358836.png" alt="image-20201123161358836"></p>
<p>​    命令执行截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201123162220087.png" alt="image-20201123162220087"></p>
<p>打完，直接push就可以上传了，刷新你的管理页面就可以看到镜像已经上传了。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201123162138266.png" alt="image-20201123162138266"></p>
<p>​    管理页面截图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201123162248038.png" alt="image-20201123162248038"></p>
<p>​    因为这里仓库是公共的，换了一台机器，直接下载，下载完成，代表镜像已经成功上传到云上。截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201123174126899.png" alt="image-20201123174126899"></p>
<p>​    至此，镜像上传到云上的流程就已经走通了，结合上一篇博客，就是自己构建镜像，再将镜像上传到云上。流程通了后，剩下就是慢慢梳理细节了。可能下一篇博客就是搭建一个真正的属于自己的镜像，再直接下载到其他机器上。准备的是搭建一个VNC的镜像，也有可能换（因为不清楚VNC最后能不能满足需求）。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Docker学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Docker%E5%AD%A6%E4%B9%A0/Docker%E4%BF%9D%E5%AD%98%E9%95%9C%E5%83%8F%E5%92%8C%E5%8A%A0%E8%BD%BD%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="Docker保存镜像和加载镜像"><a href="#Docker保存镜像和加载镜像" class="headerlink" title="Docker保存镜像和加载镜像"></a>Docker保存镜像和加载镜像</h2><p>​    最近在搞一键部署，因为Docker的镜像下载很慢，所以想搞成离线加载的，这样可以省去很多时间，于是了解了一下Docker的镜像保存和加载机制，下面就直接开始吧。</p>
<p>​    这里是直接将你本地的镜像打包，这样就可以在另一台机器上加载这个镜像了。下面就列出来用到的几条命令，同时实际操作一下。</p>
<ul>
<li> 查询要保存的镜像</li>
</ul>
<p>  ​    用到的命令：<code>docker ps</code>，需要用到的就是<code>REPOSITORY</code>或者<code>IMAGE ID</code>,这个是镜像存放的仓库，相当于云上的地址，后面也会有博客讲一下如何将自己的镜像推到云上，这里不在耽误时间了。直接上图。</p>
<p>  <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200919174552480.png" alt="image-20200919174552480"></p>
<ul>
<li><p>保存镜像</p>
<p>​    用到的命令<code>docker save [OPTIONS] IMAGE [IMAGE...]</code>,参数只有一个-o,表示输出的文件名。这里直接打包命令为：</p>
<p><code>docker save -o test.tar 121454ddad72</code> 或者</p>
<p><code>docker save -o test1.tar docker.elastic.co/elasticsearch/elasticsearch</code></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200919175202935.png" alt="image-20200919175202935"></p>
</li>
<li><p>加载镜像</p>
<p>这个就是最后一步了，加载也是比较简单的，把刚才的tar包上传到服务器，直接load即可。命令如下:</p>
<p><code>docker load -i test.tar</code></p>
<p>加载后到镜像和打包的镜像是一样的，版本和仓库地址。后续就可以愉快使用了。如图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200919175508640.png" alt="image-20200919175508640"></p>
</li>
</ul>
<p>  这次的博客比较短，也没有什么可说的，后续慢慢补充吧。</p>
<p>  就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Docker学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Docker%E5%AD%A6%E4%B9%A0/Docker%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="Docker相关知识点"><a href="#Docker相关知识点" class="headerlink" title="Docker相关知识点"></a>Docker相关知识点</h2><h3 id="Docker基础知识"><a href="#Docker基础知识" class="headerlink" title="Docker基础知识"></a>Docker基础知识</h3><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p>​    Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资 源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境 变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>​    镜像是由多层文件系统联合组成，镜像构建时，是分层构建的，前一层是后一层的基础。这就就能保证层级的复用，同时也能使镜像的定制变得容易。例如pull镜像的时候，下载的一行一行的就是层级，下载多个有关联的镜像时，实际的下载会将多个层级复用，省得重复下载。</p>
<h4 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>​    容器和镜像的关系就像Java中类和对象的关系，通过一个类可以创建多个对象，多个对象之间互不影响，同时对象也有生存周期。Docker中的容器还有一点不同，容器在运行中存储的信息会随着容器的删除而消失，就是容器没有持久化存储信息的能力，如果想要持久化容器内部的信息，需要使用数据卷或者将容器内的目录挂挂载到宿主机上。</p>
<h4 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h4><p>​    Docker仓库和git仓库类似，你可以在仓库上发布自己镜像的版本，供自己和其他人使用，官方的Docker Hub上也有很多官方镜像，例如：MySQL、Redis、ElasticSearch。本地也可以搭建自己的私有镜像仓库。</p>
<h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><ul>
<li><p>pull命令：<code>docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</code>从指定仓库拉取指定镜像的版本。</p>
</li>
<li><p>docker run 命令：<code>docker run -it --rm ubuntu:14.04 bash</code>运行对应的容器。</p>
</li>
<li><p>docker images命令：<code>docker images</code>查看所有的镜像。</p>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Docker学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/HashMap%E4%B8%AD%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="HashMap中红黑树的代码解析"><a href="#HashMap中红黑树的代码解析" class="headerlink" title="HashMap中红黑树的代码解析"></a>HashMap中红黑树的代码解析</h3><p>​    看到这里，红黑树的基本概念和操作都已经清楚了，如果条件允许的话，你说不定已经实际操作或者编写代码了。下面就来看一下JDK源码中对于红黑树的实现，再次巩固一下上面的知识。</p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>​    </p>
<p>​    如果当前节点链表超过8个，就调用树化方法、如果当前tab长度没有超过32，就扩容，如果超过32就将链表红黑树化</p>
<p>​    循环遍历将节点链表按照先后顺序复制给hd，然后将hd树化（梳理）</p>
<p>（断言检测不清楚作用）</p>
<p>​    取下一个节点</p>
<h4 id="使用情景和细节"><a href="#使用情景和细节" class="headerlink" title="使用情景和细节"></a>使用情景和细节</h4><p>红黑树颜色的作用是搭配起来使用的，</p>
<p>红黑树的维护平衡有很多方法，主要就是维护高度和节点颜色</p>
<p><a href="http://www.doczj.com/doc/cffdb8b4e009581b6ad9eb1c-4.html">http://www.doczj.com/doc/cffdb8b4e009581b6ad9eb1c-4.html</a></p>
<p><a href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf">https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><p>​    今天来看一下HashMap的源码，学习一下相关的知识点。不多啰嗦了，直接开始吧。</p>
<p>​    先看一段代码，是使用HashMap的代码，比较简单，先从代码入手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Date&gt; test = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">test.put(<span class="string">&quot;test1&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">test.put(<span class="string">&quot;test2&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">test.put(<span class="string">&quot;test1&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">Date date = test.get(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">System.err.println(date);</span><br></pre></td></tr></table></figure>

<p>​    代码比较简单，建立一个map，存放date，先后放了三次，代表三个场景，第一次当map为空时放入、第二次放入不同的key，第三次放入相同key，但是value不同。最后取出第一次放入的key的value并且打印出来。下面就来具体看看源码，看看HashMap到底做了什么。</p>
<p>​    先看第一行代码，看到声明了一个map，执行了key和value的类型。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210228215831632.png" alt="image-20210228215831632"></p>
<p>​    构造函数只有一行，指定了负载系数，下面看一下这个负载系数是什么东西。<code>负载因子是在自动增加其哈希表容量之前允许哈希表获得的满度的度量。</code>不难理解，这个负载系数是map自动扩增的一个阈值。好像这个构造函数比较简单，只是简单的赋值了，也没有什么初始化的操作，别急，看看第二行代码吧。</p>
<p>​    第二行代码就是放入一个key为test，value为当前时间的操作。来看看<code>put(K key, V value)</code>做了什么。<code>put(K key, V value)</code>的代码只有一行。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210301161338805.png" alt="image-20210301161338805"></p>
<p>​    <code>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</code>是一个实现，看一下传参的含义，需要注意的参数不多，就一个hash值，下面看一下hash方法。<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210301161814463.png" alt="image-20210301161814463"></p>
<p>​    方法注释如下：<strong>计算key.hashCode（）并将哈希的较高位（XOR）扩展为较低。 由于该表使用2的幂次掩码，因此仅在当前掩码上方的位中发生变化的哈希集将始终发生冲突。 （众所周知的示例是在小表中包含连续整数的Float键集。）因此，我们应用了一种变换，将向下扩展较高位的影响。 在速度，实用性和位扩展质量之间需要权衡。 由于许多常见的哈希集已经合理分布（因此无法从扩展中受益），并且由于我们使用树来处理容器中的大量冲突集，因此我们仅以最便宜的方式对某些移位后的位进行XOR，以减少系统损失，以及合并最高位的影响，否则由于表范围的限制，这些位将永远不会在索引计算中使用。</strong>这边说一下自己的理解：这个方法返回的是int类型，四个字节，后面是用来确定key在数组中的下标，但是map中数组长度是有限制的，一般小于2^16，即65536。获取key下标的代码如下：<code>tab[i = (n - 1) &amp; hash]</code>（hash%n等价于(n - 1) &amp; hash）,也就是说只可能会和四个字节的低两个字节进行位运算，所以这里的hash方法作用也就不难判断出来，将hash值变得更加散乱，减少哈希冲突。这里的实现就是让hashCode和高16位进行异或运算（异或的运算不偏向于0或者1）。<code>hashCode()</code>方法调用底层C的代码，这里能力有限，就不再列出来叙述了。到这里，明白了HashMap并不是将hashCode直接拿来用，还是有一定的运算。这里参考了一片博客：<a href="https://blog.csdn.net/qq_42034205/article/details/90384772">讲解hash方法</a></p>
<p>​    回到<code>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</code>方法，代码比较多，这里直接粘贴出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里初看代码有些不知道看哪里，可以按照最开始编写的代码去跑这个代码逻辑。下面就开始按照第二行代码梳理。</p>
<p>​    代码先是判断数组存不存在，数组每个位置存放的是一个节点链表。如果数组为空，就调用初始化方法<code>resize()</code>,这个方法可以放在后面讲，现在暂时略过，方法作用很简单，就是初始化或者增加表大小。下面就是根据哈希值获取key所在的下标，因为这里第一次放入，代码肯定位空，所以直接新建节点并且放入，next节点置为空。接着就来到了最后，判断当前负载系数是否超过最开始设置的值（默认0.75），如果超过，就再执行一次<code>resize()</code>.最后返回一个空。以上解析就是HashMap在放入第一个值时做的事，看着还是挺多的，下面接着看最开始编写的第三行代码。</p>
<p>​    第三行代码放入了一个不同的key，不同的value。按照上面的代码再走一遍，不过这个时候数组已经有了，不需要再次创建。但是因为key不相同，所以哈希值不相同（假设没有哈希冲突），所以后面的步骤就和上面的一样了：新建一个节点，放入到数组中。同时在最后也会对数组长度做判断，达到负载系数就扩容。那就来看第四行代码。</p>
<p>​    第四行代码是继续放入一个相同的key，但是value不同。仍然走上面的代码，发现数组已经创建，但是通过计算下标发现该下标已经有节点，执行了else部分。先是判断key是否相同，这里判断方法为：<code>hash值是否相等&amp;&amp;(两个key相等||两个key的eques方法返回true)</code>。看到这里，是不是也清楚了：重写eques方法一定要重写hashCode方法。因为如果这里没有重写hashCode方法，即哈希值不一定相同，就会造成相同的key，却有两个下标，导致后续的put无法覆盖掉原有的key。回到源码，看到else最后将原有的value取出，将新的放进去，并且将原有value返回，结束本次放入。（这里可能理解不太对，欢迎大佬们指正）</p>
<p>​    到了最后一行，将放入到值取出。看看源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码可以比较清晰的看到HashMap中<code>节点</code>这个概念的存储结构，先是找到哈希值所在的下标，再去判断节点的第一个到key是否相同（和上面所到判断方法一致），到这里，也就理解了：哈希值相同，eques方法不一定返回true。如果不是第一个元素，在开始遍历节点中的链表，一直到找到为止。到这里，最开始编写的代码也就全部解析完毕。中间的一些逻辑分支没有细说，东西都是大差不差，没有什么需要特别说的点。下面根据这个方法我找到了一个流程图。和下面的图片来源一样。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302141253511.png" alt="image-20210302141253511"></p>
<p>​    最后开始填上面的坑，resize方法。这个方法是比较重要的，属于map的扩容机制。先提一点，通过上面的解析，现在也大致清楚了HashMap中的结构，不仅仅的是一个数组，是将链表和数组的形式结合了起来。类似于下面这个形式。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302110441809.png" alt="image-20210302110441809"></p>
<p>​    这个图片来源于:<a href="https://blog.csdn.net/login_sonata/article/details/76598675">Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法）</a>,后面的解析也参考了这个博客，讲解的比较清晰。</p>
<p>​    当数组到了一定的容量后，需要对数组进行扩容，扩容后也需要对元素的下标进行重新计算，resize方法完成的就是这些内容。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里按照讲解put方法的方式分析，按照两种情况进行解析。1.数组没有初始化的时候扩容。2.数组负载系数达到阈值时，对数组进行扩容。</p>
<ul>
<li><p>当数组没有初始化，先是将数组长度和长度阈值设置好，然后直接创建数组，将数组给全局变量就完成这一步骤。初始化比较简单，主要就是各个参数的设置。</p>
</li>
<li><p>当数组需要扩容时就比较复杂了，判断是否需要扩容这一部分就不再细说了，就是各个逻辑的梳理，按照代码来即可，没有什么可说的点。只需要记得扩容后就是将原有数组长度乘2，所以HashMap的数组长度只能是2的幂次方（包括你自己设置为13，也会自动寻找最近的2的幂次方）需要重点说的就是扩容后，将原有数组移植到新数组中。这里有两个分支不需要讲：1.链表长度超过8时转换为红黑树的实现（这部分包括put方法里面涉及红黑树的会单独写一个博客，留坑）。2.链表只有一个节点时的情况，比较简单，重新计算下标即可。重点中的重点就是，链表节点树为多个的情况。就是最后一个else里面的代码。</p>
<p>先看一个解析。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210302113927205.png" alt="image-20210302113927205"></p>
<p>这个解析比较清晰，所以判断一个链表中改位置需不需要移动，就可以直接用<code>(e.hash &amp; oldCap) == 0</code>来判断，即直接将数组长度和哈希值与一下就能判断出高位是否会变化。如果等于零就不需要移动，不等于零，就需要移动到新的位置，新的数组下标为多少，上面的解析也能看出来，就是加8，即加上旧数组长度。这样的话，看这段代码就比较容易看懂了。循环遍历链表，再判断该节点是否需要移动，需要移动就放到高位节点链表中，不需要移动就放到低位节点链表中。创建四个节点也是为了方便放入，最后遍历完毕，将高低位的头节点放入到指定下标即可，完成了数组的迁移。</p>
</li>
</ul>
<p>​    至此，关于最开始编写的代码的解析都已经完毕了，剩下的红黑树实现和哈希表的原理因为能力有限，放到后面讲，要不然博客就太长了。在最后，欢迎各位大佬指正和批评。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/JUC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>java中虚假唤醒的问题</p>
<p>if只会判断一次，但是while唤醒后还是会继续判断</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Java中Lambda表达式学习"><a href="#Java中Lambda表达式学习" class="headerlink" title="Java中Lambda表达式学习"></a>Java中Lambda表达式学习</h2><p>​    上一篇博客了解了线程的相关学习，学习的过程中看到一个注解<code>@FunctionalInterface</code>，本次的博客就来学习一下函数式接口。函数式接口可以用Lambda来创建，所以函数式接口的学习应该在Lambda表达式前面。</p>
<p>​    先来看一下函数式接口的文档定义：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210218093905631.png" alt="image-20210218093905631"></p>
<p>可以发现几个重要的点：</p>
<ul>
<li>函数式接口只有一个抽象方法。</li>
<li>默认方法和覆盖方法都不计入抽象方法数目。</li>
<li>可以用Lambda表达式、方法引用、构造函数引用来创建函数式接口实例。</li>
<li>注解并不一定是必须的，只要符合要求，编译器会自动将接口视为函数式接口。</li>
</ul>
<p>​    下面看一个jdk中自带的函数式接口的实现，<code>Comparator</code>接口。发现里面有很多方法的实现，但是也使用了<code>@FunctionalInterface</code>注解，仔细再看，可以看到只有两个抽象方法，其他都是静态方法或者默认方法，都有实现。再看两个抽象方法，一个是继承了Object类的<code>equals</code>方法，所以最后这个接口只有一个抽象方法，符合函数式接口的定义。</p>
<p>​    下面就来看一下如何使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Description: 使用lambda表达式作为转换为函数式接口传递到Arrays.sort中第二个参数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2019-07-18</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arraySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String[] arrays = &#123;<span class="string">&quot;1237&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">       Arrays.sort(arrays, (first, second) -&gt; second.length() - first.length());</span><br><span class="line">       System.err.println(arrays[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    方法描述已经比较详细的介绍了这个方法的作用，因为<code>sort(T[] a, Comparator&lt;? super T&gt; c)</code>方法不是本篇博客的重点，所以不再叙述太多，简单理解为将数组中的元素按照给定的方法比较排序即可。这里第二个参数就是函数式接口，可以看到这里的传值为<code>(first, second) -&gt; second.length() - first.length()</code>,这个就是典型的Lambda表达式的应用，函数式接口的实现内容就是：返回用第二个参数的长度减去第一个参数的长度得到的值。但是我们还是有很多疑问的。下面一一去寻找答案。</p>
<ul>
<li><code>(first, second) -&gt; second.length() - first.length()</code>是什么意思，为什么这样写？换个方式<code>(String first, String second) -&gt; &#123;return second.length() - first.length();&#125;</code>这样是不是就可以看出大概了，知道这个是<code>Comparator</code>中接口方法<code>int compare(T o1, T o2);</code>的实现。</li>
<li>为什么不用声明参数类型，代码是如何知道我传入的类型？这个需要看一下方法<code>public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</code>，可以看到在调用soft方法时就已经声明了参数的类型，所以编译器就知道了这里是否正确，也是可以省略参数类型的原因。</li>
</ul>
<p>​    Lambda表达式的特征如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210218113001221.png" alt="image-20210218113001221"></p>
<p>​    下面开始编写自己的一个函数式接口的demo。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 测试使用的代码，分别要传入各自的参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Eatable e)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(e);</span><br><span class="line">		e.taste();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Flyable f)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我正在驾驶：&quot;</span>+f);</span><br><span class="line">		f.fly(<span class="string">&quot;【碧空如洗的日子】&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Addable add)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;5与3的和为：&quot;</span>+add.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 主方法，其中的方法参数都是使用lambda表达式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		demo1 demo1=<span class="keyword">new</span> demo1();</span><br><span class="line">		<span class="comment">//lambda表达式的代码只只有一句，可以省略“&#123;&#125;”</span></span><br><span class="line">		<span class="comment">//这里的lambda表达式实际上被当成任意的类型，具体的类型取决于运行环境的需要</span></span><br><span class="line">		demo1.eat(()-&gt;System.out.println(<span class="string">&quot;苹果的味道不错&quot;</span>));</span><br><span class="line">		<span class="comment">//方法的形参只有一个，可以省略“()”  weather是接口方法的形参</span></span><br><span class="line">		demo1.drive(weather-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;今天的天气是：&quot;</span>+weather);</span><br><span class="line">			System.out.println(<span class="string">&quot;直升机飞行平稳&quot;</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//代码只有一句，可以省略“&#123;&#125;”,同时也可以省略return关键字 a+b是返回值</span></span><br><span class="line">		demo1.test(Integer::sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试使用的接口,只有一个抽象方法的接口（函数式接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String weather)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    现在看这些代码是不是很容易就明白了。这里也就不再将代码进行详细解析。</p>
<p>​    函数式接口和其如何使用都已经了解了，下面就开始了解函数式接口有哪些使用方式，从最开始的文档中可以了解到，有三种方式去创建函数式接口实例。lambda表达式，方法引用或构造函数引用。Lambda表达式刚才已经看到并且使用到了，下面详细说一下方法引用和构造函数引用。</p>
<ul>
<li><p>方法引用。方法引用分为实例方法引用、静态方法引用和特定类型的方法引用。语法分别为：</p>
<ul>
<li>实例方法引用：<code>new instMethod()::method</code></li>
<li>静态方法引用：<code>类名::staticMethod</code></li>
<li>特定类型的方法引用：<code>类名::instMethod</code>（个人认为不常用）</li>
</ul>
<p>举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LambdaTrain6.java</span></span><br><span class="line"><span class="comment"> * Description: 博客中使用的练习demo，将方法引用汇集在一起</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTrain6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 第一个&lt;T&gt; 声明范型的类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2021-02-18</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T s)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是一个静态方法引用，有参数，但是没有返回值：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个普通方法引用，没有参数，但是返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是特定类型的方法引用&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态方法引用</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = LambdaTrain6::hello;</span><br><span class="line">        consumer.accept(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//普通方法引用</span></span><br><span class="line">        Supplier&lt;String&gt; supplier = <span class="keyword">new</span> LambdaTrain6()::put;</span><br><span class="line">        System.err.println(supplier.get());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.抽象方法的第一个参数类型刚好是实例方法的类型（函数式接口的抽象方法必须要有输入参数）。2.抽象方法剩余</span></span><br><span class="line"><span class="comment">         * 的参数恰好可以当做实例方法的参数。如果函数式接口的实现能由上面说的实例方法调用来实现的话，</span></span><br><span class="line"><span class="comment">         * 那么就可以使用对象方法的引用(两个条件都要满足)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BiConsumer&lt;LambdaTrain6, String&gt; biConsumer = LambdaTrain6::fun;</span><br><span class="line">        biConsumer.accept(<span class="keyword">new</span> LambdaTrain6(), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>构造方法引用 ，构造方法引用的语法就只有一种：<code>类名::new</code></p>
<p>举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LambdaTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LambdaTrain5.java</span></span><br><span class="line"><span class="comment"> * Description: lambda表达式练习，练习方法引用的构造方法引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTrain5</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果函数式接口的实现恰好可以通过调用一个类的构造方法来实现，那么就可以使用构造方法引用</span></span><br><span class="line"><span class="comment">     * 语法</span></span><br><span class="line"><span class="comment">     * 类名::new</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 主方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-08-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Person&gt; supplier = () -&gt; <span class="keyword">new</span> Person();</span><br><span class="line">        Supplier&lt;Person&gt; supplier1 = Person::<span class="keyword">new</span>;</span><br><span class="line">        supplier.get();</span><br><span class="line">        supplier1.get();</span><br><span class="line"></span><br><span class="line">        Consumer&lt;Integer&gt; consumer = (i) -&gt; <span class="keyword">new</span> Student(i);</span><br><span class="line">        Consumer&lt;Integer&gt; consumer1 = Student::<span class="keyword">new</span>;</span><br><span class="line">        consumer.accept(<span class="number">1</span>);</span><br><span class="line">        consumer1.accept(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有参构造器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Function&lt;String, Integer&gt; function = s -&gt; s.length();</span><br><span class="line">        Function&lt;String, Integer&gt; function1 = String::length;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + function.apply(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + function1.apply(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Function&lt;String, Student&gt; function2 = Student::<span class="keyword">new</span>;</span><br><span class="line">        function2.apply(<span class="string">&quot;hahahah&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 重写构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-08-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is Person&#x27;s construction method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have no parameter &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this method have one parameter&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    学习了函数式接口的使用方式和练习了一些基本的demo，现在回头看Lambda表达式是不是就更加清楚其意思了。但是什么时候或者什么地方该用Lambda呢？这个问题我现在也没有很明白，后续会慢慢补充。<code>java.util.function</code>包下都是jdk自带的函数式接口，阅读完这些接口的含义可能会对函数式接口有了一个更加清晰的认识，说到底，Lambda表达式和函数式接口的存在还是为了让写代码更加清晰和简洁。万变不离其意。要在开发中你感觉可以使用Lambda的地方使用它，使用的多了，了解也就更加的深入了。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Java中基础运算符和知识点记录"><a href="#Java中基础运算符和知识点记录" class="headerlink" title="Java中基础运算符和知识点记录"></a>Java中基础运算符和知识点记录</h2><p>​    在阅读源码和其他的一些代码后，发现自己一些基础的运算符老是忘记（其实就是不懂。。。），所以专门写一篇博客记录一下，防止后续自己忘记。不多啰嗦，直接开始。</p>
<p>​    <code>&amp;</code>：与运算符，位运算符的一种，表示同一位都为1时，最后结果才为1。例子：<code>4&amp;6=4</code>（使用计算器将两个数都显示出来更加能够理解透彻）</p>
<p>​    <code>|</code>：或运算符，位运算符的一种，表示同一位只要有一个为1，最后结果就为1。例子：<code>4|6=6</code>。</p>
<p>​    <code>~</code>：非运算符，位运算符的一种，该位为1时，结果为0，该位为0时，结果为1。例子：<code>(byte)~4=0xFB</code></p>
<p>​    <code>^</code>：异或运算符，位运算的一种，表示同一位相同时最后结果为0，同一位不同时最后结果为1.例子：<code>4^6=2</code></p>
<p>​    <code>&gt;&gt;</code>：右移运算符，位运算符的一种，表示将操作数向右移动，移出的全部丢弃，左边的看符号位进行补全，如何符号为位0，则补0，反之补1。例如：<code>4&gt;&gt;2=2</code></p>
<p>​    <code>&lt;&lt;</code>：左移运算符，运算符的一种，表示将操作数向左移动，移出位置全部丢弃，右边全部补0.例如：<code>2&lt;&lt;2=4</code></p>
<p>​    <code>&gt;&gt;&gt;</code>：无符号右移运算符。位运算符的一种，表示将操作数向右移动，移出位置全部丢弃，左边全部补0.例如<code>-4&gt;&gt;&gt;2=1073741823</code></p>
<ul>
<li>补充：计算机中存储负数不是简单的符号位加后面的数，存储的是负数的补码，这样是方便两个数相加。例如-4的补码是0xFFFFFFFC,所以负数的无符号右移会和预想中的不一致。可以自己写写代码看一下。</li>
</ul>
<p>​    <code>布尔表达式?表达式1:表达式2</code>：三目运算符。如果布尔表达式为true，执行表达式1，为false，执行表达式2。例如：<code>a=1&gt;2?1:2</code>,最后a=2.</p>
<p>​    <code>&amp;&amp;</code>：逻辑与，逻辑运算符的一种。当两个条件都为true时，最后结果才为true，有一个不为true，最后结果就为false。</p>
<p>​    <code>||</code>：逻辑或，逻辑运算符的一种。当两个条件任意一个为true时，最后结果就为true，只有两个条件都为false，最后结果才为false。</p>
<p>​    <code>bread和continue的区别</code>：break跳出本层嵌套的循环，continue跳出本次的循环，并没有跳出循环体。</p>
<p>​    暂时就想到这些了，后续还会慢慢补充。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Java中的参数传递类型"><a href="#Java中的参数传递类型" class="headerlink" title="Java中的参数传递类型"></a>Java中的参数传递类型</h2><p>​    在阅读HashMap中的源码过程中，阅读到一些方法之间的调用涉及到参数传递，有些情况下感觉最后的结果和我想的不一样，所以特地了解了一下参数传递，在这里也记录一下，防止自己忘记。</p>
<p>[TOC]</p>
<h3 id="了解一些基础概念"><a href="#了解一些基础概念" class="headerlink" title="了解一些基础概念"></a>了解一些基础概念</h3><p>​    在学习参数传递之前需要先了解一些基础概念，这里也会给出实例代码。方便理解。</p>
<h4 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h4><p>​    参数传递在程序中是比较常见的。参数传递涉及到两个概念。形式参数和实际参数。下面就说一下两者的区别。</p>
<blockquote>
<p>形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数，简称“形参”。<br>实际参数：在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”，简称“实参”。</p>
</blockquote>
<p>​    Java也不例外，也存在形式参数和实际参数，在这里分别举个例子。</p>
<h4 id="形参和实参的举例"><a href="#形参和实参的举例" class="headerlink" title="形参和实参的举例"></a>形参和实参的举例</h4><p>​    形式参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(StringBuffer s, <span class="keyword">int</span> a)</span><span class="comment">//形式参数s和a</span></span></span><br></pre></td></tr></table></figure>

<p>​    实际参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">test(s, a);<span class="comment">//实际参数s和a</span></span><br></pre></td></tr></table></figure>

<p>​    看了上面的例子，是不是了解了形式参数和实际参数的区别。</p>
<h4 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h4><p>​    在程序语言中的参数传递类型有两种，分别为值传递和引用传递。两者的概念和区别如下：</p>
<blockquote>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<p>​    这里的举例用C来举例，用C的代码分别举例值传递和引用传递。</p>
<h4 id="值传递和引用传递的举例"><a href="#值传递和引用传递的举例" class="headerlink" title="值传递和引用传递的举例"></a>值传递和引用传递的举例</h4><p>​    值传递：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bef swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">    swap(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pass by value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    引用传递：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bef swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">    swap2(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, add of a = %d\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aft swap, val of a = %d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass by reference</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面两个例子就是值传递和引用传递的区别，运行后也是不同的效果，还是比较明显的。c这一块不是很熟悉，代码可能有误，但是思想我认为传达到了。</p>
<h3 id="了解Java中的传递类型"><a href="#了解Java中的传递类型" class="headerlink" title="了解Java中的传递类型"></a>了解Java中的传递类型</h3><p>​    终于到了本文的正题了，开始讲解一下Java中的参数传递的机制和原理。在讲解之前，需要先了解一下JVM中的堆和栈的区别。</p>
<ul>
<li>栈内存。栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</li>
<li>堆内存。存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li>
</ul>
<p>​    可以简单的理解为方法中的变量都存储在栈中，实际的对象都存储在堆中。方法之间是不能够互相修改变量的。所以也就有了这种说法。<strong>Java中只存在值传递，不存在引用传递</strong>，因为本质上都是复制了一份副本，所以都是值传递。下面就开始讲解。</p>
<h4 id="对于传递类型的解析"><a href="#对于传递类型的解析" class="headerlink" title="对于传递类型的解析"></a>对于传递类型的解析</h4><p>​    Java中的参数分为两种，基本类型参数和引用数据类型，基本数据类型基本上没有什么分歧，都认为是值传递。主要分歧都在引用数据类型上。</p>
<p>​    在方法之间传递一个引用数据类型是，类似于这种<code>foo(User user)</code>,变量user相当于一个指针，指向了堆中实际的存储对象。在传递过程中，将指针进行复制，传递到foo方法中，两个变量是有区别的，但是指想的都是堆中同一个对象。</p>
<p>​    说的可能不太好理解，举一些例子来说明一下。</p>
<h4 id="举一些小例子"><a href="#举一些小例子" class="headerlink" title="举一些小例子"></a>举一些小例子</h4><ul>
<li>例子一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nativetrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferHKTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 调用海康SDK的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferHKTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        test(user);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user.name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    User(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    运行结果如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210317153823967.png" alt="image-20210317153823967"></p>
<p>​    这个运行结果好像和我们说的不一致，其实细想一下就明白了，方法传递的是一个指针的副本，最后指向的都是堆中的对象。修改这个对象后在主方法中当然可以起效。但是和引用传递还是有区别的，区别就是引用传递能修改真正的参数，但是Java中的传递并不行。可以再看一下下面一个代码示例。</p>
<ul>
<li>例子二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nativetrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferHKTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 调用海康SDK的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferHKTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        test(user);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.err.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    User(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210317154636836.png" alt="image-20210317154636836">    </p>
<p>​    只是简单的修改了一下，最后的结果就不一样了。这里将参数传递的变量进行初始化，相当于在堆中又创建了一个User对象，和主方法中的user对象所指向的对象是两个完全不同的对象，所以这里的修改也就没有起效。两次的打印也就不一样。</p>
<p>​    到这里，是不是对于Java中参数传递类型就更加清楚了一些。能力有限，如果文中有些错误，欢迎大佬指正。</p>
<p>​    本文也借鉴了一些博客，博客地址：<a href="https://www.cnblogs.com/sum-41/p/10799555.html">深入理解Java中方法的参数传递机制</a></p>
<p>​    就这样吧，结束。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0ping%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Java代码实现ping命令"><a href="#Java代码实现ping命令" class="headerlink" title="Java代码实现ping命令"></a>Java代码实现ping命令</h2><p>​    在一个项目中，遇到了一个问题，需要查看某个IP是否能够ping通，这里就直接使用Java代码实现了，记录一下。</p>
<p>​    先说一下实现的几个方法。</p>
<ul>
<li><p>Jdk1.5的InetAddresss方式</p>
</li>
<li><p>调用本机CMD</p>
</li>
<li><p>Java调用控制台执行ping命令</p>
</li>
</ul>
<p>​    下面也就不不废话了，直接上代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> network_train;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NetWorkTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 网络测试demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTrain</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 主方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ipAddress = <span class="string">&quot;192.168.16.127&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Jdk1.5的InetAddresss方式</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Jdk1.5的InetAddresss方式&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;主机的状态，&quot;</span> + pingforInetAddresss(ipAddress));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 直接调用CMD</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.err.println(<span class="string">&quot;直接调用CMD&quot;</span>);</span><br><span class="line">            <span class="comment">//pingForCMD(ipAddress);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;更加完善的调用CMD方法&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;主机的状态&quot;</span> + pingForExec(ipAddress, <span class="number">5</span>, <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: Jdk1.5的InetAddresss方式，返回值是true时，说明host是可用的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">pingforInetAddresss</span><span class="params">(String ipAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//超时应该在3秒以上</span></span><br><span class="line">        <span class="keyword">int</span> timeOut = <span class="number">3000</span>;</span><br><span class="line">        <span class="comment">// 当返回值是true时，说明host是可用的，false则不可。</span></span><br><span class="line">        <span class="keyword">boolean</span> status = InetAddress.getByName(ipAddress).isReachable(timeOut);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 直接调用CMD,方法直接将CMD窗口的信息打印出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pingForCMD</span><span class="params">(String ipAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process pro = Runtime.getRuntime().exec(<span class="string">&quot;ping &quot;</span> + ipAddress);</span><br><span class="line">            BufferedReader buf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    pro.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> ((line = buf.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">                System.out.println(line);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 更加完善的调用CMD方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pingTimes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeOut</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">pingForExec</span><span class="params">(String ipAddress, <span class="keyword">int</span> pingTimes, <span class="keyword">int</span> timeOut)</span> </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将要执行的ping命令,此命令是windows格式的命令</span></span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        String pingCommand = <span class="string">&quot;ping &quot;</span> + <span class="string">&quot;-c &quot;</span> + pingTimes + <span class="string">&quot; &quot;</span> + ipAddress;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">// 执行命令并获取输出</span></span><br><span class="line">            System.out.println(pingCommand);</span><br><span class="line">            Process p = r.exec(pingCommand);</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逐行检查输出,计算类似出现=23ms TTL=62字样的次数</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line">            <span class="keyword">int</span> connectedCount = <span class="number">0</span>;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connectedCount += getCheckResult(line);</span><br><span class="line">                <span class="comment">// 如果出现类似=23ms TTL=62这样的字样,出现的次数=测试次数则返回真</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> connectedCount == pingTimes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();   <span class="comment">// 出现异常则返回假</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != in) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 若line含有=18ms TTL=16字样,说明已经ping通,返回1,否則返回0.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> line</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCheckResult</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;控制台输出的结果为:&quot; + line);</span></span><br><span class="line">        String trueZF = <span class="string">&quot;time=&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (line.contains(trueZF)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行的截图如下：</p>
<p>​    成功的：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200615154620793.png" alt="image-20200615154620793"></p>
<p>​    失败的：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200615154550305.png" alt="image-20200615154550305"></p>
<p>​    下面就说说中间的问题。</p>
<p>​    一个是不同的电脑系统，代码中的命令是不一样的，我这里的是Mac os，所以命令和Windows上面的有所不同。</p>
<ul>
<li><p>Mac os（或者Linux）:ping -c 5 127.0.0.1 </p>
</li>
<li><p>Windows： ping 127.0.0.1 -n 5 -w 1000</p>
</li>
</ul>
<p>​    所以不同的系统要拼接的命令也是不一样的。然后就是需要注意最后结果的分析，我这里的代码是直接判断有没有<code>time=</code>,有就是成功了。大家也可以根据自己的需求对延迟做一定对要求，我这里比较简单，就没有写的太复杂。到这里就基本完成了。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><ul>
<li>编译时的类型由声明对象来决定，运行时类型由赋值对象来决定。即编译看左边，运行看右边。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>静态代理：就是在运行前就存在代理的代码，代理类和原始类的关系在运行前就已经确定了。缺点时维护成本高，修改原始类时还要修改代理类。</li>
<li>动态代理：在程序运行期间，通过JVM反射等机制动态的生成代理类的代码，代理类和原始类的关系是在运行后才确定的。</li>
</ul>
<h3 id="反射基础概念"><a href="#反射基础概念" class="headerlink" title="反射基础概念"></a>反射基础概念</h3><p>反射指的是在运行状态中，对于任意一个类能够知道这个类的所有属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectionTrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射小练习</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//通过类的路径来获取Class</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 1 class.forName(&quot;类的路径&quot;)</span></span><br><span class="line"><span class="comment">          * 2 类名.Class</span></span><br><span class="line"><span class="comment">          * 3 实例.getClass</span></span><br><span class="line"><span class="comment">          */</span>          </span><br><span class="line">         Class a=Class.forName(<span class="string">&quot;ReflectionTrain.Sub&quot;</span>);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 1 newInstance: 弱类型。低效率。只能调用无参构造。</span></span><br><span class="line"><span class="comment">          * 2 new: 强类型。相对高效。能调用任何public构造。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         Base b=(Base)a.newInstance();</span><br><span class="line">         <span class="comment">//为什么打印的是 Sub？</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 子类强转为父类，向上转换</span></span><br><span class="line"><span class="comment">          * 通过向上转换，我们能够在编写程序时采用通用程序设计的思想，</span></span><br><span class="line"><span class="comment">          * 在需要使用子类对象的时候，通过把变量定义为父类型，我们可以通过一个变量，使用该父类型的所有子类型实例</span></span><br><span class="line"><span class="comment">          * 子类可以转换为父类，即父类引用指向子类对象。引用的属性是父类的，方法若果被子类重写则是子类的方法。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         b.f();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> * 测试类，测试子类与父类的关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub2</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Sub2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射相关的类：</p>
<ul>
<li>Class类：用来表示类的信息。</li>
<li>Field类：表示类的成员变量。</li>
<li>Method类：表示类的方法。</li>
<li>Constructor类：用来表示类的构造方法。</li>
</ul>
<p>获取Class的三种方法</p>
<p>​    获取Class对象有三种方法：1）通过对象方法。object.getClass();。2）调用类的Class属性，即：Object.class。3）通过Class类中的ForName方法获取，即：Class.forName(“类的全路径”).</p>
<p>​    创建对象的两种方式：调用类的newInstance()方法来创建、通过Class获取Constructor对象，再调用newInstance()方法，这种方法可以选定构造方法。</p>
<p>​    Java有5种方式来创建对象： 1、使用 new 关键字（最常用）： ObjectName obj = new ObjectName(); 2、使用反射的Class类的newInstance()方法： ObjectName obj = ObjectName.class.newInstance(); 3、使用反射的Constructor类的newInstance()方法： ObjectName obj = ObjectName.class.getConstructor.newInstance(); 4、使用对象克隆clone()方法： ObjectName obj = obj.clone(); 5、使用反序列化（ObjectInputStream）的readObject()方法： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }</p>
<h3 id="反射需要注意的"><a href="#反射需要注意的" class="headerlink" title="反射需要注意的"></a>反射需要注意的</h3><ul>
<li>子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。（可以通过反射获取父类的字段）</li>
<li>编译时的类型由声明对象来决定，运行时类型由赋值对象来决定。即编译看左边，运行看右边。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>静态代理：就是在运行前就存在代理的代码，代理类和原始类的关系在运行前就已经确定了。缺点时维护成本高，修改原始类时还要修改代理类。</li>
<li>动态代理：在程序运行期间，通过JVM反射等机制动态的生成代理类的代码，代理类和原始类的关系是在运行后才确定的。</li>
<li>Spring中的IOC使用到了反射，通过反射获取到配置里面类的实例对象，存入到Spring的bean容器中。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><p>​    简单范型的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型练习类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParadigmTrain1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate[] dates = &#123;LocalDate.of(<span class="number">1996</span>, <span class="number">12</span>, <span class="number">9</span>), LocalDate.of(<span class="number">1997</span>, <span class="number">5</span>, <span class="number">15</span>), LocalDate.of(<span class="number">1998</span>, <span class="number">5</span>, <span class="number">15</span>)&#125;;</span><br><span class="line">        Pair&lt;LocalDate&gt; result = minmax(dates);</span><br><span class="line">        System.err.println(result.getFirst());</span><br><span class="line">        System.err.println(result.getSecond());</span><br><span class="line">      	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里可以通过参数的形式来推断出范型的类型，所以不需要输入范型的类型参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>);	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 输入的参数必须要实现Comparable。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> paradigmtrain.Pair&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个范型是对参数进行限制，第二个是返回的类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((a == <span class="keyword">null</span>) || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T min = a[<span class="number">0</span>];</span><br><span class="line">        T max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> aLength = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aLength; i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 比较大小，通过compareTo方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>范型方法类型变量要放在方法修饰符后面，返回类型前面。</li>
<li>范型里面，尖括号里面是类代表一个点，如果带有问号，代表一个范围。</li>
<li>限定列表中如果存在类，则必须为限定列表中的第一个。（接口需要放在类后面）</li>
<li>基本数据类型不能用于范型。</li>
<li>范型的查询只能判断原始类型，例如: <code>a instanceof Pair&lt;String&gt;</code> 只能判断a是否是任意一个类型的Pair。</li>
<li>编译器会将范型类型转换为原始类型（类型擦除），有限定类型就使用第一个限定类型，没有就用object代替。返回类型时，由于返回的为限定类型或者为Object，会将限定类型或者Object强制转换为对应的类型。</li>
<li>不允许创建参数化类型的数组。例如<code>Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]</code> 这样是错误的。（可以通过注解消除这个警告）因为范型擦除的存在，所以会将类型进行擦除，导致存储的元素可能不一致。（存储Integer和String都是可以的）</li>
<li>推荐通过功能性接口（Supplier）来实例化类型变量，反射也可以实现，但是比较麻烦。</li>
<li>不能构造范型数组，例如<code>public static &lt;T&gt; T[] minmax(T[] t)</code>这种写法是错误的。这里也是可以利用函数式接口实现。</li>
<li>范型类中，静态代码中的类型变量无效。（因为类型擦除的原因，返回的Onject不知道转换为那种类型）</li>
<li>不能抛出或者捕获范型类的实例。</li>
<li>范型类之间不存在继承关系，无论S和T什么关系，<code>Pair&lt;S&gt;和Pair&lt;T&gt;不存在继承关系</code></li>
<li>如上面所说，<code>Pair&lt;Object&gt;和Pair&lt;String&gt;</code>不存在继承关系，但是方法中想要使用这样的关系如何写呢？这个时候就要用到通配符类型，即？,代码如下：<code>public static void test(Pair&lt;? extends Object&gt; p)</code>这样就可以传String和Integer.通配符类型上届使用extends，下届用super。上届一般用于读取，下届一般用于写入。</li>
<li>桥方法是为了保持多态，具体的原因如下代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * paradigmTrain3.java</span></span><br><span class="line"><span class="comment"> * Description: 范型方法桥方法练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">paradigmTrain3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base&lt;Date&gt; base = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">//这里调用的应该是setFirst(Date date),但是实际会调用setFirst(Object date)</span></span><br><span class="line">        base.setFirst(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是子类的覆盖方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里编译后会生成一个桥方法，为了维持多态</span></span><br><span class="line"><span class="comment">//    public void setFirst(Object date)&#123;</span></span><br><span class="line"><span class="comment">//        setFirst((Date) date);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul>
<li>封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。</li>
<li>继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。</li>
<li>多态：按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。即父对象可以根据赋值的不同子对象调用不同的方法。即调用子对象重写的方法。</li>
<li>抽象：抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法。即将生活中的万物形容成一个个类。</li>
</ul>
<ul>
<li>类与类之间最常见的关系主要有三种：依赖(uses-a)、聚合(has-a)和继承(is-a)。依赖就是屠夫使用刀、聚合就是大雁组成雁群，大雁相对于雁群是聚合关系（两个不同的类）、继承就是儿子继承父亲的家业。</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>简单的内部类代码：</p>
<ul>
<li>内部类就是定义在一个类中的类，最开始的作用就是简化代码，比较便捷。还有就是内部类完善了多重继承，每个内部类都可以独立继承一个接口的实现，但是感觉相对于它所带来的复杂程度而言，带来的便捷性其实不是很好，也可能是我学的比较浅。</li>
<li>内部类对象有一个隐式的引用，指向了实例化该内部类对象的外部类对象。</li>
<li>不需要内部类引用外部类的时候，可以使用静态内部类。</li>
<li>静态内部类创建实例的形式和普通内部类不太一样 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通内部类</span></span><br><span class="line">Out out=<span class="keyword">new</span> Out();</span><br><span class="line">out.in in=out.<span class="function">new <span class="title">in</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line">Out.In in=<span class="keyword">new</span> Out.In();</span><br></pre></td></tr></table></figure>

<ul>
<li>双括号初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双括号的使用方法，匿名列表，适用于只使用一次的数组列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;String&gt; test = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;hah&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><ul>
<li><p>成员内部类</p>
<ul>
<li>成员内部类不能使用static方法和变量</li>
<li>只有创建了外部类才能创建内部类</li>
</ul>
</li>
<li><p>局部内部类</p>
<ul>
<li>可以引用局部变量，但是局部变量必须声明为final（jdk1.8之前）</li>
</ul>
</li>
<li><p>匿名内部类</p>
<ul>
<li>匿名内部类不能有构造方法（构造方法必须和类名相同）</li>
<li>匿名内部类没有访问修饰符</li>
</ul>
</li>
<li><p>静态内部类</p>
<ul>
<li>静态内部类只能访问外部类的静态成员和方法</li>
<li>静态内部类的创建不需要依赖于外部类的对象</li>
</ul>
</li>
</ul>
<h2 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h2><ul>
<li><code>==</code>当两边的是基本类型时，对比的是值，当两边是引用类型时，比较的内存地址。当两边一个基本一个引用时，因为Java自动拆包，所以也是判断值是否相等。</li>
<li>count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0。</li>
<li>非new生成的Integer和new生成的Integer结果只能为false，两个非new比较时，都在-128-127内，比较值，否则比较地址。</li>
<li>+=会自动装箱，将运算的结果转换为相应的类型。<code>byte a = 127;byte b = 126;b = a + b;(错误) b+=a;(正确)</code></li>
<li>自动装箱只能装相应的类型，没法自动转换。</li>
<li>三元运算符会自动做类型提升。</li>
<li>&amp;是逻辑与，会计算两边的等式，&amp;&amp;是短路与，某些情况下只计算左边的等式。｜和｜｜的区别类似。</li>
<li>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。</li>
<li>while循环就是当条件不满足时，跳出，无论while还是dowhile，只不过dowhile第一次无论如何都会执行。</li>
<li>如果不加break，是从case语句匹配的位置往下一直执行</li>
<li>取余取头，取模取尾。java中的%是取余运算，看头。即最后结果的符号看运算符的前面还是后面。</li>
<li>同名方法，不同参数是重载，父类和子类之间是重写。</li>
<li>重写方法时，访问权限不能比父类中被重写的方法的访问权限更低，父类为public，子类不能为private。</li>
<li>编译看左边，运行看右边。 ClassA a = new ClassB();编译时为ClassA，运行时为ClassB。</li>
<li>finally是在return执行之后，语句返回之前执行的。</li>
<li>二维数组定义，一维长度必须定义，二维可以后续定义。</li>
<li>类中的变量可以不用初始化，但是方法中的变量声明后一定要初始化。</li>
<li>try块后面可以不加catch块，但是必须要有finally和catch之一。</li>
<li>Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整。</li>
<li>str.split(&quot;,&quot;)方法是把str字符串根据分割符&quot;,&quot;划分成一个字符串数组，如果str字符串中找不到分隔符&quot;,&quot;，则把整个str字符串放入字符</li>
<li>replaceAll方法的第一个参数是一个正则表达式，.代表所有字符。</li>
<li>如果字符串长度没有初始化长度大，capacity返回初始化的长度，如果append后的字符串长度超过初始化长度，capacity返回增长后的长度。</li>
<li>JSP中：application可以被web应用程序访问，session可以被同一对话访问，request可以被同一请求访问，pageContext可以被当前页面访问。</li>
<li>子类抛出的异常不能比父类的更加广泛，更加广泛的异常类的catch块要放在下面。</li>
<li>所有的异常都是继承Throwable，下层分为Error和Exception，Error描述了Java运行时系统的内部错误和资源耗尽错误。Exception分为运行时异常和其他异常。</li>
<li>Error和Exception都是集成Throwable,其中Exception又被IOException和RuntimeException继承。</li>
<li>枚举类默认的toString方法会将字符串打印出来。</li>
<li>串数组的第一个元素。</li>
<li>静态代码块可以分开写。</li>
<li>导包只可以导到当前层。</li>
<li>包装类的值都是不可变的。</li>
</ul>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><ul>
<li>抽象类是类的抽象化，接口则是抽象方法的集合。抽象类可以被实现类继承，接口则只能被实现类实现。抽象类是自下而上的设计理念，接口则是自上而下的设计理念。两个都不能被实例化。</li>
<li>接口就是在不同层面对一类事物的抽象描述。例如：在生物层面，人和猪都是会吃东西的。但是不同的层面，人和猪可能就不是同一类事物。</li>
<li>抽象类可以存在普通成员变量和静态成员变量，也可以存在静态方法和构造方法、普通方法。接口可以存在成员变量，但都是静态的。接口在1.8之后可以定义静态方法。</li>
</ul>
<h2 id="继承相关的"><a href="#继承相关的" class="headerlink" title="继承相关的"></a>继承相关的</h2><ul>
<li>在构造方法中如果使用关键字 <code>this</code> 调用其他构造方法，则 <code>this(参数列表)</code> 语句必须出现在其他语句之前。super是调用父类的某个构造函数，也必须在第一行。两者不能同时出现在一个函数里面。两者都不能在static中使用。</li>
<li>不会初始化子类的几种、调用的是父类的static方法或者字段、调用的是父类的final方法或者字段、通过数组来引用。</li>
<li>如果构造方法没有显式地调用同一个类中其他的构造方法或父类的构造方法，将隐性地调用父类的无参数构造方法，即编译器会把 <code>super()</code> 作为构造方法的第一个语句。</li>
<li>静态代码块只执行一次，构造代码块只要创建对象就会执行。</li>
<li>java语言是静态多分派，动态单分派的。 如果是重载方法之间的选择，则是使用静态类型。 如果是父类与子类之间的重写方法的选择，则是使用动态类型。 如A a = new B(); 会使用类型B去查找重写的方法，使用类型A去查找重载的方法。</li>
</ul>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>byte的数值为-128-127，因为-0表示为128</p>
<ul>
<li><p>原码：计算机中将一个数字转换为二进制，并在其最高位加上符号的一种表示方法。</p>
</li>
<li><p>反码：根据表示规定，正数的反码就是本身，而负数的反码，除符号位外，其余位依次取反。</p>
</li>
<li><p>补码：根据表示规定，正数的补码就是本身，而负数的补码，是在其反码的末位加1。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h3 id="并发的基本特性"><a href="#并发的基本特性" class="headerlink" title="并发的基本特性"></a>并发的基本特性</h3><ul>
<li>并行指多个cpu同时执行多个任务，并发是指一个cpu按照时间片轮流执行多个任务。</li>
<li>进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。例如qq就是操作系统中的一个进程。切换进程的开销比较大。线程是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个进程内部可能存在多个线程。线程的切换开销要比进程小的多。qq上面能够同时听音乐和看视频就是不同的线程。</li>
<li>并发的三个特点：原子性、可见性、有序性。原子性是指一个线程内的多个操作要么全部执行，要么都不执行。可见性是指当一个线程修改了一个变量的值时，其他线程要立即看到修改的值。有序性指代码在机器中的执行顺序和代码的编写顺序一致。</li>
<li>线程池整体流程：首先设置核心线程数和最大线程数，然后提交任务，任务小于核心线程数时，是慢慢创建线程执行任务的，当执行的任务超过了核心线程数，就将后续的任务放入队列中，当队列满了时，创建非核心线程。当峰值过了后，将非核心线程数超时销毁。如果更多，就直接执行拒绝策略，通知任务提交失败，执行失败后的方法。</li>
<li>饿汉单例模式和双检锁单例模式是线程安全的，懒汉式线程模式是线程非安全的。</li>
</ul>
<h3 id="关于锁"><a href="#关于锁" class="headerlink" title="关于锁"></a>关于锁</h3><ul>
<li>死锁：两个或两个以上的线程在执行过程中，因为争夺对方手中的资源而导致相互等待的现象。比如AB两个线程，A线程拿到1资源，B线程拿到2资源。互相需要对方的21资源，结果两个线程都在等待，造成死锁。</li>
<li>死锁的解决办法。1）让线程步骤一致的获取资源。2）让多个线程尽量不要获取相同的资源。3）如果发现自己需要的资源上锁了，放弃手中的资源，再等待。</li>
<li>synchronized的实现：每一个对象都有一个锁，并且该锁也只有一个内部条件。如果使用synchronized声明方法，该对象的锁就会保护整个方法。静态方法也可以使用synchronized声明，声明后，其他线程无法使用这个类的全部静态方法。普通方法和其他静态方法仍然可以使用。synchronized无论执行完毕或者抛出异常，都会放弃锁。</li>
<li>synchronized和Lock的区别：Lock可以设定超时时间、synchronized无法获得锁的状态，Lock获取锁时会给失败还是成功、synchronized锁的条件比较单一。synchronized使用的是非公平锁，Lock支持非公平锁（默认）和公平锁。</li>
<li>volatile不能保证数据的修改具有原子性。只能保证可见性和有序性。线程1修改一个共享变量时，JVM 会把该线程1对应的本地内存中的共享变量值立即刷新到主内存。当线程2读取时，JMM 会把该线程2对应的本地内存置为无效。线程2接下来将从主内存中读取共享变量。有序性就是代码不会被重新编排。</li>
<li>Happens-Before原则就是为了解决可见性的问题，制定了8个原则，这8个原则梳理出分割线，给程序的运行制定了指导方向。程序顺序规则、锁定规则、volatile变量规则、线程启动规则、线程结束规则、中断规则、终结器规则、传递性规则。</li>
<li>synchronized和volatile的区别：voaltile只能用在变量级别，synchronized可以用在方法和类上。volatile只能保证变量的可见性和有序性，不能保证原子性，synchronized可以保证原子性。volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>悲观锁就是在修改数据的时候默认其他线程也会修改，所以在修改数据时会上锁，修改完毕后将锁释放。乐观锁就是修改数据时默认其他线程不会修改数据，修改完毕后要更新时，如果发现数据被修改了，丢弃自己的操作，如果没有修改，则执行更新。</li>
<li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。但是CAS存在ABA问题，即线程修改为B后又修改回A。可以通过添加版本号的形式来解决这个问题。</li>
<li>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li>
<li>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li>
<li>阻塞队列的流程如下：许多线程向阻塞队列中取出指令并且执行相应命令，如果有生产者插入队列中新的元素但是队列长度已经满了，生产者的插入就会被阻塞。消费者移除一个元素时，阻塞队列如果为空，移除操作也会阻塞。</li>
<li>原子操作意为不可中断的一个操作。在Java中通过锁和循环CAS实现原子操作。原子类有很多，例如AtomicInterge、AtomicArray。</li>
<li>ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。</li>
<li>CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转，翻译成人话就是循环，一般是用一个无限循环实现。这样一来，一个无限循环中，执行一个 CAS 操作，当操作成功，返回 true 时，循环结束；当返回 false 时，接着执行循环，继续尝试 CAS 操作，直到返回 true。</li>
<li>AQS是指抽象队列的同步器。定义了一套多线程访问共享资源的同步框架，</li>
</ul>
<h3 id="关于集合中的线程安全问题"><a href="#关于集合中的线程安全问题" class="headerlink" title="关于集合中的线程安全问题"></a>关于集合中的线程安全问题</h3><ul>
<li><p>HashMap是线程不安全的，它的不安全主要体现在扩容时，因为多个线程的操作，可能会导致环链，即头尾向连，无限循环。具体的实现原理可以看集合那一篇。</p>
</li>
<li><p>ConcurrentHashMap是线程安全的。它是通过分段锁的形式来解决并发读写的问题的。多个线程读写不同的Segment，是没有影响的。AB同时读写同一个Segment，也是没有影响的。AB同时写，会导致AB中间一个阻塞。保证可见性则是使用voliate关键字。ConcurrentHashMap是采用CAS+Synchronized来实现锁的。segment的多少也指ConcurrentHashMap的并发度，一般是16.</p>
</li>
<li><p>String效率较低，StringBuffer和StringBuilder修改频繁时效率较高并且占用内存少，前者线程线程安全，后者多线程状态下可能会出现问题。</p>
</li>
<li><p>SynchronizedMap是通过锁住一整张表来实现线程安全的，效率相对于ConcurrentHashMap很低。</p>
</li>
<li><p>CopyOnWriteArrayList，写数组的拷贝，支持高效率并发且是线程安全的,读操作无锁的ArrayList。所有可变操作都是通过对底层数组进行一次新的复制来实现。CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里。</p>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>实现原理：每个线程都有一个ThreadLocalMap，这个map的key就是弱引用指向的ThreadLocal对象，value就是你要放入值。每个线程都可以获取自己线程独有的map，从而获取对应ThreadLocal对象的值。也就是value。</p>
<p>可能出现的问题：可能出现的问题就是内存溢出。因为Thrad中map存放的key是弱引用，所以在垃圾回收的时候会将这个弱引用回收，导致key为null。无法获取value，时间长了，慢慢就会导致内存溢出。可以在使用完毕后，调用remove方法解决这个问题，同时在ThreadLocal的get方法也会清楚nullkey。</p>
<p>缓存</p>
<p>当ThreadLocal不用时，将其置为空，因为Thread中的map的key是弱引用，所以在下一次垃圾回收时，会直接将这个对象回收，避免造成内存溢出。如果强引用的话，因为key一直指向ThreadLocal，所以一直不会回收。</p>
<p>当key为null时，这个时候无法访问到value，所以可能会造成内存溢出。可以通过remove方法来避免。本身调用get方法到时候也会将null值回收。</p>
<h3 id="HashMap中存在的线程安全问题"><a href="#HashMap中存在的线程安全问题" class="headerlink" title="HashMap中存在的线程安全问题"></a>HashMap中存在的线程安全问题</h3><p>​    安全问题有几点：扩容时出现链表死循环的现象、扩容的时候出现数据丢失的情况、size在多线程操作的时候也会出现不正确的情况、put方法时，hash冲突会出现数据丢失的情况。</p>
<p>​    负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p>
<p>hashmap如何putnull值，会将这个元素放在第0个坐标。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7/</url>
    <content><![CDATA[<h1 id="卷二"><a href="#卷二" class="headerlink" title="卷二"></a>卷二</h1><h2 id="第1章-Java-SE-8的流库"><a href="#第1章-Java-SE-8的流库" class="headerlink" title="第1章 Java SE 8的流库"></a>第1章 Java SE 8的流库</h2><ul>
<li>流和集合的区别<ul>
<li>流并不存储元素</li>
<li>流的操作不会修改其数据源</li>
<li>流的操作是尽可能惰性执行        </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String wordsString = <span class="keyword">new</span> String(Files.readAllBytes(Paths.get(<span class="string">&quot;/Users/Desktop/dev/aaa.txt&quot;</span>)), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">//以非字母分隔符</span></span><br><span class="line">    List&lt;String&gt; wordsList = Arrays.asList(wordsString.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用迭代的方式查询大于12的单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String word : wordsList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt; <span class="number">12</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">&quot;使用迭代的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用流的方式查询大于12的单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//单线程运行</span></span><br><span class="line">    count = wordsList.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br><span class="line">    System.err.println(<span class="string">&quot;使用单线程的流的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">//多线程运行</span></span><br><span class="line">    count = wordsList.parallelStream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br><span class="line">    System.err.println(<span class="string">&quot;使用多线程的流的方式来统计大于十二的单词&quot;</span> + count);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流是使用stream和parallelStream方法来创建的，filter方法用来对流进行转化，count</span></span><br><span class="line"><span class="comment">     * 方法用来终结操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>流的创建方法<br>  JavaAPI中有大量的方法可以产生流，这里不再全部叙述，也不太现实。就直接以一个demo的形式叙述一下我了解的创建流的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> streamtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SetUpStream.java</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetUpStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;/Users/pengshiquan/Desktop/dev/aaa.txt&quot;</span>);</span><br><span class="line">        String wordsString = <span class="keyword">new</span> String(Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">        String[] arrayString = &#123;<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;ddd&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream方法创建流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(wordsString);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream1 = Stream.of(<span class="string">&quot;hahah&quot;</span>, <span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;Stream.of&quot;</span>, stringStream1);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Array.stream(array,from,to)可以创建一个流，从数组中的from到to</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream2 = Arrays.stream(arrayString, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        show(<span class="string">&quot;Arrays.stream&quot;</span>, stringStream2);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream.empty()用来创建一个不包含任何元素的流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream3 = Stream.empty();</span><br><span class="line">        show(<span class="string">&quot;Arrays.stream&quot;</span>, stringStream3);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Stream两个创建无限流的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//使用lambda表达式重写Supplier&lt;T&gt;函数表达式</span></span><br><span class="line">        Stream&lt;String&gt; stringStream4 = Stream.generate(() -&gt; <span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;Stream.generate&quot;</span>, stringStream4);</span><br><span class="line">        <span class="comment">//lambda表达式中的实例方法引用</span></span><br><span class="line">        Stream&lt;Double&gt; stringStream5 = Stream.generate(Math::random);</span><br><span class="line">        show(<span class="string">&quot;Stream.generate&quot;</span>, stringStream5);</span><br><span class="line">        <span class="comment">// 前面是种子，反复调用函数，应用到之前到结果上    顺序如下： 0，1，2，3，4</span></span><br><span class="line">        Stream&lt;BigInteger&gt; integerStream = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br><span class="line">        show(<span class="string">&quot;Stream.iterate&quot;</span>, integerStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * pattern中的splitAsStream方法将字符串分割为一个一个单词</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;String&gt; stringStream6 = Pattern.compile(<span class="string">&quot;a&quot;</span>).splitAsStream(wordsString);</span><br><span class="line">        show(<span class="string">&quot;splitAsStream&quot;</span>, stringStream6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回一个包含了文件所有行的stream</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; stringStream7 = Files.lines(path, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            show(<span class="string">&quot;Files.lines&quot;</span>, stringStream7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 添加了&lt;T&gt;的展示方法，添加&lt;T&gt;可以使得方法参数类型不受对象范型类限制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/4/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(String title, Stream&lt;T&gt; stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">        List&lt;T&gt; headList = stream.limit(SIZE + <span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">        System.err.print(title + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (T t : headList) &#123;</span><br><span class="line">            System.err.print(t);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对流的操作的方法</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ul>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口，实现run方法。</li>
<li>使用Callable和Future创建线程。主要就是让线程有返回值，线程也可以抛出异常了。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的第三种方法，使用Callable和Future创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">//创建Callable对象  1</span></span><br><span class="line">      demo3 rt=<span class="keyword">new</span> demo3();</span><br><span class="line">      <span class="comment">//先使用Lambda表达式创建Callable&lt;Integer&gt;对象  1</span></span><br><span class="line">      <span class="comment">//使用Futuretask来包装Callable对象</span></span><br><span class="line">      FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">         <span class="comment">//这里的方法相当于call()方法    1 call()方法可以有返回值  2 call()方法也可以声明抛出异常 </span></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//通过currentThread()来获得当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//返回值</span></span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//主线程</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//实质还是Callable对象创建线程的，执行者还是Thread</span></span><br><span class="line">            <span class="keyword">new</span> Thread(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//也可以获取异常</span></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//获取子线程的返回值get()方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot;子线程的返回值为：&quot;</span>+task.get());</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">         ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现Runnbale接口和Callable接口获取当前线程都需要调用<code>Thread.currentThread()</code>方法。</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。通过Future可以了解任务的执行情况和任务是否完成、也可以取消任务。</li>
</ul>
<h3 id="线程的状态流转图"><a href="#线程的状态流转图" class="headerlink" title="线程的状态流转图"></a>线程的状态流转图</h3><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210510164508318.png" alt="image-20210510164508318"></p>
<p>​    一个线程刚开始创建就是new状态，只是简单的赋值，没有什么其它操作。调用线程的start方法后，线程进入运行态，如果此时的线程没有什么其它要求，就只是简单打印一句话，线程执行完毕后就进入了终止态。但是如果有特殊情况，它在语句中调用了object.wait()，这时它会进入等待状态，同时也进入了等待队列，就是waiting，另外一个线程如何调用了这个对象的notify()方法，最开始进入等待状态的线程会重新获取锁，进入运行态。如何这个时候等待锁的线程比较多，没有获取到的就进入阻塞状态，也就进入到了同步队列，一直等待获取到锁，然后进入运行态。还有一个状态就是超时等待状态，以线程的sleep方法为例，线程运行中执行这个方法，睡眠10秒，然后线程就进入了这个状态，10秒过完后，就再次回到运行态。但是这里不会放弃锁，会一直保持。</p>
<ul>
<li>所有的状态都是先进入就绪态，再进入运行中。</li>
<li>sleep方法不会放弃锁。</li>
<li>线程不能抛出任何异常，遇到异常，应该设置异常处理器。将异常的信息打印到日志中或者后续处理。</li>
<li>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。线程状态为可运行态。</li>
<li>Thread.join方法会让当前线程进入到等待状态，执行t，完毕后再执行当前线程。本质仍然是执行了 wait() 方法，而锁对象就是 Thread t 对象本身。</li>
<li>park和unpark实现的原理则是使用线程内部的计数器。</li>
<li>用 jdk 的 Lock 接口中的 lock，如果获取不到锁，线程将挂起，状态则变为等待状态。</li>
<li>jdk 中锁的实现，是基于 AQS 的，而 AQS 的底层，是用 park 和 unpark 来挂起和唤醒线程。</li>
</ul>
<h3 id="线程池相关知识点"><a href="#线程池相关知识点" class="headerlink" title="线程池相关知识点"></a>线程池相关知识点</h3><p>​    创建一个线程池，现在里面没有任何运行的线程。提交一个任务，如果小于核心线程数，会一直创建新的核心线程。直到核心线程数满了，线程池还有一个任务队列，核心数满了后，会将提交的任务放到任务队列里面。当任务队列也满了后，会创建非核心线程数，当非核心线程数也满了后，就会走拒绝策略，将后面提交的任务全部拒绝。当非核心线程慢慢没有任务后，过一段时间就会对非核心线程进行销毁。核心线程则会一直运行中。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210607200224525.png" alt="image-20210607200224525"></p>
<ul>
<li>但是，敦促程序员使用更方便的Executors工厂方法Executors.newCachedThreadPool （无边界线程池，具有自动线程回收）， Executors.newFixedThreadPool （固定大小的线程池）和Executors.newSingleThreadExecutor （单个后台线程），这些方法可以预先配置设置。</li>
<li>当在方法execute(Runnable)提交新任务，并且正在运行的线程少于corePoolSize线程时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理请求。 如果运行的线程数大于corePoolSize但小于maximumPoolSize，则仅在队列已满时才创建新线程。 通过将corePoolSize和maximumPoolSize设置为相同，可以创建固定大小的线程池。 通过将maximumPoolSize设置为一个本质上不受限制的值（例如Integer.MAX_VALUE ，可以允许池容纳任意数量的并发任务。 最典型地，核心和最大池大小仅在构造时设置，但也可以使用setCorePoolSize和setMaximumPoolSize动态更改。</li>
<li>使用ThreadFactory创建新线程。 如果没有另外指定，则使用Executors.defaultThreadFactory ，该线程创建的线程全部位于相同的ThreadGroup并且具有相同的NORM_PRIORITY优先级和非守护程序状态。 通过提供其他ThreadFactory，可以更改线程的名称，线程组，优先级，守护程序状态等。如果ThreadFactory在从newThread返回null返回要求时未能创建线程，执行器将继续执行，但可能无法执行执行任何任务。 线程应具有“ modifyThread” RuntimePermission 。 如果使用该池的工作线程或其他线程不具有此许可权，则服务可能会降级：配置更改可能不会及时生效，并且关闭池可能保持在可能终止但未完成的状态。</li>
<li>如果当前池中的线程数超过corePoolSize，则多余的线程将在空闲时间超过keepAliveTime时终止（请参见getKeepAliveTime(TimeUnit) ）。 当不积极使用池时，这提供了一种减少资源消耗的方法。 如果池稍后变得更活跃，则将构建新线程。 也可以使用setKeepAliveTime(long, TimeUnit)方法动态更改此参数。 使用Long.MAX_VALUE TimeUnit.NANOSECONDS的值Long.MAX_VALUE有效地使空闲线程永远不会在关闭之前终止。 默认情况下，仅当corePoolSize线程数多时，保持活动策略才适用。 但是，只要keepAliveTime值不为零，方法allowCoreThreadTimeOut(boolean)还可用于将此超时策略应用于核心线程。</li>
<li>有三种一般的排队策略：<ul>
<li>直接交接。 工作队列的一个很好的默认选择是SynchronousQueue ，它可以将任务移交给线程，而不必另外保留它们。 在这里，如果没有立即可用的线程来运行任务，则尝试将任务排队的尝试将失败，因此将构造一个新线程。 在处理可能具有内部依赖项的请求集时，此策略避免了锁定。 直接切换通常需要无限制的maximumPoolSizes以避免拒绝新提交的任务。 反过来，当平均而言，命令继续以比其可处理的速度更快到达时，这可能会带来无限线程增长的可能性。</li>
<li>无限队列。 使用无界队列（例如，没有预定义容量的LinkedBlockingQueue ）将在所有corePoolSize线程繁忙时使新任务在队列中等待。 因此，将仅创建corePoolSize线程。 （因此，maximumPoolSize的值没有任何作用。）当每个任务完全独立于其他任务时，这可能是适当的，因此任务不会影响彼此的执行。 例如，在网页服务器中。 尽管这种排队方式对于消除短暂的请求突发很有用，但它承认当命令平均继续以比处理速度更快的速度到达时，无限制的工作队列增长是可能的。</li>
<li>有界队列。 当与有限的maximumPoolSizes一起使用时，有界队列（例如ArrayBlockingQueue ）有助于防止资源耗尽，但调优和控制起来会更加困难。 队列大小和最大池大小可能会相互折衷：使用大队列和小池可以最大程度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为地降低吞吐量。 如果任务频繁阻塞（例如，如果它们受I / O约束），则系统可能能够安排比您原先允许的线程更多的时间。 使用小队列通常需要更大的池大小，这会使CPU繁忙，但可能会遇到无法接受的调度开销，这也会降低吞吐量</li>
</ul>
</li>
<li> 在任一情况下， execute方法调用RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)其的方法RejectedExecutionHandler 。 提供了四个预定义的处理程序策略：</li>
<li>在默认的ThreadPoolExecutor.AbortPolicy ，处理程序在拒绝时会抛出运行时RejectedExecutionException 。</li>
<li>在ThreadPoolExecutor.CallerRunsPolicy ，调用execute自己的线程运行任务。 这提供了一种简单的反馈控制机制，该机制将减慢新任务的提交速度。</li>
<li>在ThreadPoolExecutor.DiscardPolicy ，简单地删除了无法执行的任务。</li>
<li>在ThreadPoolExecutor.DiscardOldestPolicy ，如果未关闭执行程序，则将丢弃工作队列开头的任务，然后重试执行（该操作可能再次失败，导致重复执行此操作）。</li>
</ul>
<h4 id="参数讲解"><a href="#参数讲解" class="headerlink" title="参数讲解"></a>参数讲解</h4><ul>
<li><p>corePoolSize – 要保留在池中的线程数，即使它们处于空闲状态，除非设置了allowCoreThreadTimeOut</p>
</li>
<li><p>maximumPoolSize – 池中允许的最大线程数</p>
</li>
<li><p>keepAliveTime – 当线程数大于核心数时，这是多余空闲线程在终止前等待新任务的最长时间。</p>
</li>
<li><p>unit – keepAliveTime参数的时间单位</p>
</li>
<li><p>workQueue – 用于在执行任务之前保存任务的队列。 这个队列将只保存execute方法提交的Runnable任务。</p>
</li>
<li><p>threadFactory – 执行程序创建新线程时使用的工厂</p>
</li>
<li><p>handler – 执行被阻塞时使用的处理程序，因为达到了线程边界和队列容量。</p>
</li>
<li><p>线程池的状态：</p>
<ul>
<li>RUNNING：接受新任务并处理排队的任务</li>
<li>SHUTDOWN：不接受新任务，但处理排队的任务</li>
<li>STOP：不接受新任务，不处理排队的任务，并中断进行中的任务</li>
<li>TIDYING：所有任务都已终止，workerCount为零，线程转换到TIDYING状态将运行Terminated（）挂钩方法。</li>
<li>TERMINATED：terminald（）已完成。</li>
</ul>
</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>execute(Runnable command)：在未来的某个时间执行给定的任务。</li>
<li>shutdown()：启动有序关闭，其中执行先前提交的任务，但不会接受新任务。 如果已经关闭，调用没有额外的效果。</li>
<li>shutdownNow() ：尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表。 </li>
<li>submit():提交一个返回值的任务以供执行，并返回一个表示任务未决结果的 Future.</li>
</ul>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadPoolTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 线程池练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executorService = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            TestTask testTask = <span class="keyword">new</span> TestTask(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            executorService.execute(testTask);</span><br><span class="line">            System.err.println(<span class="string">&quot;当前线程池核心线程数：&quot;</span> + executorService.getPoolSize());</span><br><span class="line">            System.err.println(<span class="string">&quot;队列中等待的任务数为：&quot;</span> + executorService.getQueue().size());</span><br><span class="line">            <span class="comment">//返回已完成执行的大致任务总数。</span></span><br><span class="line">            System.err.println(<span class="string">&quot;当前线程池完成的任务数为：&quot;</span> + executorService.getCompletedTaskCount());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;当前正在执行线程：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;线程：&quot;</span> + name + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试的问题"><a href="#面试的问题" class="headerlink" title="面试的问题"></a>面试的问题</h3><ul>
<li>等待状态和阻塞状态的区别</li>
</ul>
<p>​    线程的等待状态是主动的，自己调用wait方法将线程切换为等待状态，并且这个时候也会占用cpu，阻塞状态是被动的，获取不到锁就变成阻塞状态，这个时候会放弃cpu的执行权，等待某个时间将其唤醒。</p>
<ul>
<li>重复调用start方法会怎么样？</li>
</ul>
<p>​    会抛出异常，就在start方法的第一行，判断状态如果不是new的话，会直接抛出一个异常。</p>
<ul>
<li>线程池的创建方式有几种</li>
</ul>
<p>​    创建线程池第一种就是自定义创建，指定参数，创建线程池。还有一种就是通过Executors工具类创建指定好的线程池。一般三种类型的，线程数没有限制的、线程数固定大小的、线程数为一个的。看自己业务的需求，但是阿里的编码规范里面说不要使用工具类创建，是为了防止内存溢出。不知道我们公司线程池的使用是那种方式？</p>
<ul>
<li>线程池的拒绝策略有哪些？</li>
</ul>
<p>​    我了解的拒绝策略有一下啊几种：1.队列满了后直接抛出异常。2.无法执行的任务丢弃掉。3.使用调用者线程执行任务，这样能够减慢任务的提交速度。4.将队列头部的任务丢弃掉。</p>
<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Java线程深入学习"><a href="#Java线程深入学习" class="headerlink" title="Java线程深入学习"></a>Java线程深入学习</h2><p>​    上一篇博客讲了一下并发，但是没有达到自己的效果，所以这篇博客想从上一篇博客中的线程讲起，打算写一篇有着自己风格和能够让自己满意的博客。也是想深入了解一下线程的工作原理。</p>
<p>​    线程是程序中的执行线程。 Java虚拟机允许应用程序具有多个并发运行的执行线程。Java创建线程有两种方式（Java文档中这样说的，网上说应该还有一种,总共三种）一种是继承<code>Thread</code>类，一种是实现<code>Runnable</code>接口。下面先就第一种创建方法来说一下线程具体的流程。现在上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一种创建线程的方法，通过继承Thread类创建线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;<span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//run方法就是线程执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当线程类继承Thread类时，直接使用this可以获得当前线程</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//获取当前线程的名字</span></span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 运行的时候发现main的i不一定会到20，线程的启动是计算机调度的，具有一定的随机性</span></span><br><span class="line"><span class="comment">             * 两个子线程的i不是共享的，不会连续打印</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//currentThread()总是返回当前正在执行的线程对象</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">//通过start()方法启动第一个线程</span></span><br><span class="line">                <span class="keyword">new</span> demo1().start();</span><br><span class="line">                <span class="comment">//启动第二个线程</span></span><br><span class="line">                <span class="keyword">new</span> demo1().start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    最后运行的截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210112173640626.png" alt="image-20210112173640626">    </p>
<p>​    基础的知识就不再详细介绍了，继承<code>Thread</code>类，重写<code>run()</code>方法，通过调用该类对象的<code>start()</code>方法（不是<code>run(</code>)方法）来启动线程。剩下就没有什么需要讲解的了，但是这篇博客是深入了解线程，所以会继续深挖一下，了解背后的原理。下面就开始阅读线程类的源码。</p>
<p>​    上面的过程涉及了几个地方，一个是创建一个对象，一个就是调用了<code>start()</code>方法。下面就一步一步来，先是new了一个对象，看到源码中是调用了初始化方法，只是初始化了线程的相关设置，和我们的关系好像不大。（其中涉及的感觉都是JVM相关的东西）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210112175323837.png" alt="image-20210112175323837"></p>
<p>​    下面就是<code>start()</code>方法了，先看该方法的介绍，显示该方法会使线程开始执行，Java虚拟机将会调用此线程的run方法，结果是产生两个线程（调用start方法的线程和执行run方法的线程），线程一旦完成就可能不会重启。再来看代码，发现代码不是很复杂：将该线程放入线程组，再调用<code>start0()</code>方法，然后到这里就断了，这里就调用了底层C的代码，再看下去就不是很容易懂了。好像到这里就暂时断了。</p>
<p>​    回过头来，就不难发现为什么线程的名称是<code>Thread-0</code>,因为初始化时没有传参所以系统给默认的了。同时也能解释代码中注释的疑问：运行次数多不难发现，不一定运行到20就开始打印子线程？和主线程的打印和子线程是随机不确定间隔打印的。（因为线程的启动时随机的，主线程和子线程是两个独立的线程）</p>
<p>​    下面就来看看创建线程的第二种方式。实现<code>Runnable</code>接口，直接上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建线程的第二种方法</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i;<span class="comment">//初始值为0</span></span><br><span class="line">   <span class="comment">//线程执行体</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//当实现Runnable接口时，只能使用Thread.currentThread().getName()获得当前线程</span></span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            demo2 dt=<span class="keyword">new</span> demo2();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 最终的执行者还是Thread</span></span><br><span class="line"><span class="comment">             * 发现新线程1和新线程2的i值是连续的，因为Thread共享了同一个target(就是Runnable对象)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//通过new Thread(target,name)来创建新线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(dt,<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dt,<span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码也是比较简单，但是创建线程这里不太一样，通过创建实现了Runnable接口的对象，但是实际还是调用Thread线程类的<code>start()</code>方法。看源码发现虽然调用的是不同的构造函数，但是最后调用的都是同一个初始化函数，而且传入的Runnable好像也没有用到，只是赋值了一下，就不再处理，那使用接口和不使用接口有什么区别呢？继续阅读源码。</p>
<p>​    如果实现接口，代码中并没有重写Thread类的<code>run()</code>方法，只是重写了Runnable的<code>run()</code>方法，回到Thread类的run方法，发现有这样的代码。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210113174447700.png" alt="image-20210113174447700"></p>
<p>​    这样就明白了，Thread是先调用Runnable的run方法，也就是说线程的创建还是在Thread中，Runnable只是将自己作为接口放到了Thread的上面。回到最上面也可以看到Thread是实现了Runnable接口的。Runnable接口也比较简单，就只有一个run方法。</p>
<p>​    回到刚才的问题，使用接口和继承Thread有什么区别，其实就是代码为什么这样设计的问题。看了一下Runnable的文档，如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210113175122171.png" alt="image-20210113175122171"></p>
<p>​        说白了，就是更加的灵活，Thread有一千行代码，其中很多代码可能是大家用不到的，这样也体现了一种思想，去除无用（自己想的）。让代码中尽量少一些无用代码。</p>
<p>​    代码其实比较简单，但是其中的一些设计思想需要消化一下。能力有限，只能考虑到这些，欢迎大家补充。</p>
<p>​    最后来看一下网上说的第三种创建线程的方式，使用Callable和Future创建线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的第三种方法，使用Callable和Future创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">//创建Callable对象  1</span></span><br><span class="line">      demo3 rt=<span class="keyword">new</span> demo3();</span><br><span class="line">      <span class="comment">//先使用Lambda表达式创建Callable&lt;Integer&gt;对象  1</span></span><br><span class="line">      <span class="comment">//使用Futuretask来包装Callable对象</span></span><br><span class="line">      FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">         <span class="comment">//这里的方法相当于call()方法    1 call()方法可以有返回值  2 call()方法也可以声明抛出异常 </span></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//通过currentThread()来获得当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//返回值</span></span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//主线程</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">         <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//实质还是Callable对象创建线程的，执行者还是Thread</span></span><br><span class="line">            <span class="keyword">new</span> Thread(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//也可以获取异常</span></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//获取子线程的返回值get()方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot;子线程的返回值为：&quot;</span>+task.get());</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">         ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    按照上面的方式继续阅读这段代码，不难发现<code>FutureTask&lt;V&gt;</code>其实是实现了Runnable的子类，这样的话和第二种方法就没有什么区别，这里也不再继续跟进。所以最开始文档中说的对，实现线程的方式只有两种。</p>
<p>​    这篇博客写到这里算是一个完结，因为目前能力有限，可能一些理解不太合适。也想了一下这种情况，个人来说很难学习一个知识点就直接学习到深处，很多东西都是循序渐进的，这样也就能解释之前的博客水平不咋地。一个高度就会有一个理解，不同高度的博客很难相比较。所以后续肯定也会回头看这篇博客。</p>
<p>​    博客是分两天写完的，中间间断了一下，但是最后的结果感觉还不是很满意，中间的语句和语序都有一些问题，也留一个结论。博客最好一天写完，可以后续完善，但是一定要一天定下文章的结构和大体框架。算是写作的一个小提示吧。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="JVM基础概念"><a href="#JVM基础概念" class="headerlink" title="JVM基础概念"></a>JVM基础概念</h2><p>​    Java源文件通过编译器产生class文件，字节码文件再通过Java虚拟机中的解释器，编译成特定机器上的机器码。这也是Java跨平台的原因。</p>
<h3 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h3><p>​    Java内存模型分为两大类，线程私有和共享数据。线程私有：程序计数器、虚拟机栈、本地方法栈。共享数据有：常量池（方法区的一部分）、方法区、Java堆。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_21E692D0E9A8-1.jpeg" alt="IMG_21E692D0E9A8-1"></p>
<ul>
<li>程序计数器：当前线程执行的字节码行号指示器。</li>
<li>虚拟机栈：Java方法执行的内存模型，生命周期和线程一致。栈帧是进行方法执行的数据结构。虚拟机栈主要有两种异常：堆栈异常和内存超出异常。</li>
<li>本地方法栈：虚拟机使用到的native方法的内存空间。抛出的异常也是堆栈异常和内存超出异常。</li>
<li>堆：主要存放着对象的实例和数组的数据。抛出的异常为内存溢出异常。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A22B848C2C43-1.jpeg" alt="IMG_A22B848C2C43-1"></p>
<ul>
<li>方法区：主要存放虚拟机加载的类信息、常量、静态变量、编译后的代码。主要抛出内存溢出异常。</li>
<li>运行时常量池：属于方法区的一部分，主要存放编译器生成的各种字面量和符号的引用。不会抛出内存溢出异常。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>标记清除算法：将存活的对象标记，然后将为标记的对象的内存空间进行回收。</li>
<li>复制算法：将内存空间分为两块，一块用满后，将存活对象复制到另外一块，然后直接将之前的内存空间清理掉。</li>
<li>标记整理算法：将存活对象进行标记，然后将存活的对象都移动到一端，再将边界后面的内存空间清理。</li>
<li>分代收集算法：将内存分为两个区域：新年代和老年代。比例为1:2.新年代又分为Eden、From、To三个区域，比例为：8:1:1.每次进行回收时，将Eden和From存活对象复制到To中，然后将Eden和From清理。老年代因为对象存活时间久，执行的是标记整理算法。<ul>
<li>当标记对象达到15次时，就会移动到老年代。</li>
<li>当To的空间不足时，会将对象移动到老年代。</li>
<li>当老年代也满了或者空间不够了，会触发新年代和老年代的GC，两者分别为：MinorGC和FullGC。</li>
</ul>
</li>
</ul>
<h3 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h3><ul>
<li>引用计数法：有地方引用这个对象，计数器久加一，引用失效久减一。但是不能解决相互引用的问题。</li>
<li>可达性分析算法：以根作为起始点，沿着节点向下搜索，如果一个对象没有可以搜索到的路径，认为该对象不可达，即该对象不可用，可以回收。</li>
</ul>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p>​    通过new关键字创建的引用就是强引用，强引用就算内存不足，gc也不会删除它。软引用可以和ReferenceQueue一块使用，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。弱引用通过WeakReference类实现，弱引用的生命周期比软引用短，无论当前内存空间是否足够，弱引用都会被删除。虚引用也叫幻象引用，通过PhantomReference类来实现。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<h3 id="垃圾收集器的种类"><a href="#垃圾收集器的种类" class="headerlink" title="垃圾收集器的种类"></a>垃圾收集器的种类</h3><ul>
<li>Serial垃圾收集器：单线程、复制算法。进行垃圾回收的同时，必须暂停其他所有工作线程。</li>
<li>ParNew垃圾收集器：Serial收集器的多线程版本。也是需要暂停其他线程，在垃圾回收过程中。</li>
<li>Paraller Scavenge垃圾收集器：多线程复制算法、高效。</li>
<li>Serial Old垃圾收集器：单线程标记整理算法。主要回收老年代。</li>
<li>Paraller Old垃圾收集器：多线程标记整理算法。</li>
<li>CMS收集器：多线程标记清楚算法。有四个阶段：1）初始标记。2）并发标记。3）重新标记。4）并发清楚。</li>
<li>G1垃圾收集器：基于标记整理算法，不产生内存碎片。可以精确控制停顿时间，在不牺牲吞吐量的情况下实现低停顿垃圾回收。</li>
</ul>
<h3 id="JVM调优的工具"><a href="#JVM调优的工具" class="headerlink" title="JVM调优的工具"></a>JVM调优的工具</h3><ul>
<li>jconsole：对jvm中的内存、线程和类进行监控</li>
<li>jvisualvm：可以分析内存快照、线程快照、程序死锁、监控内存变化、gc等</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>​    类加载机制分为五个部分：加载-验证-准备-解析-初始化。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_B2026A3771A2-1.jpeg" alt="IMG_B2026A3771A2-1"></p>
<ul>
<li><p>加载：生成该类的Class对象。</p>
</li>
<li><p>验证：主要是确保Class文件是否符合要求。</p>
</li>
<li><p>准备：为类变量分配内存空间。</p>
</li>
<li><p>解析：虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
</li>
<li><p>初始化：执行类中定义的Java代码。</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>​    对于任意一个类，需要加载它的类加载器和这个类本身一同确立这个类在JVM中的唯一性，每一个类加载器都有一个独立的类名称空间。类加载器就是通过完全限定名将class文件加载到jvm中，再转换为class对象。</p>
<p>  类加载器有三种：启动类加载器、扩展类加载器、应用类加载器。</p>
<ul>
<li>双亲委派模型：类加载器接收到类加载任务时，会交给父类加载器完成，这样，所有的加载请求都会传递到启动类加载器，只有当父类无法完成加载请求，子加载器才会去尝试加载类。好处就是无论哪个类加载器进行加载，最后得到的都是jvm中唯一的class对象。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>对于两个类的情况，即一个父类和一个子类，执行顺序如下。执行父类的静态初始化块。执行子类的静态初始化块。执行父类的非静态初始化块。执行父类的构造器。执行子类的非静态初始化块。执行子类的构造器。</li>
<li>编译是javac test.java。运行是java test。</li>
<li>静态域,main(),构造代码块,构造方法。</li>
<li>Java通过垃圾回收回收不再引用的变量，垃圾回收时对象的finallize（）不一定会得到执行。</li>
<li>判断对象是否可以回收有两个算法，引用计数算法和根搜索算法。垃圾回收算法则有四种，标记清楚算法、复制算法、标记整理算法、分代收集算法Minor GC 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会频繁执行，一般回收速度也比较快。Full GC 也称 Major GC，指发生在老年代的垃圾回收操作。出现了 Full GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。优先在新生代区存放对象，大对象直接放在老年代区，新生代区的对象经历15次GC后就会进入老年代区。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="输入输出基础知识"><a href="#输入输出基础知识" class="headerlink" title="输入输出基础知识"></a>输入输出基础知识</h2><p>​    字符编码（英语：Character encoding）也称字集码，是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。常见的例子包括将拉丁字母表编码成摩斯电码和ASCII。其中，ASCII将字母、数字和其它符号编号，并用7比特的二进制来表示这个整数。通常会额外使用一个扩充的比特，以便于以1个字节的方式存储。</p>
<p>​    字符编码就是将字符和一串二进制编码对应起来，例如ASCII编码就是将各种字符和实际的数字（转换的二进制编码）对应起来。</p>
<p>​    常用的字符编码有ASCII、GBK、Unicode等。</p>
<p>​    GBK 采用双字节表示，总体编码范围为 8140-FEFE，首字节在 81-FE 之间，尾字节在 40-FE 之间，剔除 xx7F 一条线。总计 23940 个码位，共收入 21886 个汉字和图形符号，其中汉字（包括部首和构件）21003 个，图形符号 883 个。</p>
<p>​    我们日常接触到的文件分ASCII和Binary两种。ASCII是“美国信息交换标准编码”的英文字头缩写，可称之为“美标”。美标规定了用从0到127的128个数字来代表信息的规范编码，其中包括33个控制码，一个空格码，和94个形象码。形象码中包括了英文大小写字母，阿拉伯数字，标点符号等。</p>
<p>​    Unicode其实就是宽字节字符集，它对每个字符都固定使用两个字节即16位表示，于是当处理字符时，不必担心只处理半个字符。UTF-8是Unicode编码的一种实现，因为Unicode对于一个字符的表示比较长，所以UTF-8采用了动态长度的方法进行编码。UTF-8是兼容ASCII，第一个字节与ASCII相容，理论上可以达到四个字节。</p>
<p>​    读入一个字节序列的对象叫做输入流，写出一个字节序列对象叫做输出流。实际传输的都是01，但是Java分为字节流和字符流。</p>
<p>处理字节的Stream类结构。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_894224ED70D2-1.jpeg" alt="IMG_894224ED70D2-1"></p>
<p>处理字符的Reader和Writer：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_C3D453ADB75A-1.jpeg" alt="IMG_C3D453ADB75A-1"></p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>​    对象序列化就是将Java中的对象转换为固定格式的字节。想要实现序列化必须实现Serializable接口。</p>
<p>​    序列化的机制：每个对象都用一个序列号保存，即每个对象都关联一个序列号。当序列化时，遇到这个对象第一次时正常序列化，保存其对象。当第二次遇到时，只需要写出之前对象关联的序列号即可。读会对象则是相反，遇到一个序列号时，构建这个对象，并使用流中的数据初始化它。当遇到和这个序列号相同的对象时，获取这个对象引用即可。</p>
<p>​    使用transient关键字可以将某些域声明为不可序列化。</p>
<p>​    Java中存在三种复制，第一种直接赋值，第二种浅拷贝，第三种深拷贝。</p>
<p>​    直接赋值如：A a = a2;当a2变化时，a也会变化。</p>
<p>​    浅拷贝：clone方法，当对象里面还有引用对象时，只是复制引用不复制引用对象。所以当对对象里面的引用对象进行修改时，两者都会变化。</p>
<p>​    深拷贝：无论值还是对象里面的引用对象都进行了拷贝。复制后的对象的修改不影响双方。可以使用序列化来实现。</p>
<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>​    这一部分没啥可讲的，就正常操作文件就行，使用File类，注意操作文件时使用的字符串和当时的机器环境即可。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合的框架图"><a href="#集合的框架图" class="headerlink" title="集合的框架图"></a>集合的框架图</h3><p>集合框架中继承关系：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_0ABE1119FACC-1.jpeg" alt="IMG_0ABE1119FACC-1"></p>
<p>常用的各个集合的作用和特点：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_62E779E2DD25-1.jpeg" alt="IMG_62E779E2DD25-1"></p>
<h3 id="LIst相关知识点"><a href="#LIst相关知识点" class="headerlink" title="LIst相关知识点"></a>LIst相关知识点</h3><ul>
<li>List是有序的Collection（指的是插入顺序）</li>
<li>ArrayList是常用的List，通过数组实现。允许对元素快速访问。扩容是当前容量*1.5+1,当元素满的时候扩容。线程不安全。</li>
<li>Vector也是通过数组实现的，但是它支持多线程访问。速度比ArrayList慢。初始化为10，同步的实现原理是synchronized.</li>
<li>LinkedList通过双向循环链表数据结构，插入和删除比较方便，随机访问比较慢。</li>
</ul>
<h3 id="Set相关知识点"><a href="#Set相关知识点" class="headerlink" title="Set相关知识点"></a>Set相关知识点</h3><ul>
<li>Set主要存放的无序的元素（指的是插入的顺序），值不能重复，只允许插入一个空元素。</li>
<li>HashSet是按照Hash值来存取元素的，只能通过迭代器访问元素。</li>
<li>TreeSet是使用二叉树的原理对元素进行顺序排序。</li>
<li>LinkedHashSet继承HashSet又基于LinkedHashMap实现。</li>
</ul>
<h3 id="Map相关知识点"><a href="#Map相关知识点" class="headerlink" title="Map相关知识点"></a>Map相关知识点</h3><ul>
<li>HashMap就是键值映射，能够存储null值和一个null的key，线程不安全。其他可以看看博客。线程安全问题存在扩容情况，就是多个线程扩容时，会造成环链的情况，导致无限循环。</li>
<li>Hashtable 是一个哈希表，该类继承自Dictionary类，实现了 Map 接口。HashMap是基于哈希表实现的，该类继承AbstractMap，实现Map接口。Hashtable 线程安全的，而 HashMap 是线程不安全的。HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li>
<li>ConcurrentHashMap支持并发操作，采用的是分段锁的形式。Segment代表一个段，一个Segment又代表了一个小型的HashMap，默认并发度为16即16个Segment。</li>
<li>TreeMap是排序map，能够将存储的元素进行排序，默认是升序，需要插入的元素实现Comparable接口。</li>
<li>LinkHashMap继承HashMap，保存了插入的顺序。</li>
<li>重写equals时一定要重写hashcode，因为不重写会导致，map中判断相同的对象无法达到覆盖的目的。equals判断为true，hashcode可能为false。</li>
<li>WeakHashMap使用的是弱引用保存键。</li>
</ul>
<h3 id="迭代器相关知识点"><a href="#迭代器相关知识点" class="headerlink" title="迭代器相关知识点"></a>迭代器相关知识点</h3><ul>
<li>使用迭代器的原因就是可以在迭代过程中删除元素。还有就是解耦合，将遍历Collection和具体的实现抽离出来。</li>
<li>具体使用代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; abc = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">            add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Iterator&lt;String&gt; it  = abc.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.err.println(it.next());</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ListIteratort只能遍历List，Iterator不仅可以遍历List也可以遍历Set。Iterator只能单向遍历，ListIterator可以双向遍历。ListIterator也添加了其他的功能，添加一个元素、替换一个元素、获取前面的元素或者后面的元素。</li>
</ul>
<h3 id="集合的其他知识点"><a href="#集合的其他知识点" class="headerlink" title="集合的其他知识点"></a>集合的其他知识点</h3><ul>
<li>foreach循环内部实现是使用迭代器的，但是最好不要在里面执行元素的删除</li>
<li>迭代器的remove方法会删除指针的前一个元素。调用这个方法时一定要调用next方法控制指针</li>
<li>可以通过instanceof RandomAccess接口来判断当前集合是否支持高效的随机访问。</li>
<li>链表添加元素一般都是在末尾，使用迭代器可以在特定位置添加元素。（ListIterator）</li>
<li>优先级队列可以按任意顺序插入，但是最后删除时是排序的，会获取最小的元素。</li>
<li>映射视图和MySQL中的视图类似，将键、值、键值组成不同的视图。如果在视图上调用remove方法，会删除，但是不能增加元素。</li>
<li>Hashtable和HashMap作用一样，不过前者是同步的，后者是不同步的。</li>
<li>java中的sub一般都是第一个包含在内，第二个参数不包含在内。</li>
<li>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。</li>
<li>队列先进先出，栈先进后出</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="枚举类了解及练习"><a href="#枚举类了解及练习" class="headerlink" title="枚举类了解及练习"></a>枚举类了解及练习</h2><p>​    工作中遇到一个类，发现使用到了枚举，这次也顺带着了解一下。很多东西虽然自己知道但是没有再工作中遇到，也没有去想什么地方能遇到。后面也会对这类知识点在工作中的使用专门写一些博客。</p>
<p>​    枚举类型比较特殊，算是Java中一个比较特殊的类。下面就列一个简单的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> enumtrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClothesSize.java</span></span><br><span class="line"><span class="comment"> * Description: 衣服大小枚举类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ClothesSize</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类,利用构造方法传参。这里的四个码号其实相当于四个实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    S(<span class="string">&quot;S号&quot;</span>), L(<span class="string">&quot;L号&quot;</span>), XL(<span class="string">&quot;XL号&quot;</span>), XXL(<span class="string">&quot;XXL号&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 构造方法，将枚举项的值赋值给枚举类的普通属性，再通过公共方法获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019-07-13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ClothesSize(String size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面就是一个简单的枚举类的例子。可以看到其实枚举相当于Java中的常量，类似下面代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ABA = <span class="string">&quot;气温&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​    但是枚举类要丰富的很多，里面可以写一些方法和变量，相对于上面的常量的定义要灵活的多。下面也给个例子如何使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> train;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> enumtrain.ClothesSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClothesSizeTest.java</span></span><br><span class="line"><span class="comment"> * Description:  枚举类测试方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClothesSizeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印枚举值的值和name</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClothesSize clothesSize = ClothesSize.XL;</span><br><span class="line">        System.err.println(<span class="string">&quot;根据构造方法获取枚举类型的值：&quot;</span> + clothesSize.getSize());</span><br><span class="line">        System.err.println(<span class="string">&quot;直接获取枚举类型的name&quot;</span> + clothesSize.toString());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取全部的枚举值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClothesSize[] clothesSizes = ClothesSize.values();</span><br><span class="line">        <span class="keyword">for</span> (ClothesSize clothesSize1 : clothesSizes) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;枚举值name为：&quot;</span> + clothesSize1.toString() + <span class="string">&quot;，枚举值value为：&quot;</span> + clothesSize1.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据键盘的输入取对应的枚举值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String input = scanner.next().toUpperCase();</span><br><span class="line">        ClothesSize clothesSize1 = Enum.valueOf(ClothesSize.class, input);</span><br><span class="line">        System.err.println(<span class="string">&quot;输入的枚举值name为：&quot;</span> + clothesSize1.toString() + <span class="string">&quot;，输入的枚举值value为：&quot;</span> + clothesSize1.getSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行的截图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200630233928092.png" alt="image-20200630233928092"></p>
<p>说到底，还是简单的使用。一旦到了工作中还是会忘记，因为还是没有在工作中使用，所以忘记的比较快。下面也给出一个代码，希望自己不要忘记。后面也会列举出工作中的使用。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200630234426659.png" alt="image-20200630234426659"></p>
<p>​    有大佬知道这段代码的作用也可以给菜鸟说一下。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="第7章-异常、断言和日志"><a href="#第7章-异常、断言和日志" class="headerlink" title="第7章 异常、断言和日志"></a>第7章 异常、断言和日志</h2><p>​    之前写过异常的文章，部分内容不是很正确，而且整篇文章结构也有些不恰当，这里修改了文章，添加了一些内容。</p>
<h4 id="错误的产生原因"><a href="#错误的产生原因" class="headerlink" title="错误的产生原因"></a>错误的产生原因</h4><p>​    没有人能写出没有BUG的程序，除非这个程序太过于简单。BUG其实就是程序的一些错误，可能是代码的问题，也可能是输入的问题。Java中的异常机制其实也是为了解决这些问题，其他语言也有类似的机制。</p>
<h4 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h4><p>​    Java中，异常都是基于Throwable，Throwable下面又有两个基类。Error和Exception。</p>
<p>​    Error代表Java运行时系统的内部错误和资源耗尽错误，其实就是Java虚拟机出错了。</p>
<p>​    Exception则又分为两类，RuntimeException和其他异常。RuntimeException就是运行时异常，一般都是程序代码有问题。例如：</p>
<blockquote>
<p>错误的类型转换。</p>
<p>数组访问越界。</p>
<p>访问 null 指针。</p>
</blockquote>
<p>其他异常则相反，不是程序代码的问题。所以也叫其他异常。一般有以下几种：</p>
<blockquote>
<p>试图在文件尾部后面读取数据。</p>
<p>试图打开一个不存在的文件。</p>
<p>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。</p>
</blockquote>
<p>​    Java将其他异常称为受查异常，Error和RuntimeException统称为非受查异常。为什么这样分？因为受查异常是没法考虑周全的，所以编译器在编写代码时会检查所有的受查异常是否都有异常处理器（就是那个try块）。非受查异常一般可以通过代码来避免（RuntimeException），也有代码处理不了的（Error）。所以对于非受查异常来说代码其实能做的不多，所以你很少见到代码会throw一个非受查异常，非受查异常一般都是通过捕获来进行处理。</p>
<p>​    总的来说，方法应该尽可能声明会抛出的受查异常，非受查异常要么不可控，要么不应该出现。如果方法没有声明或者捕获受查异常，编译器也会有一个警告。</p>
<h4 id="异常的处理办法"><a href="#异常的处理办法" class="headerlink" title="异常的处理办法"></a>异常的处理办法</h4><p>​    这里说的异常的处理方法其实就是指捕获，捕获的代码格式比较简单。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//可能发生异常的代码</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="comment">//捕获的异常和捕获后要做的事</span></span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//最后要做的事</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    这种结构的代码大家估计看的很多了，这里提几个需要注意的点：</p>
<ul>
<li>try语句后面可以只有finally语句，没有catch语句。也就是说必须要有其中一个。</li>
<li>finally语句的返回值会覆盖掉原始的返回值。</li>
<li>finally是在return执行之后，语句返回之前执行的。(可能比较绕，直接看下面代码)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Train</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;finally&quot;</span>+a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    输出结果是<code>finally11\n10</code>，也就是说返回的是10，但是在finally语句开始前，a已经变为11了。</p>
<p>​    对于关闭资源来说，有可能关闭资源的方法也会出现错误，所以要写两个try块，其实也可以这样写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">    out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，无论怎么退出，资源都会关闭。</p>
<p>​    异常的结构和一些注意的点都说了，下面说一下异常机制的一些小技巧。</p>
<ul>
<li>异常处理不能代替简单的测试</li>
<li>不要过分的细化异常</li>
<li>利用异常层次结构</li>
<li>不要压制异常</li>
<li>在监测错误时，严格要比放任好</li>
<li>不要害怕传递异常</li>
</ul>
<h4 id="处理错误的其他方法"><a href="#处理错误的其他方法" class="headerlink" title="处理错误的其他方法"></a>处理错误的其他方法</h4><p>​    错误的产生最后形式可能不仅仅是异常，如何处理其他的错误呢？下面介绍两种，断言和日志。</p>
<h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><p>​    断言我其实用的很少（几乎没有）。只有在源码中才会看到断言。断言机制其实是测试中间会用到的一种检查，测试时，断言能够对语句或者变量进行检查，代码发布后，这些语句将会自动移走以增加程序的运行速度。其实IDE的调试功能可能会好用一些。大家感兴趣也可以查查，这里了解的不多，也就不再叙述用法和详解了。</p>
<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>​    日志在开发中用的比较多，日志相对于直接打印优点比较多，这里不再累述了。日志框架也比较多，之前也做过分析和介绍。<a href="https://blog.csdn.net/qq_38533859/article/details/107210715?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162203960016780261995962%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162203960016780261995962&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-107210715.nonecase&utm_term=%E6%97%A5%E5%BF%97&spm=1018.2226.3001.4450">SpringBoot集成Log4j2日志框架</a>。后续也会更新一下日志框架的相关博客。这里也是不再累述了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    总的来说，异常机制、断言、日志都是为了让我们代码调试过程中更加方便。下面再说一下调试的一些技巧。</p>
<ul>
<li>每个类可以放一个主函数方便调试，也可以通过写测试类来实现。</li>
<li>多用日志。</li>
<li>利用Throwable提供的printStackTrace可以打印堆栈信息，方便调试。</li>
<li>也可以使用一些Java虚拟机调试工具来监控和管理Java程序。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="第9章-集合"><a href="#第9章-集合" class="headerlink" title="第9章 集合"></a>第9章 集合</h2><p>​    集合平时使用的比较多，但是自己很少往深处去看看其实现和原理，这次趁着这个机会了解一下，完全搞懂还是要看自己后续的使用和深挖。</p>
<h3 id="集合框架了解"><a href="#集合框架了解" class="headerlink" title="集合框架了解"></a>集合框架了解</h3><p>​    想要了解集合，就需要先了解集合框架，这里也以最熟悉的队列（queue）为例来介绍集合框架。</p>
<ul>
<li><p>集合的接口与实现分离</p>
<p>和大多数的设计思想一样，集合的接口和实现也是分离的。队列接口指出了可以在队列的尾部添加元素，在头部删除元素，查找队列中元素的个数。队列的实现通常存在两种形式，一种是使用循环数组，一种是使用链表。这样设计的目的是为了：构建集合时不需要知道使用哪种实现，只有在使用集合对象时，才会确定具体的类。同时也是为了保证：一旦程序改变了想法，只需要在一个地方就可以快捷的改变，即改变调用构造器的地方。</p>
</li>
<li><p><code>Collection</code>接口</p>
<p>集合类的基本接口是<code>Collection</code>接口，这个接口有很多方法，详细可以看一下这个网址：<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a>.</p>
<p>同时，<code>Collection</code>接口又继承了<code>Iterable</code>接口。说到这里就不得不提<code>Iterator</code>和<code>Iterable</code>接口的关系，前者是迭代器对象，后者则是定义了如何返回迭代器方法的接口。</p>
<p>迭代器接口有四个方法。<code>hasNext();,next();,remove(),forEachRemaining(Consumer&lt;? super E&gt; action)</code>.方法的作用看名称就能看出来，不需要多讲什么。需要注意的就是：迭代器的指针是位于两个元素之间的，不是正好指向元素的位置。所以调用<code>next()</code>方法是先越过下一个元素，再返回越过元素的引用。</p>
</li>
<li><p>范型使用方法</p>
<p>不难看出，集合框架中的接口都是范型接口，所以也可以编写一些实用的范型方法，现实也确实这么做了。<code>Collection</code>接口中声明了很多方法。作为实现者来说可以通过实现<code>AbstractCollection</code>接口来定制化自己的需求，同时也不用提供其他不需要的例行方法。具体实现的细节可以看看源码。</p>
</li>
<li><p>集合框架中的接口</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_8073B96B2C46-1.jpeg" alt="IMG_8073B96B2C46-1"></p>
<p>上图已经很明白这个接口之间的关系了。</p>
<h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_2A63A75F65C0-1.jpeg" alt="IMG_2A63A75F65C0-1"></p>
<p>​    下面就来详细介绍一下各个集合的信息和部分集合的用法。</p>
</li>
<li><p>链表</p>
<p>链表的优点就是删除和增加元素时消耗不大（只是修改前后元素的引用），但是随机访问时的消耗要比数组大的多。</p>
<p>在Java语言中，所有的链表实际都是双向链表，即后一个元素存放着前一个元素的引用。</p>
<p>Java中的链表中的add方法是将元素添加到链表尾部，但是实际使用中很少遇到这种需求，都是在链表中部添加元素。所以这种对于指定位置添加元素的方法都可以交给迭代器去处理。但是使用迭代球也需要注意：可以给一个容器添加多个迭代器，但是应该只有一个迭代器能够读写，其他迭代器尽量不要读写，只给读的权限即可。光说也体现不出什么，实际撸代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedListTrain.java</span></span><br><span class="line"><span class="comment"> * Description:  链表练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; a = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        a.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        a.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        a.add(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        List&lt;String&gt; b = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        b.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        ListIterator&lt;String&gt; aIter = a.listIterator();</span><br><span class="line">        Iterator&lt;String&gt; bIter = b.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bIter.hasNext()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在当前位置前添加一个元素</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (aIter.hasNext()) aIter.next();</span><br><span class="line">            aIter.add(bIter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(a);</span><br><span class="line">        bIter = b.iterator();</span><br><span class="line">        <span class="keyword">while</span> (bIter.hasNext()) &#123;</span><br><span class="line">            bIter.next();</span><br><span class="line">            <span class="keyword">if</span> (bIter.hasNext()) &#123;</span><br><span class="line">                bIter.next();</span><br><span class="line">                <span class="comment">//删除前一个元素</span></span><br><span class="line">                bIter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(b);</span><br><span class="line"></span><br><span class="line">        a.removeAll(b);</span><br><span class="line">        System.err.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在敲这段代码的时候先猜一下实际会打印什么，我第一次猜的时候错的离谱。</p>
</li>
<li><p>数组列表</p>
<p>这个没有啥好讲的，ArrayList用的比较多，需要注意的就是：需要同步时使用Vector，不需要同步时使用ArrayList。</p>
</li>
<li><p>散列集</p>
<p>用处就是随机访问集合中的任意元素，并且概率相同。涉及到数据结构。</p>
<p>原理就是散列表为每一个对象计算一个散列码（hash code），散列码是由对象的实例产生的一个整数。具体使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SetTrain.java</span></span><br><span class="line"><span class="comment"> * Description: Set练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (!in.hasNext(<span class="string">&quot;eof&quot;</span>)) &#123;</span><br><span class="line">                String word = in.next();</span><br><span class="line">                <span class="comment">//因为电脑的性能不同，这里可能会是0</span></span><br><span class="line">                <span class="keyword">long</span> callTime = System.currentTimeMillis();</span><br><span class="line">                System.err.println(callTime);</span><br><span class="line">                words.add(word);</span><br><span class="line">                callTime = System.currentTimeMillis() - callTime;</span><br><span class="line">                System.err.println(callTime);</span><br><span class="line">                l += callTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;String&gt; iterator = words.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span> &amp;&amp; iterator.hasNext(); i++) &#123;</span><br><span class="line">            System.err.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        System.err.println(words.size() + <span class="string">&quot;时间花费&quot;</span> + l + <span class="string">&quot;时间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树集</p>
<p>涉及到数据结构，之前学的都忘的差不多了。和红黑树类似，后续可以算法那部分继续了解，这里只是简单的上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ItemTest.java</span></span><br><span class="line"><span class="comment"> * Description:  树集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemTest</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ItemTest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> partNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemTest</span><span class="params">(String adescription, <span class="keyword">int</span> apartNumber)</span> </span>&#123;</span><br><span class="line">        description = adescription;</span><br><span class="line">        partNumber = apartNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ItemTest&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, partNumber=&quot;</span> + partNumber +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比较，需要注意的是对象可能是个null对象，但是仍然要返回true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ItemTest other = (ItemTest) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(description, other.description) &amp;&amp; partNumber == other.partNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(description, partNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ItemTest o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比较int的大小和string的长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> diff = Integer.compare(partNumber, o.partNumber);</span><br><span class="line">        <span class="keyword">return</span> diff != <span class="number">0</span> ? diff : description.compareTo(o.description);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.NavigableSet;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedSet;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSetTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 树集练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTrain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 代码写完，还是不明白，后续了解。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SortedSet&lt;ItemTest&gt; itemTests = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        itemTests.add(<span class="keyword">new</span> ItemTest(<span class="string">&quot;A&quot;</span>, <span class="number">123</span>));</span><br><span class="line">        itemTests.add(<span class="keyword">new</span> ItemTest(<span class="string">&quot;B&quot;</span>, <span class="number">456</span>));</span><br><span class="line">        itemTests.add(<span class="keyword">new</span> ItemTest(<span class="string">&quot;C&quot;</span>, <span class="number">789</span>));</span><br><span class="line">        System.err.println(itemTests);</span><br><span class="line"></span><br><span class="line">        NavigableSet&lt;ItemTest&gt; itemTests1 = <span class="keyword">new</span> TreeSet&lt;&gt;(Comparator.comparing(ItemTest::getDescription));</span><br><span class="line">        itemTests1.addAll(itemTests);</span><br><span class="line">        System.err.println(itemTests1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>优先级队列</p>
<p>优先级队列就是一个可以自我调整的二叉树，对树执行添加和删除操作时，可以让最小的元素移动到根，而不必花费时间对元素进行排序。代码的使用很简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collectiontrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PriorityQueueTest.java</span></span><br><span class="line"><span class="comment"> * Description: 优先级队列练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;LocalDate&gt; localDates = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        localDates.add(LocalDate.MAX);</span><br><span class="line">        localDates.add(LocalDate.MIN);</span><br><span class="line">        localDates.add(LocalDate.of(<span class="number">1903</span>, <span class="number">12</span>, <span class="number">10</span>));</span><br><span class="line">        localDates.add(LocalDate.of(<span class="number">1902</span>, <span class="number">12</span>, <span class="number">10</span>));</span><br><span class="line">        localDates.add(LocalDate.of(<span class="number">1903</span>, <span class="number">11</span>, <span class="number">10</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;打印&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (LocalDate localDate : localDates) &#123;</span><br><span class="line">            System.err.println(localDate);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 只取出最小的删除，无论如何操作。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!localDates.isEmpty()) &#123;</span><br><span class="line">            System.err.println(localDates.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>​    有时集合并不是很适合，例如我们知道某些键的信息，但是想查询与键对应的值。映射就是为了解决这类问题或场景而设计的。</p>
<ul>
<li><p>映射基本用法</p>
<p>映射的两个通用实现分别为：HashMap,TreeMap。名字已经很清楚了。一个时散列映射，一个是树映射。散列只能将键散列，树映射也是对键的整体顺序排序。</p>
<p>映射中有一些常用的方法，例如：<code>get(k),put(k,v),remove(k),size(),forEach()</code>，映射中键是唯一的，同一个键重复赋值，后一次的赋值会覆盖掉前一次的赋值。</p>
<p>需要注意的就是如果代码中有更新映射的需求，需要先判断这个键是否存在，在执行对应的逻辑，代码中很容易就实现了，这里不在列举出详细代码。</p>
<p>使用起来也是比较简单，这个还是比较常用的，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; stringStringMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">stringStringMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">stringStringMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">stringStringMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">stringStringMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">  </span><br><span class="line">System.err.println(stringStringMap);</span><br><span class="line">  </span><br><span class="line">stringStringMap.remove(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">  </span><br><span class="line">stringStringMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">System.err.println(stringStringMap.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 还是需要再了解和使用lambda表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stringStringMap.forEach((k, v) -&gt; System.err.println(<span class="string">&quot;key&quot;</span> + k + <span class="string">&quot;===&quot;</span> + <span class="string">&quot;value&quot;</span> + v));</span><br></pre></td></tr></table></figure></li>
<li><p>视图和其他映射</p>
<p>视图就是将映射中的元素存放到集合中（官方认为映射不是一个集合）。有三种映射，键集、值集合和键/值对集。需要注意的时键集中删除某个键，映射中也会删除这个键和其对应的值，但是添加则不行。</p>
<p>弱散列映射，当对键的唯一引用来自于散列条目时，这一数据结构将与垃圾回收器协同工作一起删除键/值对。WeakHashMap使用弱引用来保存键。弱引用其实是将强引用包装，想要获得该对象需要用get方法，具体这里的实现原理可以看一下WeakHashMap的源码，这里水平太差，估计要放到后面留个坑了。</p>
<p>链接散列集与映射，类似于一个双向链表，调用get和put时，会影响该元素在映射中的位置。其实可以修改这个映射，将用的多的元素放到缓存中。这里不再列举代码了。</p>
<p><code>EnumSet</code>是枚举元素集，实现是用位序列，如果对应的值在集中，则相应的位置被置位1。</p>
<p>标志散列映射，<code>IdentityHashMap</code>类比较特殊，键的散列值不是用<code>hashCode()</code>计算的，是使用<code>identityHashCode()</code>计算的，这个方法和<code>hashCode()</code>的区别看一看看源码，大概就是比较时一个使用的是<code>==</code>，一个是<code>equals()</code>。</p>
</li>
</ul>
<h3 id="视图和包装器"><a href="#视图和包装器" class="headerlink" title="视图和包装器"></a>视图和包装器</h3><p>​    这一部分感觉设计到设计模式，这一块目前还不是很熟悉，很多用法不知道为什么这样设计以及这样做的好处。就简单介绍记录一下吧。</p>
<p>​    视图有几种，子范围的视图、不可修改的视图、同步视图、受查视图。作用名称已经很清楚了。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    上面也说过了，映射和集合是一种数据结构，自然离不开算法，看到现在也大致了解了，这些的集合和映射的实现离不开算法。但是感觉现在自己学起来还是比较空，就再给自己留个坑吧。</p>
<p>就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E8%8C%83%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="第8章-范型程序设计"><a href="#第8章-范型程序设计" class="headerlink" title="第8章 范型程序设计"></a>第8章 范型程序设计</h2><p>​    范型要解决的问题就是让编写的代码可以被很多不同的类型所重用。例如<code>List&lt;String&gt;</code>,就是一个简单的范型的使用。</p>
<p>​    下面就列举一个简单的范型的代码例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型练习类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParadigmTrain1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate[] dates = &#123;LocalDate.of(<span class="number">1996</span>, <span class="number">12</span>, <span class="number">9</span>), LocalDate.of(<span class="number">1997</span>, <span class="number">5</span>, <span class="number">15</span>), LocalDate.of(<span class="number">1998</span>, <span class="number">5</span>, <span class="number">15</span>)&#125;;</span><br><span class="line">        Pair&lt;LocalDate&gt; result = minmax(dates);</span><br><span class="line">        System.err.println(result.getFirst());</span><br><span class="line">        System.err.println(result.getSecond());</span><br><span class="line">      	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里可以通过参数的形式来推断出范型的类型，所以不需要输入范型的类型参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>);	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 输入的参数必须要实现Comparable。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> paradigmtrain.Pair&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个范型是对参数进行限制，第二个是返回的类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((a == <span class="keyword">null</span>) || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T min = a[<span class="number">0</span>];</span><br><span class="line">        T max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> aLength = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aLength; i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 比较大小，通过compareTo方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain1.java</span></span><br><span class="line"><span class="comment"> * Description:  范型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以通过对范型参数添加<code>extends</code>，来限制范型参数的类型。如下：</p>
<p><code>public static &lt;T extends Comparable &amp; Serializable&gt; Pair&lt;T&gt; minmax(T[] a) &#123;</code></p>
</li>
<li><p>范型的原理。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_4294825AB109-1.jpeg" alt="IMG_4294825AB109-1"></p>
<p>注意：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_4DB8B172B25A-1.jpeg" alt="IMG_4DB8B172B25A-1"></p>
</li>
<li><p>为了解决类型擦除于多态的冲突，需要生成一个桥方法。（比较复杂，了解即可）</p>
</li>
<li><p>关于范型的事实。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_9B4D064EA133-1.jpeg" alt="IMG_9B4D064EA133-1"></p>
</li>
<li><p>范型的约束和局限</p>
<ul>
<li><p>不能用基本类型实例化类型参数。类型擦除后，变为Object，但是Object不能存储基本类型的值。</p>
</li>
<li><p>运行时类型查询只适用于原始类型。即这个代码是错误的。<code>if(a instanceof Pair&lt;String&gt;)</code>（无法判断）。</p>
</li>
<li><p>不能创建参数化类型的数组。数组会记住它的元素类型，如果试图存储其他类型的元素会报异常。</p>
</li>
<li><p>不能构造范型数组。</p>
</li>
<li><p>不能实例化类型变量。</p>
</li>
<li><p>范型类的静态上下文中类型变量无效。</p>
</li>
<li><p>不能抛出或捕获范型类的实例。</p>
</li>
</ul>
</li>
<li><p>范型类型的继承规则。Employee是Manager的父类，但是<code>Pair&lt;Employee&gt;</code>不是<code>Pair&lt;Manager&gt;</code>的父类。</p>
</li>
<li><p>通配符类型中，允许类型参数变化。</p>
<p>看书是有点枯燥的，尤其这种难读的东西，下面写个例子，把上面的东西串联起来。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> paradigmtrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParadigmTrain2.java</span></span><br><span class="line"><span class="comment"> * Description:  综合练习，把范型知识点串联起来</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParadigmTrain2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Manager ceo = <span class="keyword">new</span> Manager(<span class="string">&quot;zhangshan&quot;</span>, <span class="number">8000</span>, <span class="number">24</span>);</span><br><span class="line">        Manager cfo = <span class="keyword">new</span> Manager(<span class="string">&quot;lisi&quot;</span>, <span class="number">9000</span>, <span class="number">25</span>);</span><br><span class="line">        Pair&lt;Manager&gt; managerPair = <span class="keyword">new</span> Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">        printBuddies(managerPair);</span><br><span class="line"></span><br><span class="line">        ceo.setMoney(<span class="number">10000</span>);</span><br><span class="line">        cfo.setMoney(<span class="number">20000</span>);</span><br><span class="line">        Manager[] managers = &#123;ceo, cfo&#125;;</span><br><span class="line">        Pair&lt;Manager&gt; managerPair1 = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">        minMaxBonus(managers, managerPair1);</span><br><span class="line">        System.err.println(<span class="string">&quot;minMaxBonus:&quot;</span> + managerPair1.getFirst().getName() + <span class="string">&quot;==&quot;</span> + managerPair1</span><br><span class="line">                .getSecond().getName());</span><br><span class="line">        maxMinBonus(managers, managerPair1);</span><br><span class="line">        System.err.println(<span class="string">&quot;minMaxBonus:&quot;</span> + managerPair1.getFirst().getName() + <span class="string">&quot;==&quot;</span> + managerPair1</span><br><span class="line">                .getSecond().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 通配符类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; pair)</span> </span>&#123;</span><br><span class="line">        Employee employee = pair.getFirst();</span><br><span class="line">        Employee employee1 = pair.getSecond();</span><br><span class="line">        System.err.println(<span class="string">&quot;printBuddies&quot;</span> + employee.getName() + <span class="string">&quot;====&quot;</span> + employee1.getName() + <span class="string">&quot;=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 通配符的超类型限定，限定父类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> managers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minMaxBonus</span><span class="params">(Manager[] managers, Pair&lt;? <span class="keyword">super</span> Manager&gt; pair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (managers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Manager min = managers[<span class="number">0</span>];</span><br><span class="line">        Manager max = managers[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; managers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min.getMoney() &gt; managers[i].getMoney()) min = managers[i];</span><br><span class="line">            <span class="keyword">if</span> (max.getMoney() &lt; managers[i].getMoney()) max = managers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        pair.setFirst(min);</span><br><span class="line">        pair.setSecond(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxMinBonus</span><span class="params">(Manager[] managers, Pair&lt;? <span class="keyword">super</span> Manager&gt; pair)</span> </span>&#123;</span><br><span class="line">        minMaxBonus(managers, pair);</span><br><span class="line">        PairAlg.swapHelper(pair);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairAlg</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 无限定通配符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNull</span><span class="params">(Pair&lt;?&gt; pair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pair.getFirst() == <span class="keyword">null</span> || pair.getSecond() == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; pair)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; tPair)</span> </span>&#123;</span><br><span class="line">        T t = tPair.getFirst();</span><br><span class="line">        tPair.setFirst(tPair.getSecond());</span><br><span class="line">        tPair.setSecond(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E3%80%81%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="Java中并发了解和学习"><a href="#Java中并发了解和学习" class="headerlink" title="Java中并发了解和学习"></a>Java中并发了解和学习</h2><p>​    了解Java中的并发需要先清楚进程和线程的区别</p>
<p>​    进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p>​    线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<p>​    说的更加通俗一点，进程相当于你电脑运行的各个软件，满足的你的不通需求。线程相当于进程中更加小的进程，例如打游戏时，你既可以看到画面，也能听到游戏的声音，这里就是不同的线程。线程和进程的区别本质在于进程之间的变量不通用，但是线程之间时通用的，所以线程之间的通信要比进程有效的多。同时，创建、撤销线程要比进程开销要小得多。下面就来讲讲Java中的线程和并发。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>​    线程的状态有六种。新创建、可运行、被阻塞、等待、计时等待、被终止。这六种状态的图序如下图。<img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_CC357226F5D1-1.jpeg" alt="IMG_CC357226F5D1-1"></p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><p>​    说完了线程的状态，下面就要说一下线程的属性，线程的属性有线程优先级、守护线程、线程组、未捕获异常的处理器。</p>
<ul>
<li> 需要注意的是Java中线程的优先级依赖于底层系统的计算，说到底Java还是属于应用层，系统底层也有着自己的优先级，所以优先级的设置只能使该线程在Java中的优先级较高，在底层的优先级不能够确定。</li>
<li>当虚拟机中只剩下守护线程时，虚拟机就退出了，守护线程，字如其意，有其他线程让守护线程守护，守护线程才有意义。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>​    并发其实要解决的问题就是多个线程共同使用统一资源的问题（可能有误，欢迎指正）。Java为了防止代码块被并发的访问，最后导致数据的不稳定性。Java提供了一个syncchronized关键字，同时也提供了一个ReentrantLock类。下面就举一个简单的例子。银行转账（大家都用这个例子，我也用）。如果让一百个线程，随机往100个用户里面随机转账，转账完毕后就睡眠。最开始还能保持总金额没有变化，但是随着运行时间越来越长，总金额有可能变大也有可能变小，但是很小的可能会仍然保持不变。这种不确定性就是程序员最害怕的。下面也是用ReentrantLock类来改善这个例子，每次转账时对金额上锁，达到总金额不变的目的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockBank.java</span></span><br><span class="line"><span class="comment"> * Description: 带锁的银行类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Lock banlLock;</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customerNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockBank</span><span class="params">(<span class="keyword">int</span> customerNum, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 填充数值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="keyword">double</span>[customerNum];</span><br><span class="line">        Arrays.fill(accounts, balance);</span><br><span class="line">        banlLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        sufficientFunds = banlLock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 转账方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> money)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        banlLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (accounts[from] &lt; money) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                sufficientFunds.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.err.println(Thread.currentThread());</span><br><span class="line">            accounts[from] -= money;</span><br><span class="line">            System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>, money, from, to);</span><br><span class="line">            accounts[to] += money;</span><br><span class="line">            System.out.printf(<span class="string">&quot;the total balance is %10.2f&quot;</span>, getTotalbalance());</span><br><span class="line">            sufficientFunds.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            banlLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取所有的余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalbalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        banlLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> a : accounts) &#123;</span><br><span class="line">                sum += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            banlLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取当前客户人数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCustomerNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BankMain.java</span></span><br><span class="line"><span class="comment"> * Description: 银行测试的主方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MACCOUNTS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> INITIAL_BALANCE = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MAX_AMOUNT = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockBank lockBank = <span class="keyword">new</span> LockBank(MACCOUNTS, INITIAL_BALANCE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MACCOUNTS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> fromeaccount = i;</span><br><span class="line">            Runnable r = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> toaccount = (<span class="keyword">int</span>) (lockBank.getCustomerNum() * Math.random());</span><br><span class="line">                        <span class="keyword">double</span> money = MAX_AMOUNT * Math.random();</span><br><span class="line">                        lockBank.transfer(fromeaccount, toaccount, money);</span><br><span class="line">                        Thread.sleep((<span class="keyword">int</span>) (DELAY * Math.random()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不难看到，总金额运行后是一直保持不变的。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201214212715997.png" alt="image-20201214212715997"></p>
<p>​    但是这个办法只能用于单个机器，多服务器的情况下仍然会出现金额错乱的情况。使用synchronized关键字的代码如下，只是附上了银行类的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SyncBank.java</span></span><br><span class="line"><span class="comment"> * Description:Java关键字synchronized 的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncBank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customerNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncBank</span><span class="params">(<span class="keyword">int</span> customerNum, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 填充数值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="keyword">double</span>[customerNum];</span><br><span class="line">        Arrays.fill(accounts, balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 转账方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> money)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (accounts[from] &lt; money)</span><br><span class="line">            wait();</span><br><span class="line">        System.err.println(Thread.currentThread());</span><br><span class="line">        accounts[from] -= money;</span><br><span class="line">        System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>, money, from, to);</span><br><span class="line">        accounts[to] += money;</span><br><span class="line">        System.out.printf(<span class="string">&quot;the total balance is %10.2f&quot;</span>, getTotalbalance());</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取所有的余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getTotalbalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> a : accounts) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取当前客户人数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCustomerNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如何选择这些？怎么知道自己需要哪个？1.不要使用Lock/Condition或者synchronized,多数情况下可以使用阻塞队列来同步完成一个共同任务的线程。2.如果能使用synchronized，尽量使用，可以减少代码，从而达到减少出错的机会。3.如果需要使用到Lock\Condition的特性，才使用Lock\Condition。(书上抄的，就这样吧)</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>​    阻塞队列是为了更加优雅的解决上面的问题，如果开发者太多的参与底层的编写，这个是不合理并且不切实际的。所以就有了阻塞队列的产生，用来解决线程之间共享资源的问题。阻塞队列的流程如下：许多线程向阻塞队列中取出指令并且执行相应命令，如果有生产者插入队列中新的元素或者消费者移除一个元素时，阻塞队列会导致线程阻塞。队列会自动的平衡负载。</p>
<p>下面就来简单编写一个阻塞队列的demo。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BlockingQueueTrain.java</span></span><br><span class="line"><span class="comment"> * Description:  阻塞队列的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FILE_QUEUE_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEARCH_THREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File DUMMY = <span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;File&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(FILE_QUEUE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(System.in)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your directory eg: /Users/pengshiquan/Desktop/Developmentcache/JavaTrain/src/syncTrain&quot;</span>);</span><br><span class="line">            String directory = in.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your keyword eg volatile&quot;</span>);</span><br><span class="line">            String keyword = in.nextLine();</span><br><span class="line">            Runnable enumerator = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    enumrate(<span class="keyword">new</span> File(directory));</span><br><span class="line">                    <span class="comment">//通过添加&quot;包尾&quot;来达到通知的效果</span></span><br><span class="line">                    queue.put(DUMMY);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(enumerator).start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; SEARCH_THREADS; i++) &#123;</span><br><span class="line">                Runnable searcher = () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">                            File file = queue.take();</span><br><span class="line">                            <span class="keyword">if</span> (file == DUMMY) &#123;</span><br><span class="line">                                queue.put(file);</span><br><span class="line">                                done = <span class="keyword">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> search(file, keyword);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">new</span> Thread(searcher).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 列举目录下所有的文件或者目录，添加到队列中.会循环遍历目录的目录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory 需要列举的文件夹或者文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/12/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enumrate</span><span class="params">(File directory)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        File[] files = directory.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) enumrate(file);</span><br><span class="line">            <span class="keyword">else</span> queue.put(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 搜索文件中是否含有关键字，有就打印出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file    需要搜索的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyword 搜索时的关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/12/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(File file, String keyword)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(file, <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> lineNumber = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (in.hasNextLine()) &#123;</span><br><span class="line">                lineNumber++;</span><br><span class="line">                String line = in.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (line.contains(keyword)) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s:%d:%s%n&quot;</span>, file.getPath(), lineNumber, line);</span><br><span class="line">                    <span class="comment">//想法是测试队列的公平性，但是测试结果和预想的不太一样</span></span><br><span class="line">                    <span class="comment">//System.err.println(Thread.currentThread().getId());</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面也没有什么难点，说一下大致的思路。这个demo的目的是为了检索用户输入的目录下所有文件含有关键字的行，并且打印该行。demo先是创建一个线程，用来将用户输入的目录下所有的文件或者文件夹放入队列中，另外起大量线程，用来检索文件内是否含有指定关键字。中间一部分代码和预想中的不一致，目前能力有限，也无法验证。就是上面测试队列公平性的代码，发现打印都是用一个线程做的。和我预想中的不太一样。</p>
<h3 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h3><p>​    在Java中实现多线程有两种方式，一种是继承Thread类，还有一种就是实现Runnable接口。Runnable封装一个异步运行的任务，可以看为一个没有参数和返回值的异步方法。Callable和Runnablee类似，但是有返回值。Callable接口是一个参数化的类型，只有一个方法<code>call()</code>。</p>
<p>​    Future能够保存异步计算的结果，流程是这样的：启动一个计算，将Future对象交给某个线程，然后执行其他任务，Future对象的所有者在结果计算好之后就可以获得它。上面的例子也可以修改为使用Future，代码修改为如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syncTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FutureTest.java</span></span><br><span class="line"><span class="comment"> * Description: Future的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(System.in)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your directory eg: /Users/pengshiquan/Desktop/Developmentcache/JavaTrain/src/syncTrain&quot;</span>);</span><br><span class="line">            String directory = in.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your keyword eg volatile&quot;</span>);</span><br><span class="line">            String keyword = in.nextLine();</span><br><span class="line">            MathCounter mathCounter = <span class="keyword">new</span> MathCounter(<span class="keyword">new</span> File(directory), keyword);</span><br><span class="line">            FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(mathCounter);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.println(task.get() + <span class="string">&quot;符合的行数&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FutureTest.java</span></span><br><span class="line"><span class="comment"> * Description:  计数类，实现了Callable接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathCounter</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> File directory;</span><br><span class="line">    <span class="keyword">private</span> String keyword;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MathCounter</span><span class="params">(File file, String keyword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = file;</span><br><span class="line">        <span class="keyword">this</span>.keyword = keyword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        File[] files = directory.listFiles();</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (File file : files)</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                MathCounter mathCounter = <span class="keyword">new</span> MathCounter(file, keyword);</span><br><span class="line">                FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(mathCounter);</span><br><span class="line">                result.add(task);</span><br><span class="line">                Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">                t.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (search(file)) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; integerFuture : result) &#123;</span><br><span class="line">            count += integerFuture.get();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(file, <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">while</span> (!found &amp;&amp; in.hasNextLine()) &#123;</span><br><span class="line">                    String line = in.nextLine();</span><br><span class="line">                    <span class="keyword">if</span> (line.contains(keyword)) found = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行器和线程池"><a href="#执行器和线程池" class="headerlink" title="执行器和线程池"></a>执行器和线程池</h3><p>​    线程的创建事比较消耗资源的，如果程序中创建了大量的短期线程，可以使用线程池来管理和获取。</p>
<p>​    这篇博客前前后后写了很长时间，最后写了感觉也不是很理想，中间也断断续续了几次，这篇博客的知识点我也忘了几次，都是看前面写的才记起来写到哪里。最后发现不是我想象中的学习方式，也记录下来，引以为戒。如果只是死看书很难学到有用的知识，可能就是写了一篇博客，其中的知识点也很难到自己的脑子里。还是好奇法更加容易学习，通过工作中的一个例子，去编写一个demo，再去了解这个demo后面藏着的知识，这样的方式才能让知识更加深刻的到达自己的脑子里面。引以为戒。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8HashMap%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="红黑树在HashMap中的应用（一）"><a href="#红黑树在HashMap中的应用（一）" class="headerlink" title="红黑树在HashMap中的应用（一）"></a>红黑树在HashMap中的应用（一）</h2><p>​    现在来填上一篇博客的坑，讲一讲红黑树在HashMap中的应用。</p>
<p>​    在讲之前，先要了解一下红黑树，再去阅读源码。本文就是这样的一个结构。但是一开始没有想到红黑树很复杂，篇幅比预期的要大，所以本次红黑树的记录分为三期，坑一定要慢慢填。。</p>
<p>[TOC]</p>
<h3 id="了解红黑树"><a href="#了解红黑树" class="headerlink" title="了解红黑树"></a>了解红黑树</h3><p>​    分析源码肯定要先了解相关概念，了解了概念去看源码就豁然开朗，要不然一直都像无头苍蝇一样，抓不到头绪。</p>
<h4 id="红黑树的历史"><a href="#红黑树的历史" class="headerlink" title="红黑树的历史"></a>红黑树的历史</h4><p>​    红黑树最开始由鲁道夫·贝尔在1972年发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文。但是其代码的实现非常不容易，所以在2008年Robert Sedgewick编写了一个幻灯片，介绍了左倾红黑树，并且给出了简单的实现代码，就此，红黑树就逐渐变成我们如今了解的样子。</p>
<p>​    作为一个合格的开发人员，应该去了解概念的最初形成，知道其根源的理论。网上的大部分文章都介绍了红黑树的五个性质，但是性质来源和为什么有这些性质并没有说清楚。这里因为本人能力有限（英语方面），使用谷歌翻译但是翻译的一塌糊涂。所以最后虽然找到了论文和PPT，但是看不懂。。。（英语的重要性）下面放上链接，同时也希望自己后续英语能力上来后能够填上这个坑。</p>
<p><a href="https://ieeexplore.ieee.org/abstract/document/4567957">A dichromatic framework for balanced trees</a></p>
<p><a href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf">Left-Leaning Red-Black Tree</a></p>
<h4 id="红黑树的来源和变种"><a href="#红黑树的来源和变种" class="headerlink" title="红黑树的来源和变种"></a>红黑树的来源和变种</h4><p>​    如果你也和我一样在网上找了一圈相关的论文资料，估计这个小节你已经有了相关的概念。红黑树并不是凭空出来的新概念，只是将最开始的概念进行完善和代码化。下面我就按照完善的顺序介绍各种二叉树的变种。直到最后介绍红黑树，</p>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>​    二叉树（binary tree）是最开始的树，就是一个简单的只有两个字节点的树。甚至节点之间都没有顺序。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210309184758580.png" alt="image-20210309184758580"></p>
<h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>​    二叉查找树（BST，binary search tree）是二叉树的进化，在二叉树的基础上增加了有序性，我们平时说的二叉树也是指的二叉查找树。二叉查找树能够快速的查找、删除、插入元素。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210309185136325.png" alt="image-20210309185136325"></p>
<p>​    但是二叉查找树有一个致命因素，如果元素在特殊情况下插入，二叉树会变成一种单链表，如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210309185326382.png" alt="image-20210309185326382"></p>
<p>​    所以二叉查找树在特殊情况下的时间复杂度非常差。</p>
<h5 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h5><p>​    AVL树（由发明者Adelson-Velsky 和 Landis 的首字母缩写命名）是指任意节点的两个子树的高度差不超过1的平衡树。</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210309190241163.png" alt="image-20210309190241163"></p>
<p>​    上面的树就是AVL树，不是很容易理解，并且AVL树实现自平衡的过程很复杂，这里就不再详细描述了。</p>
<h5 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h5><p>​    2-3树的定义如下：每个具有子节点的节点（内部节点，internal node）要么有两个子节点和一个数据元素，要么有三个子节点和两个数据元素的自平衡的树，它的所有叶子节点都具有相同的高度。</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310163055451.png" alt="image-20210310163055451"></p>
<p>​    2-3树的逻辑还是能够理解的，主要就是维持2-3树的特点，如果出现了不符合2-3树的特征，就需要将数据元素或者字节点往上移动。下面列举一个2-3树生长轨迹图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310165516582.png" alt="image-20210310165516582"></p>
<p>​    图的来源为：<a href="http://ddrv.cn/a/104429">算法网</a></p>
<h5 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h5><p>​    2-3-4树，它的每个非叶子节点，要么是2节点，要么是3节点，要么是4节点，且可以自平衡，所以称作2-3-4树。2节点：包含两个子节点和一个数据元素；3节点：包含三个子节点和两个数据元素；4节点：包含四个子节点和三个数据元素；</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310165929418.png" alt="image-20210310165929418"></p>
<p>​        2-3-4树是2-3树的进阶版，在2-3树的转换过程中会发现有一种中间状态和上面的图类似，就是具有四个节点和三个数据元素，如果这种状态合法，它就是2-3-4树。</p>
<p>​    如果2-3-4树转换的中间状态也是合法的，就又产生了一种新的树，2-3-4-5树。这样类似的树统称为B树，它允许一个节点可以有多于两个子节点，同时，也是自平衡的，叶子节点的高度都是相同的。B树多了一个概念叫“度”，2-3树的度就是3，2-3-4树多度就是4，度就是表示该树最多拥有多少字节点。</p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>​    红黑树其实是由2-3-4树变种而来（也有说是2-3树变种而来，这里不再讨论详细内容），因为2-3-4树代码的实现比较复杂，所以产生了红黑树（代码实现也不简单）。先说一下红黑树的五条性质。</p>
<ul>
<li>节点是要么红色或要么是黑色。</li>
<li>根一定是黑色节点。</li>
<li>每个叶子结点都带有两个空的黑色结点（称之为NIL节点，它又被称为黑哨兵）。</li>
<li>每个红色节点的两个子节点都是黑色（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点）。</li>
<li>从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
<p>​    现在五条性质不清楚原因没有关系，可以在后面慢慢的去了解其意义，或者在上面的论文和幻灯片中寻找答案。和我之前想的一样，不同的高度看到和理解的东西是不一样的，很难一次就理解红黑树的全部概念。列举一个和上面2-3-4树数据元素一致的红黑树。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310182116361.png" alt="image-20210310182116361"></p>
<p>​    这样看的话是不是就能理解为什么红黑树是2-3-4树的变种了？对比五条性质就更能理解这个图。如果上面的两个图片还是抽象，我寻找了画的比我好的一个示意图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310194048137.png" alt="image-20210310194048137"></p>
<p>​    到此，红黑树的来源和中间的一些变种就全部了解完毕。这一部分借鉴了其他人的博客，这里放上链接。</p>
<p>​    <a href="https://segmentfault.com/a/1190000024499075">红黑树的来源和变种的讲解</a></p>
<h4 id="红黑树的五条性质及其解释"><a href="#红黑树的五条性质及其解释" class="headerlink" title="红黑树的五条性质及其解释"></a>红黑树的五条性质及其解释</h4><p>​    红黑树的五条性质在上面有说到过，下面就一一分析这五条性质。</p>
<h5 id="2-3-4树和红黑树之间的转换"><a href="#2-3-4树和红黑树之间的转换" class="headerlink" title="2-3-4树和红黑树之间的转换"></a>2-3-4树和红黑树之间的转换</h5><p>​    既然说了红黑树来源于2-3-4树，所以两者肯定可以转换，并且红黑树的五条性质也是依赖于这些转换过程的。下面给出转换的图例和解析。2-3-4树只存在2、3、4节点的情况，临时的节点情况不再本次分析之内。</p>
<ul>
<li>2节点。2节点比较简单，直接转换为红黑树中的黑色节点即可，如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314142331015.png" alt="image-20210314142331015"></p>
<p>​    这个还是很好理解的，就是简单将节点赋予颜色，没有什么难点。</p>
<ul>
<li>3节点。3节点有些特殊，存在两个情况，也是红黑树的分支由来，即左倾红黑树和右倾红黑树。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314143232558.png" alt="image-20210314143232558"></p>
<p>​    这里就可以看到颜色的意义，红色本身是没有任何含义的，红色的节点是要结合它的父树一起来看才能看出这棵红黑树树的含义。</p>
<ul>
<li>4节点。4节点和2节点相似，只存在一种情况，如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314143711140.png" alt="image-20210314143711140"></p>
<p>​    到此，就可以将任意的一个2-3-4树转换为红黑树，并且可以确定红黑树的颜色。但是因为3节点的存在，所以一个2-3-4树能转换为不同的红黑树，一个红黑树不能转换为多个2-3-4树。</p>
<h5 id="红黑树的性质解析"><a href="#红黑树的性质解析" class="headerlink" title="红黑树的性质解析"></a>红黑树的性质解析</h5><p>​    红黑树的性质上面已经说过了，并且也已经了解了2-3-4树和红黑树的互相转换，可以开始解析对应的五条性质了。</p>
<ul>
<li><p><strong>节点是要么红色或要么是黑色。</strong>这个性质还是比较好理解的，红黑树只存在黑色和红色，如果有其他颜色也就不叫红黑树了。需要注意的是如果一个红黑树全部存在黑色或者红色呢？也不是不可以，但是红黑树是来源于2-3-4树，全是黑色或者全是红色显然无法分辨出是2节点还是3节点，一个红黑树也就对应多个2-3-4树了。不符合要求，并且代码也无法实现。</p>
</li>
<li><p><strong>根一定是黑色节点。</strong>这个性质可能要思考一下，红黑树来源于2-3-4树，通过上面的转换不难发现无论是2、3还是4节点，最后转换为红黑树都是黑色节点在上。所以根节点就无论如何都是黑色的了。</p>
</li>
<li><p><strong>每个叶子结点都带有两个空的黑色结点（称之为NIL节点，它又被称为黑哨兵）。</strong>这个性质我现在还不是很理解，找了一下，大部分的解释是为了区分某些不属于红黑树的特殊情况，这里也留个坑吧，也欢迎大佬给出解答。而这也是为什么链表中通常会有哨兵节点的原因，就是为了避免各种判空，这样既容易出错也会让代码一团糟。</p>
</li>
<li><p><strong>每个红色节点的两个子节点都是黑色（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点）。</strong>这个性质也需要思考一会，还是那句话，红黑树来源于2-3-4树，看看2-3-4树什么情况下会转换为红色树，只有3和4节点，之前也说过红树是结合父树来看的，如果3节点增加红树，对应的就是4节点，但是4节点只存在唯一的情况，所以不行。4节点就更容易理解了，添加一个红树，变为5节点，但是5节点是临时态，实际是不应该存在的，最后还是会转换为其他形态。解释如下图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314150143548.png" alt="image-20210314150143548"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314150159674.png" alt="image-20210314150159674"></p>
</li>
<li><p>  <strong>从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点。</strong>这个性质也是能够理解的，通过上面的转换可以看到只有黑色节点代表一层，红色节点其实和父黑色节点同属于一层，所以黑色节点代表层数。同时红黑树是做了平衡的，和2-3-4树一样，到达子节点的层数都是一致的，即到达任何一个子节点的黑色节点树相同。</p>
</li>
</ul>
<h4 id="红黑树的操作及其分析"><a href="#红黑树的操作及其分析" class="headerlink" title="红黑树的操作及其分析"></a>红黑树的操作及其分析</h4><p>​    讲解完了红黑树的来源和性质，下面就可以讲解一下红黑树具体的操作和对这些操作的分析。</p>
<p>​    红黑树的平衡操作有三种：左旋转、右旋转、染色。下面就一一解析这些操作。具体的插入和操作放到下一片博客讲。</p>
<h5 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h5><p>​    左旋转的作用就是将一个向右倾斜的二叉树平衡，转化为左链接。如下示意图。（插入顺序为1-2-3）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310195710789.png" alt="image-20210310195710789"></p>
<p>​    通过将这个二叉树左旋，就是将1节点变为2节点的左节点，同时改变颜色（这一步骤其实不涉及染色）。变成如下图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310200014187.png" alt="image-20210310200014187"></p>
<h5 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h5><p>​    举一反三，看过上面就大致猜到了右旋转就是将左倾斜的二叉树平衡，转化为右链接。如下示意图。（插入顺序为3-2-1）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310200442968.png" alt="image-20210310200442968"></p>
<p>​    和上面的相反，将二叉树右旋，将3节点变为2节点的右节点。变成如下图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310200635557.png" alt="image-20210310200635557"></p>
<h5 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h5><p>​    旋转完后或者插入节点后，很大概率红黑树的节点颜色是不符合要求的，所以需要将红黑树节点的颜色进行改变，变成符合五条性质的红黑树。还是以上面的左旋转为例。</p>
<p>​    旋转完毕，但是不染色。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310201209652.png" alt="image-20210310201209652"></p>
<p>​    很明显不符合红黑树的性质4，所以要对节点的颜色进行变换，变成符合要求的如下的红黑树。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210310200635557.png" alt="image-20210310200635557"></p>
<p>​    </p>
<p>​    红黑树为了平衡的三个操作都已经了解了，剩下的就是实践了，这一部分比较耗费时间和画图。。。所以不再博客中叙述。只需要记住一点，无论经过什么操作，红黑树需要满足自身的平衡要求并且也要符合红黑树的五条性质，剩下的自己就是慢慢画和理解了。</p>
<p>​    这一部分也借鉴了其他人的成果，这里放上链接。</p>
<p><a href="https://segmentfault.com/a/1190000023715473?utm_source=sf-related">红黑树的操作解析</a></p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树的在线演示图，可以在这里验证自己的思路</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Java%E5%9F%BA%E7%A1%80/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8HashMap%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="红黑树在HashMap中的应用（二）"><a href="#红黑树在HashMap中的应用（二）" class="headerlink" title="红黑树在HashMap中的应用（二）"></a>红黑树在HashMap中的应用（二）</h2><p>​    上一篇博客讲述了红黑树的历史来源，阐述了红黑树的五条性质，并且解释了五条性质的原因。下面就来实际操作一下，讲解一下红黑树对于节点的插入和删除。</p>
<p>[TOC]</p>
<h3 id="红黑树的插入和删除"><a href="#红黑树的插入和删除" class="headerlink" title="红黑树的插入和删除"></a>红黑树的插入和删除</h3><p>​    在之前不止一次的说过红黑树来源于2-3-4树，所以插入和删除也是，不了解2-3-4树的插入、删除操作，很难直接上手红黑树。本文的结构就如此，先介绍2-3-4树的插入、删除操作，再去解析红黑树的对应操作。</p>
<h4 id="2-3-4树的插入、删除操作"><a href="#2-3-4树的插入、删除操作" class="headerlink" title="2-3-4树的插入、删除操作"></a>2-3-4树的插入、删除操作</h4><h5 id="2-3-4树的节点插入"><a href="#2-3-4树的节点插入" class="headerlink" title="2-3-4树的节点插入"></a>2-3-4树的节点插入</h5><p>​    2-3-4树的插入分为几个情况，2节点、3节点、4节点。下面就一一解释和画图举例。</p>
<ul>
<li>2节点插入。这个比较简单，直接将2节点转换为3节点即可。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314162205713.png" alt="image-20210314162205713"></p>
<ul>
<li>3节点插入。这个和2节点差不多，因为最大允许4节点，所以直接插入即可。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314163816142.png" alt="image-20210314163816142"></p>
<ul>
<li>4节点插入。这个需要做一下变换，因为5节点是不存在的，所以需要将3个元素的中间元素上移，在放置插入元素即可。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210314164631591.png" alt="image-20210314164631591"></p>
<p>到这里，2-3-4的插入就完成了，下面就要讲一下删除了。</p>
<h5 id="2-3-4树的节点删除"><a href="#2-3-4树的节点删除" class="headerlink" title="2-3-4树的节点删除"></a>2-3-4树的节点删除</h5><p>​    删除操作比较复杂一点，分为2节点删除和3、4节点删除，为什么分为两个，下面就清楚了。</p>
<ul>
<li><p>3、4节点删除。直接删除即可。因为是大于2的节点，所以这个时候树的高度没有发生变化，只需要合并子节点或者将子节点用于补位即可。这里就不再画图了，因为情况有些多。</p>
</li>
<li><p>2节点删除。2节点删除网上也有许多方案，这里使用下面这个思路：将当前节点变为大于2节点。或者说，不让删除节点出现在2节点中。分为三个情况。</p>
<ul>
<li>父节点和兄弟节点都大于2.这个情况将父节点中的一个元素下调至删除节点，形成一个3节点。兄弟节点将一个元素上调到父节点。完成删除。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210315201220749.png" alt="image-20210315201220749"></p>
<ul>
<li>父节点为大于2节点，兄弟节点为2节点。父节点下调一个元素，和删除元素、兄弟节点一起组成4节点，最后删除要删除的元素。完成删除。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210315201735601.png" alt="image-20210315201735601"></p>
<ul>
<li>父节点和兄弟节点都为2节点。父节点下调和删除节点、兄弟节点组成临时节点，删除要删除的节点。完成。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210315201929131.png" alt="image-20210315201929131"></p>
</li>
</ul>
<p>​    删除到这里就结束了，当删除元素为2节点并且没有兄弟节点时，无论父节点为几节点，直接删除即可。</p>
<p>​    2-3-4树的插入和删除到这里就暂时结束了，开始编写解析红黑树的插入和删除了。这里水平有限，有些地方可能想的不是很全面，欢迎大佬们的指正。这里借鉴了知乎的回答。连接如下：</p>
<p><a href="https://www.zhihu.com/question/312327402/answer/1560653215">知乎关于红黑树的回答</a></p>
<h4 id="红黑树的插入、删除操作"><a href="#红黑树的插入、删除操作" class="headerlink" title="红黑树的插入、删除操作"></a>红黑树的插入、删除操作</h4><p>​    终于讲解到红黑树的插入和删除了，和上面的一样，先分析红黑树的插入（比较简单），然后再去分析红黑树的删除。这里红黑树的基本操作：左旋转、右旋转和染色默认大家都已经清楚了，如果不是很清楚，可以看一下上一篇博客。<a href="https://blog.csdn.net/qq_38533859/article/details/114789173?spm=1001.2014.3001.5501">红黑树在HashMap中的应用（一）</a></p>
<p>​    因为红黑树也分为多种，这里以左倾红黑树为例。</p>
<h5 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h5><p>​    红黑树的插入的节点默认为红色，上面也能看出，2-3-4树的插入默认都是当前节点，所以红黑树的插入的节点都是临时节点，默认为红色。插入有两种大情况，插入元素的父亲是红色、插入元素的父亲是黑色。下面就一一解析。</p>
<ul>
<li> <strong>插入元素比黑父小</strong>。因为是左倾红黑树，所以当黑父的左节点不存在时，一定没有右节点。所以这种情况直接插入即可。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323100150896.png" alt="image-20210323100150896"></p>
<ul>
<li><strong>插入元素比黑父大</strong>。这时分为两个情况。<ul>
<li><strong>当黑父没有左节点时</strong>，直接左旋转黑父、再将父节点和插入节点换色即可。</li>
<li><strong>当黑父有左节点时</strong>，因为这个时候没有破坏红黑树的性质，所以也是直接插入即可。</li>
</ul>
</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323100513177.png" alt="image-20210323100513177"></p>
<p>​    因为红父是要结合它的黑父节点一起看的，并且红黑树来源于2-3-4树，所以存在红父的情况只有3节点、4节点。3节点和4节点的区别只有红父是否存在兄弟节点。所以红父的情况分为了四种：插入节点有叔父节点且比红父小、插入节点有叔父节点且比红父大、插入节点没有叔父节点且比红父小、插入节点没有叔父节点且比红父大。</p>
<p>​    注意：此时叔父节点不可能为黑色，要不然插入之前的树就不符合红黑树的定义五。</p>
<ul>
<li><strong>插入节点有叔父节点且比红父小。</strong>这个形态对应的是2-3-4树的4节点，所以要此时的临时5节点分裂，将树的高度加一，即将叔父节点和红父节点的颜色与祖父节点互换。因为比红父小，所以符合左倾红黑树要求。但是这时，祖父节点因为变换了颜色，所以将祖父节点当作插入节点，再执行修复操作。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323103124602.png" alt="image-20210323103124602"></p>
<ul>
<li><strong>插入节点有叔父节点且比红父大。</strong>这个形态和上面类似，不过因为比红父大，所以不符合左倾红黑树的要求，需要再做一个转换。这里就不再画图了，脑中过一遍就能理解。</li>
<li><strong>插入节点没有叔父节点且比红父小。</strong>这个形态对应2-3-4树的3节点，插入此节点不会导致高度的变化，所以就是需要将红父进行右旋转。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323111003906.png" alt="image-20210323111003906"></p>
<ul>
<li><strong>插入节点没有叔父节点且比红父大。</strong>此时树应该是右倾的，所以需要将树变为左倾，再转换为上面步骤即可，如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323112156656.png" alt="image-20210323112156656"></p>
<p>​    这些插入结束后需要注意一点，因为祖父节点产生了变化，所以需要对祖父节点进行回溯，即将祖父节点当作插入节点，在执行这个步骤，直到根节点符合要求。    </p>
<p>至此，红黑树的插入就全部例举完毕了，同时需要注意还有一点是不是对红黑树的理解又加深了？因为本人水平有限，可能有些地方有误或者不清晰，欢迎大佬的指正。</p>
<h5 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h5><p>​    红黑树的删除比较复杂，考虑的情况要比插入多一些。这里也是举例说明，希望自己能够理清，也欢迎大家指正。</p>
<h6 id="了解删除前需要了解的"><a href="#了解删除前需要了解的" class="headerlink" title="了解删除前需要了解的"></a>了解删除前需要了解的</h6><p>​    了解删除前需要了解一些知识点。关于二叉树通用的删除策略。</p>
<ul>
<li>删除某个节点时，可以选择该节点的前驱节点或者后继节点来替代它。这个需要思考一下，并不是很难。<ul>
<li>前驱节点：该节点的左子树的最右节点。</li>
<li>后继节点：该节点的右子树的最左节点。</li>
</ul>
</li>
</ul>
<h6 id="红黑树删除的情况"><a href="#红黑树删除的情况" class="headerlink" title="红黑树删除的情况"></a>红黑树删除的情况</h6><p>​    红黑树删除分为三个大情况，三个大情况又各自进行细分。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323182608315.png" alt="image-20210323182608315"></p>
<p>​    下面就需要对没有子节点的情况进行分析。</p>
<ul>
<li> 删除节点为红色：因为红色对应着2-3-4树的3、4节点，由上面可知，直接删除即可。没有什么好说的。结果如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323182954212.png" alt="image-20210323182954212"></p>
<ul>
<li><p>删除节点为黑色。因为黑色其实代表了一个2-3-4中的一个层级，删除层级肯定对红黑树的实际高度有影响，所以需要做一定的调整。并且按照上面的步骤，删除的黑色节点其实对应了2-3-4树中删除2节点，所以删除红黑树的黑色子叶节点需要观察父节点和兄弟节点，这也是网上大家都这样说的原因。这样就简单了，按照2-3-4树进行理解和分析吧。</p>
<p>还是先说说情况，总共有六种，但是中间一些情况的处理时一样的。情况如下图：（因为为左倾红黑树，所以不存在兄弟节点为红色）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323204709003.png" alt="image-20210323204709003"></p>
<ul>
<li>当兄没有红子节点时，无论父是否为红，最后都变为父黑兄红。其实对应了2-3-4树中的删除2节点时，兄弟节点也为2节点。最后都是父节点和兄弟节点组成一个三节点的子树。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323211215752.png" alt="image-20210323211215752"></p>
<ul>
<li>当兄有一个红色节点时，无论父是否为红，最后都是兄弟节点代替父节点、父节点代替删除节点、兄弟子节点代替兄弟节点。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323211409899.png" alt="image-20210323211409899"></p>
<ul>
<li>当兄弟有两个红色时，无论父是否红，最后都是兄弟节点代替父节点、父节点代替删除节点、兄弟节点的左节点挂在删除节点下、兄弟节点的右节点代替兄弟节点、最后父节点再左旋转。如下图：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210323211559996.png" alt="image-20210323211559996"></p>
</li>
</ul>
<p>​    至此，红黑树的删除也讲完了。这一块不是很容易理解，我画的图也不会动，所以最后还是需要靠自己去一点点想象（。。。）中间也看了很多的博客，对于自己的理解有很大的帮助，下面就放上链接。</p>
<p><a href="https://segmentfault.com/a/1190000023715473?utm_source=sf-related">删除操作类举比较详细</a></p>
<p><a href="https://www.zhihu.com/question/312327402/answer/1560653215">红黑树的插入讲的不错</a></p>
<p>​    上面的链接只是个人的判断，当你理解其含义后，各个方法也就能懂其意思了。</p>
<p>​    讲完了红黑树的插入和删除，下面就要上实现代码了，这里直接阅读JDK的源码，分析一下HashMap中红黑树的实现（讲到现在终于靠题了）。这篇博客花了很长的时间，后面也会单独分析一下原因，技术应该没有如此难学。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Linux%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="第七章、Linux文件系统"><a href="#第七章、Linux文件系统" class="headerlink" title="第七章、Linux文件系统"></a>第七章、Linux文件系统</h2><h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><ul>
<li><p>Linux的EXT2文件系统</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_3DFC7CA9B512-1.jpeg" alt="IMG_3DFC7CA9B512-1"></p>
<ul>
<li><p>Data block 是用来放置文件内容数据的地方。Ext2系统中所支持的blokc大小有1、2，4K三种。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_2488E99AAFB4-1.jpeg" alt="IMG_2488E99AAFB4-1"></p>
</li>
<li><p>Inode table 是记录文件的属性以及该文件实际数据是放在哪个block中的。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_F2D95A3DEA87-1.jpeg" alt="IMG_F2D95A3DEA87-1"></p>
<p>inode还有下面的特点。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_7173E6AAB4C5-1.jpeg" alt="IMG_7173E6AAB4C5-1"></p>
<p>inode的记录结构图，最小的1K的block可以容纳16GB的文件。<code>12+256+256*256+256*256*256=16GB</code></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_B0821E59ADEE-1.jpeg" alt="IMG_B0821E59ADEE-1"></p>
</li>
<li><p>Superblock记录整个filesystem相关信息的地方。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_163F8E9E2A81-1.jpeg" alt="IMG_163F8E9E2A81-1"></p>
</li>
<li><p>Filesytem Description（文件系统描述说明）描述每个block group的开始与结束的block号码，以及说明每个区段分别介于哪一个block号码之间。</p>
</li>
<li><p>Block bitmap(区块对照表)记录系统中空的block号码。</p>
</li>
<li><p>Inode bitmap（inode 对照表）记录未使用的inode号码。</p>
</li>
<li><p><code>dumpe2fs</code> 查询Ext家族superblock信息的指令。（不常用）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_51A8DF0CE1DB-1.jpeg" alt="IMG_51A8DF0CE1DB-1"></p>
</li>
<li><p>文件的读取流程</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_7F443C85D318-1.jpeg" alt="IMG_7F443C85D318-1"></p>
</li>
</ul>
</li>
<li><p>XFS文件系统简介</p>
<ul>
<li><p>资料区。分为多个存储群组，每个群组包含（1）整个文件系统的 superblock、 (2)剩余空间的管理机制、 (3)inode 的分配与追踪。</p>
</li>
<li><p>文件系统活动登录区。主要记录文件系统的变化，有点类似于日志区。</p>
</li>
<li><p>实时运作区。记录extent区块的信息。</p>
</li>
<li><p><code>xfs_info</code>指令的用法</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_368E80FB9615-1.jpeg" alt="IMG_368E80FB9615-1"></p>
</li>
</ul>
</li>
<li><p>文件系统的简单操作</p>
<ul>
<li><p><code>df</code>列出文件系统的整体磁盘使用量</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_0AAC648A473B-1.jpeg" alt="IMG_0AAC648A473B-1"></p>
</li>
<li><p><code>du</code>评估文件系统的磁盘使用量</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_01964E14EB78-1.jpeg" alt="IMG_01964E14EB78-1"></p>
</li>
</ul>
</li>
<li><p>实体链接与符号链接</p>
<ul>
<li><p><code>ln</code>制作链接档。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_C5F5EAF2A276-1.jpeg" alt="IMG_C5F5EAF2A276-1"></p>
<ul>
<li><p>Hard Link（实体链接，硬式连结或实际连结）在某个目录下新增一笔档名链接到某inode号码的关联记录。</p>
</li>
<li><p>Symbolic Link(符号链接，类似于快捷方式) 建立一个独立的文件，而这个文件会让数据的读取指向link的那个文件档名。会创建新的inode和block，但是要比原档名小的多。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘的分区、格式化、检验与挂载</p>
<ul>
<li><p><code>lsblk</code>列出系统上所有的磁盘列表。<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_881CF83F6037-1.jpeg" alt="IMG_881CF83F6037-1"></p>
</li>
<li><p><code>blkid</code>列出装置的UUID等参数</p>
</li>
<li><p><code>parted</code>列出磁盘的分区表类型与分区信息</p>
</li>
<li><p>分区的步骤：先通过<code>lsblk</code>或者<code>blkid</code>找到磁盘，再通过<code>parted /dev/xxx print</code> 找到该磁盘的分区类型，之后通过<code>fdisk</code>(MBR分区)或者<code>gdisk</code>(GPT分区)来操作磁盘。</p>
</li>
<li><p><code>mkfs.xfs</code>命令是建置文件系统</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_C576B170E89D-1.jpeg" alt="IMG_C576B170E89D-1"></p>
</li>
<li><p>EXT4文件系统的<code>mkfs.ext4</code></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_D34A4CD5C7F0-1.jpeg" alt="IMG_D34A4CD5C7F0-1"></p>
</li>
</ul>
</li>
<li><p>文件系统的检验</p>
<ul>
<li><p><code>xfs_repair</code>处理XFS文件系统<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_ED943AA7B08E-1.jpeg" alt="IMG_ED943AA7B08E-1"></p>
</li>
<li><p><code>fsck.ext4</code>处理EXT4文件系统</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_1AC76C5CAAB8-1.jpeg" alt="IMG_1AC76C5CAAB8-1"></p>
</li>
</ul>
</li>
<li><p>文件系统的挂载和卸除</p>
<ul>
<li><p><code>mount</code>挂载使用到的命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_EF0C6D310CCA-1.jpeg" alt="IMG_EF0C6D310CCA-1"></p>
</li>
<li><p><code>umount</code>将装置文件卸除的命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_D4FFFBEBEEE1-1.jpeg" alt="IMG_D4FFFBEBEEE1-1"></p>
</li>
</ul>
</li>
<li><p>设置开机挂载</p>
<ul>
<li><p>/etc/fstab文件内容</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200421091505802.png" alt="image-20200421091505802"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_DA7EB7846934-1.jpeg" alt="IMG_DA7EB7846934-1"></p>
<ul>
<li><p>磁盘装置文件名/UUID/LABEL name。 例子：/dev/vda2.  UUID=xxx.  LABEL=xxx</p>
</li>
<li><p>挂载点。一定要是目录</p>
</li>
<li><p>磁盘分区槽的文件系统。如xfs,ext4,vfat,reiserfs,nfs</p>
</li>
<li><p>文件系统参数</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_01E1BA15FC1D-1.jpeg" alt="IMG_01E1BA15FC1D-1"></p>
</li>
<li><p>能否被dump备份指令作用。0即可</p>
</li>
<li><p>是否以fsck检验扇区。xfs文件系统会自己检查，直接填0即可</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特殊装置loop挂载</p>
<ul>
<li><p>以挂载一个文件为例</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200421134709795.png" alt="image-20200421134709795"></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200421134803389.png" alt="image-20200421134803389"></p>
<p>步骤：1.建立大型文件。2.大型文件格式化。3.将大型文件挂载到目录（通过UUID的形式）</p>
<ul>
<li><p>内存置换空间（swap）之建置（用处不大，看看就可以）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_57EEF927240A-1.jpeg" alt="IMG_57EEF927240A-1"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Linux%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="第九章、vim程序编辑器"><a href="#第九章、vim程序编辑器" class="headerlink" title="第九章、vim程序编辑器"></a>第九章、vim程序编辑器</h2><ul>
<li><p>vi的基础了解</p>
<p>vi分为三种模式，<code>一般命令模式</code>，<code>编辑模式</code>，<code>指令列命令模式</code>。</p>
<ul>
<li>一般指令模式。默认就是一般指令模式，在该模式下可以使用上下左右进行光标移动，也可以使用指令对处理文本内容，如：复制，删除…</li>
<li>编辑模式。按下<code>i,I,o,O,a,A,r,R</code>中任何一个字母后进入编辑模式，左下方会出现[INSERT],[REPLACE]的提示。退出编辑模式只需要按[esc]键即可。</li>
<li>指令列命令模式。一般模式中，输入<code>:/?</code>三个按钮中任何一个就可以进入指令列命令模式。光标会移动到最底下那一列。对文档的额外操作可以通过指令列命令模式进行</li>
</ul>
</li>
<li><p>按键说明</p>
<p> <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_938F47F946DA-1.jpeg" alt="IMG_938F47F946DA-1"></p>
<p> <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_0813AAE3737A-1.jpeg" alt="IMG_0813AAE3737A-1"></p>
<p> <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_26DFD8F9FEE6-1.jpeg" alt="IMG_26DFD8F9FEE6-1"></p>
<p> <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_17D2939DE8E2-1.jpeg" alt="IMG_17D2939DE8E2-1"></p>
<p> <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_6A4E09F4473D-1.jpeg" alt="IMG_6A4E09F4473D-1"></p>
<p> <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_28496E1077AB-1.jpeg" alt="IMG_28496E1077AB-1"></p>
<p> 操作练习</p>
<p> <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_855740C3FF9C-1.jpeg" alt="IMG_855740C3FF9C-1"></p>
</li>
<li><p>vi的暂存档。当使用vi编辑时，会在同目录下创建一个.filename.swp的文件。当突然中断后，会出现这个页面。</p>
<p> <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200426111858492.png" alt="image-20200426111858492"></p>
<p> 按照需要的方式输入字母即可。</p>
</li>
<li><p>区块选择</p>
</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_E542292E6459-1.jpeg" alt="IMG_E542292E6459-1"></p>
<ul>
<li><p>多文件编辑</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_FBF7D5BD084E-1.jpeg" alt="IMG_FBF7D5BD084E-1"></p>
</li>
<li><p>多窗口编辑</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A658F1E6441A-1.jpeg" alt="IMG_A658F1E6441A-1"></p>
</li>
<li><p>vim的补全功能。没有搞明白，后续有知道的可以补充一下。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_2453B42FB883-1.jpeg" alt="IMG_2453B42FB883-1"></p>
</li>
<li><p>vim的环境设定与记录</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_F5422405CB23-1.jpeg" alt="IMG_F5422405CB23-1"></p>
</li>
<li><p>vim常用的命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_24AC0E8650BF-1.jpeg" alt="IMG_24AC0E8650BF-1"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Linux%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h2 id="第八章、文件与文件系统的压缩、打包和备份"><a href="#第八章、文件与文件系统的压缩、打包和备份" class="headerlink" title="第八章、文件与文件系统的压缩、打包和备份"></a>第八章、文件与文件系统的压缩、打包和备份</h2><ul>
<li><p>Linux常见的压缩命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_BCF8665FBBD5-1.jpeg" alt="IMG_BCF8665FBBD5-1"></p>
<ul>
<li><p><code>gzip</code>压缩命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_6583B53AC8BC-1.jpeg" alt="IMG_6583B53AC8BC-1"></p>
</li>
<li><p><code>bzip2</code>压缩命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_5C7656007A22-1.jpeg" alt="IMG_5C7656007A22-1"></p>
</li>
<li><p><code>xz</code>压缩命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_C8C028350B6E-1.jpeg" alt="IMG_C8C028350B6E-1"></p>
</li>
</ul>
</li>
<li><p><code>tar</code>打包命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A140720C58E7-1.jpeg" alt="IMG_A140720C58E7-1"></p>
<ul>
<li><p>压缩<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200425104505375.png" alt="image-20200425104505375"></p>
</li>
<li><p>解压</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200425105144263.png" alt="image-20200425105144263"></p>
</li>
<li><p>解压某个文件，这个压缩文件仍然在压缩包里面。<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200425105817037.png" alt="image-20200425105817037"></p>
</li>
<li><p>打包某个目录，但不打包某些文件</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200426091434124.png" alt="image-20200426091434124"></p>
</li>
<li><p>利用管线命令将目录复制到另外的地方。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_DA0A5D46ECC1-1.jpeg" alt="IMG_DA0A5D46ECC1-1"></p>
</li>
</ul>
</li>
<li><p>XFS文件系统的备份和还原</p>
<ul>
<li><p><code>xfsdump</code>对XFS文件系统备份</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_88F902852F05-1.jpeg" alt="IMG_88F902852F05-1"></p>
</li>
<li><p><code>xfsrestore</code>对XFS文件系统还原</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_96D8641A09A2-1.jpeg" alt="IMG_96D8641A09A2-1"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Linux%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="第六章、Linux文件与目录管理"><a href="#第六章、Linux文件与目录管理" class="headerlink" title="第六章、Linux文件与目录管理"></a>第六章、Linux文件与目录管理</h2><h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><ul>
<li><p><code>ls</code>命令</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_E867F1DE7BD3-1.jpeg" alt="IMG_E867F1DE7BD3-1"></p>
</li>
<li><p>复制、删除与移动  <code>cp</code>,<code>rm</code>,<code>mv</code><br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_83380C6DF2B8-1.jpeg" alt="IMG_83380C6DF2B8-1"></p>
<h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3></li>
<li><p><code>cat</code>：从第一行显示到最后一行<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_76BB5886D069-1.jpeg" alt="IMG_76BB5886D069-1"></p>
</li>
<li><p><code>tac</code>：从最后一行显示到第一行        </p>
</li>
<li><p><code>nl</code>：显示的时候显示行号<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_14F24DA98032-1.jpeg" alt="IMG_14F24DA98032-1"></p>
</li>
<li><p><code>more</code>：一页一页的显示文本<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_F97B32F53055-1.jpeg" alt="IMG_F97B32F53055-1"></p>
</li>
<li><p><code>less</code>：一页一页显示文本，但是可以往前翻页<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_777F6AABB74F-1.jpeg" alt="IMG_777F6AABB74F-1"></p>
</li>
<li><p><code>head</code>：只看头几行<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_B955711F9456-1.jpeg" alt="IMG_B955711F9456-1"></p>
</li>
<li><p><code>tail</code>：只看后面几行<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_9D3335EA23B0-1.jpeg" alt="IMG_9D3335EA23B0-1"></p>
</li>
<li><p><code>od</code>：以二进制的形式读取文件内容<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_1F0EC4C06432-1.jpeg" alt="IMG_1F0EC4C06432-1"><br>取一个文件11行到20行到内容<br><code>head -n 20 /test.txt | tail -n 10    </code><br>管线符号<code>｜</code>：前面的指令所输出的信息，通过管线命令交给后续指令继续使用<br>显示行号：<code>cat -n test.txt | head -n 20 | tail -n 10</code>        </p>
</li>
<li><p><code>touch</code>修改文件时间或创建一个新的文档<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_F1CC616035BD-1.jpeg" alt="IMG_F1CC616035BD-1">            </p>
</li>
</ul>
<h3 id="文件与目录的默认权限和隐藏权限"><a href="#文件与目录的默认权限和隐藏权限" class="headerlink" title="文件与目录的默认权限和隐藏权限"></a>文件与目录的默认权限和隐藏权限</h3><p><code>umask</code>指定用户在创建文件或者目录时的默认权限值<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_00741A334223-1.jpeg" alt="IMG_00741A334223-1"><br>默认权限值代表的意思<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_39339A93FE77-1.jpeg" alt="IMG_39339A93FE77-1"></p>
<ul>
<li><p><code>chattr</code>配置文件隐藏的属性（和下面的一个命令一样不是很常用）<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_DDB37D20B3DD-1.jpeg" alt="IMG_DDB37D20B3DD-1"></p>
</li>
<li><p><code>lsattr</code>显示文件的隐藏属性</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_8CF328C04A07-1.jpeg" alt="IMG_8CF328C04A07-1"></p>
</li>
<li><p>文件的特殊权限：SUID,SGID,SBIT</p>
<p>SUID指文件的执行者在执行程序时拥有文件拥有者相同的权限，一般出现在文件拥有者的x权限上。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_27D05CA751BD-1.jpeg" alt="IMG_27D05CA751BD-1"></p>
<p>SGID是SUID的升级版，升级为文件的群组。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_8541875233A9-1.jpeg" alt="IMG_8541875233A9-1"></p>
<p>SBIT只针对目录，在该目录下创建的文件只有自己或者root才能修改或者删除</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_9CF18B040559-1.jpeg" alt="IMG_9CF18B040559-1"></p>
<p>授权上面的三种特殊权限可以通过数字或者字符</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200412204346040.png" alt="image-20200412204346040"></p>
</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200412204449320.png" alt="image-20200412204449320"></p>
<ul>
<li><code>file</code>命令用来查看文件的类型</li>
<li><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_31B8AC9CC1EB-1.jpeg" alt="IMG_31B8AC9CC1EB-1"></li>
</ul>
<h3 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h3><ul>
<li><p><code>which</code>寻找可执行的文档</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_2760EE6A96EE-1.jpeg" alt="IMG_2760EE6A96EE-1"></p>
</li>
<li><p><code>whereis</code>寻找系统中某些特定目录底下的文件(用处估计不是很多，但是速度快)</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_00AD66018E29-1.jpeg" alt="IMG_00AD66018E29-1"></p>
</li>
<li><p><code>locate</code>命令是在系统建立的数据库（一天修改一次的数据库）中查询文件。一般配合<code>updatedb</code>使用（用到的地方也是很少）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_1169BF8BB661-1.jpeg" alt="IMG_1169BF8BB661-1"></p>
</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_4F1C1F7A6DD6-1.jpeg" alt="IMG_4F1C1F7A6DD6-1"></p>
<ul>
<li><p><code>find</code>命令是一个非常强大的命令的，但是是因为直接读取的硬盘，所以速度没有上面两个快。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_7FC983BD2FC3-1.jpeg" alt="IMG_7FC983BD2FC3-1"></p>
</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_D52E7DA4D5A9-1.jpeg" alt="IMG_D52E7DA4D5A9-1"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_FD693BD4905F-1.jpeg" alt="IMG_FD693BD4905F-1"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_3EDE5760B28D-1.jpeg" alt="IMG_3EDE5760B28D-1"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A65852973ABA-1.jpeg" alt="IMG_A65852973ABA-1"></p>
<p>自己的理解，和管线命令类似。但是是以参数的形式<img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200412214544680.png" alt="image-20200412214544680"></p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Linux%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E5%AD%A6%E4%B9%A0BASH/</url>
    <content><![CDATA[<h2 id="第十章、学习BASH"><a href="#第十章、学习BASH" class="headerlink" title="第十章、学习BASH"></a>第十章、学习BASH</h2><p>​    这次就来学习一下最基础的BASH，下面直接开搞。</p>
<ul>
<li><code>type</code>命令</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A2A285D5741D-1.jpeg" alt="IMG_A2A285D5741D-1"></p>
<ul>
<li><p><code>echo</code>读取变量的内容</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_E19EBBDADCF9-1.jpeg" alt="IMG_E19EBBDADCF9-1"></p>
</li>
<li><p>关于引号</p>
<p>单引号赋值只会赋值引号内的内容，双引号可以保存变量的内容，反引号会先执行。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200621082943077.png" alt="image-20200621082943077"></p>
</li>
<li><p>环境变量</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_01BE4759785E-1.jpeg" alt="IMG_01BE4759785E-1"></p>
<ul>
<li>提示变量的设定</li>
</ul>
<p>提示变量就是你执行命令前面的东西，这个其实是可以设置的。下面就介绍一下。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_65F50926A71F-1.jpeg" alt="IMG_65F50926A71F-1"></p>
<p>设置就是这个样子，很有意思，可以按照上面的信息自己设置一下。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200629232612846.png" alt="image-20200629232612846"></p>
<ul>
<li><p>$ 符的使用</p>
<p>就是代表的当前Sheel的线程代号（就是PID）。如下图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200629233227290.png" alt="image-20200629233227290"></p>
</li>
<li><p>? 符的使用</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_DDDB2B3AAC11-1.jpeg" alt="IMG_DDDB2B3AAC11-1"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200629233555410.png" alt="image-20200629233555410"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/SpringCloud/SpringCloud%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="SpringCloud基础了解"><a href="#SpringCloud基础了解" class="headerlink" title="SpringCloud基础了解"></a>SpringCloud基础了解</h2><h3 id="SpringCloud背景和基础知识"><a href="#SpringCloud背景和基础知识" class="headerlink" title="SpringCloud背景和基础知识"></a>SpringCloud背景和基础知识</h3><p>​    随着技术的慢慢发展，单一的应用很难满足目前用户的需求的。例如现在最简单的商场应用，用户下单后，需要创建订单服务，再创建库存服务、快递服务、如果有可能还会有会员积分服务。所以目前单一的应用去做这些事情很困难，能够完成，但是中间要花费大量的时间和精力去处理服务之间的协调和通信问题。SpringCloud就应用而生，和SpringBoot的产生一样，也是轻量级，让开发人员更加专注的开发业务代码，而不是和业务无关的代码。由此可见，这也是目前主流工具的开发方向。</p>
<p>​    想要了解SpringCloud需要先了解SpringBoot，因为都是Spring的全家桶，所以SpringCloud是基于SpringBoot的。关于SpringBoot的介绍这里就不再累述了，很多文档包括我也写了一些。其实在我看来，因为这些脚手架的原因，现在开发人员甚至不用关注底层原理，直接就可以开发。所以SpringBoot只要会大致写一个HelloWorld，就可以看关于SpringCloud的文档了。但是一旦底层出现一些问题，这些人又完全没有方法。短期看，Spring对于编程的发展有一定的好处，但是长远看，会使得编程人员往更高级的语言发展（但是Java本身就是高级语言啊）或者后来的编程人员越来越原理这里底层原理。无论哪种都不是很好的结果。（说多了，开始吧）</p>
<h3 id="SpringCloud的核心组件"><a href="#SpringCloud的核心组件" class="headerlink" title="SpringCloud的核心组件"></a>SpringCloud的核心组件</h3><ul>
<li><p>服务发现——Netflix Eureka。通过这个组件可以将服务注册到Eureka服务端中，服务端则将所有的服务的机器和端口号记录下来。当调用服务时，向注册中心查询注册表即可。</p>
</li>
<li><p>客服端负载均衡——Netflix Ribbon。这个组件是为了提供客户侧的软件负载均衡算法。Ribbon的负载均衡默认使用的最经典的<strong>Round Robin轮询算法</strong>。</p>
</li>
<li><p>HTTP客户端——OpenFeign。简化调用服务时的工作，将复杂的请求简化为配置，使用动态代理来构造出需要请求的服务地址，最后发起请求和解析请求。</p>
</li>
<li><p>断路器——Netflix Hystrix。为了避免雪崩现象，使用Hystrix来解决这个问题。Hystrix是隔离、熔断以及降级的一个框架。当某个服务挂掉后，Hystrix首先熔断，在一定时间后直接返回，但是不能直接返回，需要降级，把这个错误或者异常记录，在服务恢复后继续执行。</p>
</li>
<li><p>服务网关——Netflix Zuul。各个服务因为请求地址不同，前端做分离是不现实的，所以采用路由的形式，将前端的请求统一从路由过，再由路由转发给对应的服务。</p>
</li>
</ul>
<h3 id="记在后面的话"><a href="#记在后面的话" class="headerlink" title="记在后面的话"></a>记在后面的话</h3><p>​    其实把上面的看完就可以理解这些组件设计的目的了，总的来说，SpringCloud的组件虽然都是轻量级的，但是普通的应用拆分服务的很少，所以还是有一定体量的才会上微服务，所以保证这些服务和应用正常工作就显得格外重要，各个组件也是为了保证这一点。作为码农，了解各个模块和组件的作用非常重要，要比一个demo重要的多。后面我也会慢慢的搭建一个简单的SpringCloud框架。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/SpringCloud/SpringCloud%E9%9B%86%E6%88%90Eureka/</url>
    <content><![CDATA[<h2 id="SpringCloud集成Eureka"><a href="#SpringCloud集成Eureka" class="headerlink" title="SpringCloud集成Eureka"></a>SpringCloud集成Eureka</h2><p>​    下面就开始简单的写一个demo，先把组件慢慢都集成进来，先集成Eureka。</p>
<h3 id="创建父模块"><a href="#创建父模块" class="headerlink" title="创建父模块"></a>创建父模块</h3><p>​    父模块需要创建maven项目，这里没有找到基础的方法，就是不使用任何IDE去生成项目，所以最后无奈只能使用IDEA来生成这些项目。</p>
<p>​    首先选择maven，再输入自己项目的信息。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200602152019621.png" alt="image-20200602152019621"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200602141047248.png" alt="image-20200602141047248"></p>
<p>​    输入完成后，删除src目录，只保留一个pom文件，加入SpringBoot依赖即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建Eureka服务注册中心"><a href="#创建Eureka服务注册中心" class="headerlink" title="创建Eureka服务注册中心"></a>创建Eureka服务注册中心</h3><p>​    新建一个模块，根据spring的配置添加相应的依赖即可。这里需要注意一下。</p>
<p>​    我的IDE不知道抽什么风，一直连接不上springio，IDEA的代理配置能测试成功，但是到创建模块时死活不行，修改代理、用VPN、改地址为http，网上能找到的方法都试了，还是不行。最后放弃了，用的阿里云的spring镜像服务器。如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200602142009357.png" alt="image-20200602142009357"></p>
<p>​        中间有些步骤我给省略了，没有什么可讲的地方，下面就是选择依赖。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200602142110037.png" alt="image-20200602142110037"></p>
<p>​    后面就创建成功了，修改Eureka的配置即可。修改如下。</p>
<h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><p>​    pom文件需要修改父类依赖指向，指向刚才创建的父模块。EurekaServer依赖刚才创建模块的时候就已经导入了，不需要了。另外，看自己的需求导入健康检查依赖，这里我没有使用，就没有导入。pom文件全部代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.psq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssodemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.psq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>this is Eureka Server<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR4<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- eureka依赖       --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 健康检查依赖       --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="application-yml文件"><a href="#application-yml文件" class="headerlink" title="application.yml文件"></a>application.yml文件</h4><p>​    application.yml文件需要对项目做一个基础的配置，这里按照自己的需求配置就可以了。因为只是引入了Eureka，所以配置文件很少。另外，刚创建项目的时候是application.properties，命名为application.yml文件即可，要注意这两个文件虽然Spring都支持，但是这俩种文件的书写格式不一样。配置文件代码如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################### common config : ####################################</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8080</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##eureka服务段配置</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://127.0.0.1:8080/eureka</span></span><br><span class="line">  <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">renewal-percent-threshold</span>: <span class="string">0.49</span></span><br></pre></td></tr></table></figure>

<h4 id="启动类添加Eureka注解"><a href="#启动类添加Eureka注解" class="headerlink" title="启动类添加Eureka注解"></a>启动类添加Eureka注解</h4><p>​    启动类添加注解即可，添加一个<code>@EnableEurekaServer</code>注解，然后启动服务就可以了。</p>
<h4 id="启动结果及其验证方法"><a href="#启动结果及其验证方法" class="headerlink" title="启动结果及其验证方法"></a>启动结果及其验证方法</h4><p>​    启动单个模块，然后在浏览器输入<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a>，出现下面的页面就代表成功了。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-06-02%20%E4%B8%8B%E5%8D%882.59.01.png" alt="截屏2020-06-02 下午2.59.01"></p>
<h3 id="创建Eureka客户端"><a href="#创建Eureka客户端" class="headerlink" title="创建Eureka客户端"></a>创建Eureka客户端</h3><p>​    创建模块的步骤和上面一致，不过依赖和相应的配置需要修改一下。</p>
<h4 id="pom文件-1"><a href="#pom文件-1" class="headerlink" title="pom文件"></a>pom文件</h4><p>​    没有什么可以讲的地方。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.psq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssodemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.psq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka-client<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>this is Eireka Client<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR4<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="application-yml配置文件"><a href="#application-yml配置文件" class="headerlink" title="application.yml配置文件"></a>application.yml配置文件</h4><p>​    唯一需要注意的地方就是端口号和注册中心的地址。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################### common config : ####################################</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">eureka-client</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8081</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://127.0.0.1:8080/eureka</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure>

<h4 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h4><p>​    和注册中心的注解也不一样，需要修改一下。使用<code>@EnableDiscoveryClient</code>这个注解。</p>
<h4 id="启动监测"><a href="#启动监测" class="headerlink" title="启动监测"></a>启动监测</h4><p>​    需要注意的是，如果依赖中没有添加web依赖，项目就会启动一会就停掉了。因为没有添加web依赖的SpringBoot项目相当于一个java的demo，代码执行完毕就结束了。执行项目后，注册中心回出现已经注册的实例。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200602151510377.png" alt="image-20200602151510377"></p>
<p>​    这样就整合了一个Eureka，一个简单的demo，中间省略了很多的东西。只是简单的验证一下。就这样吧，结束。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/SpringCloud/SpringCloud%E9%9B%86%E6%88%90Gateway/</url>
    <content><![CDATA[<h2 id="SpringCloud集成Gateway"><a href="#SpringCloud集成Gateway" class="headerlink" title="SpringCloud集成Gateway"></a>SpringCloud集成Gateway</h2><p>​    拖了很久，目前最后一篇SpringCloud的博客终于写了。这个坑算是告一段落了。最后一篇博客就是整合Gateway。也不说其他的了，直接开始吧。</p>
<p>​    其实写了这么久，应该了解了SpringCloud是有多个组件组成的，每个部分都有许多替代品，网关这个部分也不例外。其实最开始我一直在纠结选择哪个组件。目前比较好和流行的有Zuul和Gateway。但是Zuul2.0后就闭源了，所以一直在纠结，最后还是选择了Gateway。</p>
<p>​    Gateway的官网地址：<a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a>其实这个地址其他的组件也能找到，之前没有关注这个网址，后续大家可以在上面了解一下详细的写法和demo。</p>
<p>​    该项目提供了一个用于在Spring MVC之上构建API网关的库。Spring Cloud Gateway旨在提供一种简单而有效的方法来路由到API，并为它们提供跨领域的关注，例如：安全性，监视/指标和弹性。它的功能有以下几点。</p>
<ul>
<li><p>基于Spring Framework 5，Project Reactor和Spring Boot 2.0构建</p>
</li>
<li><p>能够匹配任何请求属性上的路由。</p>
</li>
<li><p>谓词和过滤器特定于路由。</p>
</li>
<li><p>Hystrix断路器集成。</p>
</li>
<li><p>Spring Cloud DiscoveryClient集成</p>
</li>
<li><p>易于编写的谓词和过滤器</p>
</li>
<li><p>请求速率限制</p>
</li>
<li><p>路径改写</p>
</li>
</ul>
<p>​    不难看到其实网关的一部分功能和其他的组件有些重合。这个后面会有一个问题。关于Gateway的原理这里不再叙述了，作为后续的一个扩展点（又是一个坑）。就直接整合。</p>
<p>​    需要添加Gateway的依赖，同时Gateway作为一个服务也是需要注册到Eureka注册中心的。</p>
<p>​    使用IDEA直接创建一个新模块，指定好名称和需要添加的依赖，这里只选择Gateway和Eureka-client就可以了。截图如下：</p>
<p>​    添加模块：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200724103944533.png" alt="image-20200724103944533"></p>
<p>​    选择两个依赖：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200724104143276.png" alt="image-20200724104143276"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200724104212862.png" alt="image-20200724104212862"></p>
<p>​    后面直接下一步就可以最后把pom文件中的父模块修改为自己的父模块就可以了。剩下就没有什么了。然后就是修改启动类，添加<code>@EnableDiscoveryClient</code>注解。最后就是在<code>application.yml</code>中增加一些配置。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">eureka-client</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://eureka-client</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/eureka-client/**</span></span><br><span class="line">    <span class="attr">loadbalancer:</span></span><br><span class="line">      <span class="attr">ribbon:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8080/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>​    下面说一下这个配置文件需要注意的事。</p>
<ul>
<li><p>uri后面填写的是你服务的地址，例如:<code>http://www.baidu.com</code>。这里填写<code>lb://eureka-client</code>代表从注册中心获取<code>eureka-client</code>的服务。</p>
</li>
<li><p>predicates是过滤原则，不能为空，必须要填。可以从其他地方了解一个这个如何填。我这里的意思是只要url为：<code>http://127.0.0.1:8084/eureka-client/**</code>的请求都会转到对应的服务上去处理。</p>
</li>
<li><p>id就是id，没有啥特殊的含义或者用处。</p>
</li>
<li><p>转到对应的服务时，请求地址会有一定的变化，还是上面那个链接，如果请求的服务端口为8081，则这个请求经过网关路由转化为：<code>http://127.0.0.1:8081/eureka-client/**</code>=，其实就是把端口号换了一下，所以我在服务模块添加了一个全局请求前缀：<code>/rureka-clien</code>。</p>
</li>
<li><p>下面的eureka客户端的配置没有什么可以讲的，和其他的一样。</p>
</li>
<li><p>启动的时候报了一个警告，大意是提醒已经启用了Ribbon，可能会有冲突。所以添加了配置：``spring.cloud.loadbalancer.ribbon.enabled<code>=false</code>，这里是为了不让这个告警出现（强迫症），要看自己项目是否需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">You already have RibbonLoadBalancerClient on your classpath. It will be used by <span class="keyword">default</span>. As Spring Cloud Ribbon is in maintenance mode. We recommend switching to BlockingLoadBalancerClient instead. In order to use it, set the value of `spring.cloud.loadbalancer.ribbon.enabled` to `<span class="keyword">false</span>` or remove spring-cloud-starter-netflix-ribbon from your project.</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    剩下就没有什么可以讲的了，启动项目测试一下就可以了，看看最后服务会不会经过路由转换为相应的服务。我最后是测试成功的。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200724105846220.png" alt="image-20200724105846220"></p>
<p>​    SpringCloud的内容就暂时告一段落了，这个主要还是熟悉SpringCloud，了解它的一些基础概念，具体到实际开发可能有很大的差异，例如单点登录的整合和跨域的处理，这些我都没有写。所以主要还是作为一个练手项目，了解就可以了。后续还是会持续更新的。（坑多不愁）。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/SpringCloud/SpringCloud%E9%9B%86%E6%88%90Hystrix/</url>
    <content><![CDATA[<h2 id="SpringCloud集成Hystrix"><a href="#SpringCloud集成Hystrix" class="headerlink" title="SpringCloud集成Hystrix"></a>SpringCloud集成Hystrix</h2><p>​    之前在SpringCLoud了解的博客简单介绍了Hystrix，现在就来详细介绍一下，顺带编写一个demo。</p>
<p>​    为了防止雪崩现象（一个系统中的错误导致系统大面积不可用），所以要让请求在发生错误时仍然可以维持后续的步骤，就是让操作降级，或者后续再处理。总之就是要维持后续的步骤，让系统在发生错误的情况下仍然可用。（这个感觉需要和业务紧密连接，虽然组件可以达到高可用，但是业务上的后续处理还是需要自己编写相关的业务代码的。）</p>
<p>​    Hystrix的原理。</p>
<blockquote>
<ul>
<li>防止任何单个依赖项耗尽所有容器（例如Tomcat）用户线程。</li>
<li> 减少负载并快速失败，而不是排队。</li>
<li>在可行的情况下提供备用，以保护用户免受故障的影响。</li>
<li>使用隔离技术（例如如 bulkhead, swimlane, 和 circuit breaker 模式）来限制任何一种依赖关系的影响。</li>
<li>通过近实时指标，监视和警报优化发现时间。</li>
<li>通过在Hystrix的大多数方面中以低延迟传播配置更改来优化恢复时间，并支持动态属性更改，这使您可以通过低延迟反馈回路进行实时操作修改。</li>
<li>防止整个依赖性客户端执行失败，而不仅仅是网络流量失败。</li>
</ul>
</blockquote>
<p>  为了实现这些目标，Hystrix也做了一些处理。</p>
<blockquote>
<ul>
<li>将对外部系统（或“依赖关系”）的所有调用包装在通常在单独线程中执行的<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象中（这是<a href="http://en.wikipedia.org/wiki/Command_pattern">命令模式</a>的示例）。</li>
<li>超时呼叫花费的时间超过您定义的阈值。有一个默认的，而是由“属性”，使它们比测量的99.5略高的方式对大多数依赖你自定义设置这些超时个百分点每个依存性的性能。</li>
<li>为每个依赖项维护一个小的线程池（或信号灯）；如果已满，发往该依赖项的请求将立即被拒绝，而不是排队。</li>
<li>测量成功，失败（客户端抛出的异常），超时和线程拒绝。</li>
<li>如果某个服务的错误百分比超过阈值，则使断路器跳闸，以在一段时间内手动或自动停止所有对特定服务的请求。</li>
<li>当请求失败，被拒绝，超时或短路时执行回退逻辑。</li>
<li>几乎实时监控指标和配置更改。</li>
</ul>
</blockquote>
<p>  上面都是翻译自Hystrix的GitHub页面，找了一圈，没有找到官网，只找到这个GitHub页面，上面也有一些文档。GitHub地址如下：</p>
<p><a href="https://github.com/Netflix/hystrix/wiki">https://github.com/Netflix/hystrix/wiki</a></p>
<p>​    然后就是一些图片，关于服务的正常调用和异常调用。</p>
<center>正常的服务之间的调用</center>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704171401715.png" alt="image-20200704171401715"></p>
<center>异常的服务之间的调用</center>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704172314545.png" alt="image-20200704172314545"></p>
<p>​    一个服务的节点阻塞，导致阻塞用户的整个请求，最后产生雪崩现象。</p>
<center>Hystrix之间的调用</center>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704172521744.png" alt="image-20200704172521744"></p>
<p>​    还是那句话，有能力的最好直接看官网文档，比较详细而且比较全。</p>
<p>​    介绍完了大致的原理，下面就开始撸代码。</p>
<p>​    因为feign默认集成了Hystrix，所以这里和上一节的Ribbon都不需要添加新的依赖。直接就可以编写。需要修改的地方有三个，一个是在feign接口代码添加一个回调类，还有就是创建一个回调类，写一些业务逻辑代码。最后就是在配置文件中开启Hystrix，因为feign默认不开启。</p>
<p>​    接口代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient.feign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.eurekaclient.hystrix.UserHystrix;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserFeign.java</span></span><br><span class="line"><span class="comment"> * Description: User的feign</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;provider-mysql&quot;, fallback = UserHystrix.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 查询list中的id所对应的用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">selectUserByID</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; ids)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    回调类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient.hystrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.eurekaclient.feign.UserFeign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserHystrix.java</span></span><br><span class="line"><span class="comment"> * Description: UserFeign的回调类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHystrix</span> <span class="keyword">implements</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 查询的回调方法，里面可以放一些异常后处理机制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selectUserByID</span><span class="params">(List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用异常，但是可以继续往下执行&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    配置代码如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################### common config : ####################################</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">eureka-client</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8081</span></span><br><span class="line"><span class="comment">#eureka注册中心的配置</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://127.0.0.1:8080/eureka</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#日志的级别</span></span><br><span class="line"><span class="attr">logging</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">level</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">com.psq.eurekaclient.feign.UserFeign</span>: <span class="string">debug</span></span><br><span class="line"><span class="comment">#feign默认不开启Hystrix，需要配置开启</span></span><br><span class="line"><span class="attr">feign</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">hystrix</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    关闭生产者前的调用截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704175652527.png" alt="image-20200704175652527"></p>
<p>关闭生产者后的调用截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200704180406092.png" alt="image-20200704180406092"></p>
<p>​    以上就是简单的调用，说了这么多，这些组件都是为了保证服务的高可用，但是写下来后发现，企业里面要保证高可用只有这些事不够的，需要结合自己公司的情况做对应的修改，有可能需要对这些组件的源码修。还是之前说的，公司的实力不够还是不要搞微服务了，很坑。</p>
<p>​    上面简单的调用没有什么技术点，后面还是需要看看源码或者分析具体的原理。但是现在显然短短一篇博客是不可能的了，这些都可以算到后面的债。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/SpringCloud/SpringCloud%E9%9B%86%E6%88%90OpenFeign/</url>
    <content><![CDATA[<h2 id="SpringCloud集成OpenFeign"><a href="#SpringCloud集成OpenFeign" class="headerlink" title="SpringCloud集成OpenFeign"></a>SpringCloud集成OpenFeign</h2><p>​    上次讲完Eureka，这次来讲一下OpenFeign。</p>
<p>​    之前的Eureka没有讲它的原理，后面看看能不能补上，这里也简单叙述一下OpenFeign的原理，后面慢慢补充。</p>
<p>​    OpenFeign。简化调用服务时的工作，将复杂的请求简化为配置，使用动态代理来构造出需要请求的服务地址，最后发起请求和解析请求。</p>
<p>​    微服务即然已经搭建起来了，但是各个微服务之前如何通讯和调用确实各问题，当然可以通过http的形式调用相应的服务，但是这样写的话，比较繁琐，并且代码的耦合度也会很高，这里就引出了Openfeign的概念。Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，这种请求相对而言比较直观。所以一个插件或者组件的产生肯定是为了解决某个问题的，不可能没有任何用处但是仍然在使用。</p>
<p>​    Openfeign的原理相对于我来说还是比较复杂的，这里我也就我自己的理解和别人的博客简单说一下Openfeign的一次调用。</p>
<ul>
<li><p>在使用feign 时，会定义对应的接口类，在接口类上使用Http相关的注解，标识HTTP请求参数信息</p>
</li>
<li><p>在Feign 底层，通过基于面向接口的动态代理方式生成实现类，将请求调用委托到动态代理实现类</p>
</li>
<li><p>最后将方法的调用转换为一次http请求</p>
</li>
</ul>
<p>​    我的理解就是这么个过程，可能不太对，欢迎大家指正。下面就上代码。</p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>​    生产者的代码主要就是一个controller，只要有返回就可以了。这里就不再累述。没有什么可讲的。主要讲一下中间遇到的坑。</p>
<ul>
<li><p>IDEA运行的时候，因为我的结构是父模块和子模块的形式，所以在编译的时候一直没有通过，只需要先把父模块编译，要注意pom文件不要带子模块，编译完毕在<code>install</code>一下就可以了，子模块就可以编译运行了。</p>
</li>
<li><p>为了方便后面的测试，所以在模块中添加了swagger-ui，很简单，添加pom文件、增加一个swagger配置类就可以了。详细的解释和需要添加的注解可以看下面的俩博客。</p>
<p> <a href="https://www.cnblogs.com/xifengxiaoma/p/11022146.html">https://www.cnblogs.com/xifengxiaoma/p/11022146.html</a></p>
<p><a href="https://blog.csdn.net/u012702547/article/details/88775298">https://blog.csdn.net/u012702547/article/details/88775298</a></p>
<p>生产者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.providermysql.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserController.java</span></span><br><span class="line"><span class="comment"> * Description:  User相关controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(value = &quot;用户&quot;, tags = &quot;用户管理相关接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;查询用户接口&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selectUserByID</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello SpringCloud&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>​    主要改动的地方就在消费者，首先消费者模块需要添加一个feign依赖，然后消费者通过编写一个feign接口来代表生产者的方法，controller通过<code>@Autowired</code>注解直接使用就可以了，启动类也需要添加一个<code>@EnableFeignClients</code>注解。其他的地方就不需要改动了。代码如下：</p>
<ul>
<li><p>Feigin接口代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient.feign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserFeign.java</span></span><br><span class="line"><span class="comment"> * Description: User的feign</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;provider-mysql&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 查询list中的id所对应的用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">selectUserByID</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; ids)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>controller层代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.eurekaclient.feign.UserFeign;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserController.java</span></span><br><span class="line"><span class="comment"> * Description:  User相关controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(value = &quot;用户&quot;, tags = &quot;用户管理相关接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserFeign userFeign;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;查询用户接口&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selectUserByID</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        String result = userFeign.selectUserByID(ids);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动类代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.eurekaclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EurekaClientApplication.java</span></span><br><span class="line"><span class="comment"> * Description:  Eureka Client 启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>导入的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置feign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    代码就是上面的代码，运行截图如下：</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200616145706715.png" alt="image-20200616145706715"></p>
<p>​    难点上面都说了，也没有啥可以说的了，感觉坑还是自己踩踩比较好，后面也会又个深入的了解，也会把踩到的坑说说。</p>
<p>​    顺带说一下，代码也上传到GitHub了，大家也可以下载源码。链接：<a href="https://github.com/qq1162210866/springcloud-train">https://github.com/qq1162210866/springcloud-train</a></p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/SpringCloud/SpringCloud%E9%9B%86%E6%88%90Ribbon/</url>
    <content><![CDATA[<h2 id="SpringCloud集成Ribbon"><a href="#SpringCloud集成Ribbon" class="headerlink" title="SpringCloud集成Ribbon"></a>SpringCloud集成Ribbon</h2><p>​    Ribbon 是一个基于 HTTP 和 TCP 的 客服端负载均衡工具，它是基于 Netflix Ribbon 实现的。</p>
<p>​    说的明白点就是一个或者多个消费者去调用生产者的方法，但是哪个消费者去调用哪个生产者这个是根据算法来确定的，Ribbon就类似于这个算法。</p>
<p>​    Ribbon有很多的负载均衡算法，轮询策略（默认）、权重轮询策略、随机策略、最少并发数策略、重试策略、可用性敏感策略、区域敏感性策略。很多算法看名字就知道意思，这里算法不是本次讨论的重点，也不再累述，后面有机会了解一下。</p>
<p>​    Ribbon是集成于客户端的，业内也有两种主流的负载均衡的方案。1.集中式负载均衡（服务器负载均衡），通过一个单独的模块来实现负载均衡。2.进程内负载均衡（客户端负载均衡），客户端通过算法去查询合适的生产者，然后调用。可以显而易见的看到Ribbon是属于后者的。</p>
<p>​    还是老样子，实际操作一下，后面再说原理的事。成功了才会有兴趣去深入。</p>
<p>​    因为OpenFeign已经集成了Ribbon，所以之前的代码不需要大的改动。</p>
<p>​    要实现负载均衡，需要有两个生产者。这里直接将一个生产者的文件夹复制，在修改文件夹名字，然后IDE导入模块就可以了。项目结构如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200702181859656.png" alt="image-20200702181859656"></p>
<p>​    第二个生产者模块需要修改一个端口号，以免两个生产者启动冲突。然后启动两个生产者模块即可。可以看到注册中心页面如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200702181934513.png" alt="image-20200702181934513"></p>
<p>​    然后使用swagger-ui直接调用消费者的方法，消费者通过OpenFeign调用生产者的方法。会发现两个生产者的控制台在循环打印信息，这是因为Ribbon默认使用的轮询算法。效果如图：</p>
<p>生产者1:</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200702182439596.png" alt="image-20200702182439596"></p>
<p>生产者2:</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200702182525176.png" alt="image-20200702182525176"></p>
<p>​    总共是调用了五次，所以生产者累计打印了五次。</p>
<p>​    在编写的过程中才发现，Ribbon更多的是提供了一个思路或者解决办法，解决的问题就是生产者和消费者之间调度的问题。因为SpringCloud对于这些组件集成的比较好（还是之前说的，这些工具的产生是为了加快开发的速度），所以本次更多的还是理解负载均衡的意义和原理。后面也会对这些源码进行阅读，了解深层次的一些东西。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/netty/Netty%E4%BA%86%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>​    工作中需要集成一个TCP客户端，使用Java原生的<code>ServerSocket</code>写了一个demo，但是整合到项目中的时候发现原来的代码使用的是<code>Netty</code>，由于自己不是很了解，所以这次就来学习一下，首先按照惯例先了解Netty的基础概念。开始。</p>
<p>​    Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。（摘抄自百度百科）</p>
<p>​    也就是说，Netty是一个网络应用程序框架，是用来开发和网络服务有关的，所以本次的TCP服务端就使用的是Netty。同时，Netty是基于Java中的NIO的，但是Netty对NIO的封装比较友好。（大家都说java中的NIO烂的一塌糊涂，我也没有用过，只能顺大流了）另外，Netty吸收了很多的协议的实现经验，所以保证了易于开发并且性能稳定。说完了它的历史背景和所解决的问题，下面就要开始介绍一下Netty的一些基础组件，方便后面的理解。</p>
<ul>
<li><p>引导类。引导类分为服务端ServerBootStap、客户端BootStrap。引导类作用是将各个基础组件通过链式语法进行组装，服务端通过bind()进行启动,客户端通过connect()进行启动。</p>
</li>
<li><p>线程模型。</p>
<ul>
<li>Boss线程：负责接收客户端连接请求。</li>
<li>Worker线程：负责IO读写事件和任务处理(比如channel注册selector、channel绑定端口等)，通过inEventLoop()和MPSC(Multiple Producer Single Consumer)队列实现无锁化串行线程执行模型。</li>
<li>IO-Reactor：Netty可配置三种IO-Reactor线程模型,分别为单Boss线程处理客户端连接和IO读写、单Boss线程处理客户端连接-多Worker线程处理IO读写、多Boss线程处理客户端连接-多Worker线程处理IO读写。</li>
<li>NioEventLoopGroup：线程池，内部存储可用线程NioEventLoop，默认大小为2倍的cpu核数。</li>
<li>ThreadPerTaskExecutor：线程创建器，创建过程中会为线程重命名，并将其转换为FastThreadLocalThread类型。</li>
<li>Chooser：线程选择器，根据NioEventLoopGroup中线程数量采取不同策略选取可用线程。</li>
</ul>
</li>
<li><p>通道/业务逻辑处理</p>
<ul>
<li>Channel：数据传输通道,Netty对NIO中ServerSocketChannel和SocketChannel进行抽象和功能封装。</li>
<li>ChannelPipeline：业务逻辑处理链，采取责任链模式将事件进行传递交由ChannelHandler进行处理。Netty通过Synchronized关键字保证ChannelPipeline的线程安全性，实现ChannelHandler的动态添加和删除。事件传递：入站事件向后一个入站事件传递，出站事件向前一个出站事件传递，异常事件向后一个事件传递。</li>
<li>ChannelHandler：业务处理组件，分为入站处理、出站处理和入出站处理三种类型。特别注意ChannelHandler并非线程安全，因此最好实现一些无状态方法，或者通过线程安全容器和关键字保证数据的线程安全。</li>
<li>ChannelHandlerContext：存储业务处理组件上下文信息，保存ChannelHandlerContext-&gt;ChannelHandler的1:1映射关系，因为ChannelHandler可被共享重复使用，所以ChannelHandler-&gt;ChannelHandlerContext并不一定是一一映射。</li>
</ul>
</li>
<li><p>数据容器/编解码</p>
<ul>
<li>ByteBuf：Netty中数据存储的载体，根据内存类型、内存回收和API实现机制可分为Head/Direct、Pooled/UnPooled和UnSafe/非UnSafe三种类型。编解码：数据以二进制方式在服务端和客户端进行传输，接收数据后需要对数据进行解码，发送数据前需要对数据进行编码。</li>
<li>ByteToMessageDecoder：解码器，将累加的字节流数据进行decode，decode操作交由子类实现，通过fireChannelRead事件将解码后的数据向后传播。</li>
<li>MessageToByteEncoder：编码器，分配内存将数据写入ByteBuf，发起write事件将编码后的数据向前传播。</li>
</ul>
</li>
</ul>
<p>​    上面就是基于作用来介绍各个组件，还有一个图，这些都是拷贝自另一个博主的，总结的挺好的，但是不知道为什么不写了。。。博客地址：<a href="https://www.jianshu.com/p/17ccfc1005f8">https://www.jianshu.com/p/17ccfc1005f8</a></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200618155425968.png" alt="image-20200618155425968"></p>
<p>  下面就说一下Netty的特点。（来自官网）</p>
<ul>
<li>丰富的缓冲区数据结构</li>
<li>通用的异步I/O API</li>
<li>基于拦截器链模式的事件模型</li>
<li>高级组件，实现更快的开发</li>
</ul>
<p>还有一个官网的图，看不懂也要看。。。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200618153050073.png" alt="image-20200618153050073"></p>
<p>​    感觉还是官网比较靠谱，我在各个博客找了很久，大部分都不是很好，后来感觉官网写挺不错的，同时官网上面也有jar包和文档，都比较齐全。</p>
<p>​    官网地址：<a href="https://netty.io/">https://netty.io</a></p>
<p>​    后面就是开始写demo了，简单介绍到这里就结束了，后面有机会也慢慢补上其他的概念。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/netty/Netty%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="NIO和BIO和AIO的区别"><a href="#NIO和BIO和AIO的区别" class="headerlink" title="NIO和BIO和AIO的区别"></a>NIO和BIO和AIO的区别</h2><ul>
<li>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。</li>
</ul>
<p>​    Linux对于IO的区分：</p>
<ul>
<li>阻塞IO模型：应用进程等待数据准备好，拷贝完后，处理数据。</li>
<li>非阻塞IO模型：如果数据没有准备好，返回一个错误，数据准备好后，拷贝完毕后，处理数据。</li>
<li>IO复用模型：Linux提供select/poll，可以检测多个通道数据是否就绪，当就绪后，调用回调函数。</li>
<li>信号驱动IO模型：调用一个信号处理函数，系统做其他事情，当数据准备就绪时，生成一个信号，通过信号回调通知程序读取数据。</li>
<li>异步IO：告知系统启动某个操作，让内核在完成操作后通知程序。和信号驱动的区别就是，拷贝过程中，异步IO也不会阻塞。</li>
</ul>
<h3 id="BIO相关知识点"><a href="#BIO相关知识点" class="headerlink" title="BIO相关知识点"></a>BIO相关知识点</h3><p>​    一般有一个独立线程负责监听客户端的连接，如果接收到客户端的请求，为每一个客户端的请求创建一个线程进行处理，处理完成后，通过输出流将返回信息返回给客户端。</p>
<p>​    还有就是通过线程池和同步队列实现的伪异步的IO通信框架。将套接字封装成一个Task，让后交给线程池处理。这样线程池可大可小，不会导致资源耗尽。</p>
<p>​    但是这样如果有一方接收速度较慢，另一方就会被阻塞。</p>
<h3 id="NIO相关知识点"><a href="#NIO相关知识点" class="headerlink" title="NIO相关知识点"></a>NIO相关知识点</h3><h4 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h4><p>​    Netty是一个高性能、异步事件驱动的NIO框架，所有的IO操作都是异步非阻塞的。</p>
<ul>
<li>缓冲区buffer。缓冲区是一个对象，包含要写入或者要读出的数据。BIO中是直接操作Stream，但是NIO是直接操作buffer。缓冲区类似于字节数组。</li>
<li>通道Channel。通道类似于一个自来水管，可以通过它读取和写入数据。网络数据通过通道读取和写入，并且通道是双向的。</li>
<li>多路复用器Selector。Selector会不断轮询注册其上的Channel，如果某个Channel有TCP连接、读或者写事件，这个Channel就会处于就绪状态，会被Selector轮询出来，进行后续的IO操作。</li>
</ul>
<h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><p>​    NIO可以监听多个通道，通过将通道注册到多路复用器上，如果某个通道有连接、读或者写事件，Selector会通过关键字获取Channel，将通道的消息写入buffer中，再进行后续的IO操作。</p>
<h3 id="AIO相关知识点"><a href="#AIO相关知识点" class="headerlink" title="AIO相关知识点"></a>AIO相关知识点</h3><p>​    AIO就是异步IO，程序启动后，不在原地等待程序执行结果，等到数据到了后，并且拷贝完毕后，异步通知原有程序，进行后续的数据处理。</p>
<h2 id="Netty相关知识点"><a href="#Netty相关知识点" class="headerlink" title="Netty相关知识点"></a>Netty相关知识点</h2><h3 id="Netty基础概念"><a href="#Netty基础概念" class="headerlink" title="Netty基础概念"></a>Netty基础概念</h3><ul>
<li>因为jdk自带的ByteBuffer只有一个指针用于读写操作，使用起来不是很方便，所以netty中的ByteBuf对其进行了优化。ByteBuf采用两个指针，读操作一个，写操作一个。数据的写入会导致写指针增加，读操作回导致读指针增加。但是读指针不能操过写指针，要不然会报错。调用discardReadBytes方法可以释放已经读过的区域。ByteBuf如果写入字节大于能写入字节，会进行动态扩展。<ul>
<li>discardable会将读过的字节清楚，将读指针和写指针向前移动。</li>
<li>clear会将指针变为初始位置，并不会清除缓存区的内容。</li>
<li>mark会将指针备份，rest会将指针恢复到备份到位置。读写指针都有这个方法。</li>
<li>ByteBuf有很多查找字节的方法。</li>
</ul>
</li>
<li>Channel：数据传输通道,Netty对NIO中ServerSocketChannel和SocketChannel进行抽象和功能封装。每个Channel都对应一个物理链接。</li>
<li>ChannelPipeline和ChannelHandler类似于过滤器，数据在ChannelPipeline中流转，ChannelHandler则对这些数据进行处理。底层的Channel触发事件，由EventLoop调用ChannelPipeline，将消息传输到ChannelPipeline中，再依次被各个Handler处理。<ul>
<li>Netty中的启动类会为每个Channel自动创建pipeline，获取pipeline然后将handler加入即可。</li>
<li>ChannelPipeline支持运行时动态添加或者删除Handler。</li>
<li>ChannelPipeline是线程安全的。使用的是synchronized关键字实现。</li>
</ul>
</li>
<li>EventLoop和EventLoopGroup：EventLoop是一个IO线程，但是除了负责读写外，还处理系统Task、定时任务。EventLoopGroup是个线程池，主要放置Accpetor线程或者IO线程。</li>
<li>Future：代表异步操作的结果，一般与Channel操作有关。</li>
<li>Promise ：是可写的Future，Netty通过Promise对Future进行扩展，用于设置IO操作的结果。</li>
</ul>
<p>​    Netty有三种线程模型：</p>
<ul>
<li>Reactor单线程模型：所有的IO操作都在同一个NIO线程上面完成，包括接受TCP连接信息，当链路建立后，将ByteBuf发送给Handler，进行消息解码。小容量可以使用，高并发不适合。</li>
<li>Reactor多线程模型：有一个单独的Acceptor线程监听服务端，接受客户端的请求，IO操作读或者写则由NIO线程池复杂，线程池包含一个队列和N个可用的线程，由这些线程复杂解码、处理。一个NIO线程可以处理多个链路，但是一个链路只对应一个线程，这样可以防止并发导致出现问题。单独的Acceptor线程在某些情况下可能会出现性能问题，如：认证情况下。</li>
<li>主从Reactor多线程模型：服务端用于接受客户端的连接也是一个独立的线程池，Acceptor仅仅用于客户端的登录、握手、安全认证。然后将Channel注册到IO线程池，让后续的IO线程对数据进行处理。</li>
</ul>
<h3 id="Netty具体流程"><a href="#Netty具体流程" class="headerlink" title="Netty具体流程"></a>Netty具体流程</h3><p>​    首先声明一个Channel，然后将这个通道注册到Selector，也就是BossGroup里面。当有客户端进行TCP连接时，把连接信息封装成 NioSocketChannel 注册到 WorkerGroup 线程中的 Selector。当 WorkerGroup 线程中的 Selector 监听到自己感兴趣的 IO 事件后，就调用 Handler 进行处理。</p>
<h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><h2 id="其他相关知识点"><a href="#其他相关知识点" class="headerlink" title="其他相关知识点"></a>其他相关知识点</h2><ul>
<li><p>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。</p>
</li>
<li><p>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。</p>
</li>
<li><p>Java中默认是大端模式。和TCP中的传输一致。</p>
</li>
<li><p>在操作系统层面上的零拷贝是指避免在用户态与内核态之间来回拷贝数据的技术。在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.</p>
</li>
<li><p>Netty的零拷贝完全是在用户态(Java层面)的，更多是数据操作的优化。主要有五点：</p>
<ul>
<li>Netty的接收和发送ByteBuffer使用直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li>
<li>Netty的文件传输调用FileRegion包装的transferTo方法，可以直接将文件缓冲区的数据发送到目标Channel，避免通过循环write方式导致的内存拷贝问题。</li>
<li>Netty提供CompositeByteBuf类, 可以将多个ByteBuf合并为一个逻辑上的ByteBuf, 避免了各个ByteBuf之间的拷贝。</li>
<li>通过wrap操作, 我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象, 进而避免拷贝操作。</li>
<li>ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf, 避免内存的拷贝。</li>
</ul>
</li>
</ul>
<h2 id="面试的问题"><a href="#面试的问题" class="headerlink" title="面试的问题"></a>面试的问题</h2><ul>
<li>介绍一下netty的线程模型</li>
</ul>
<p>​    说到netty的线程模型需要先说一下nio和aio的区别，NIO是内核通知应用可以读写，然后应用去进行读写操作，AIO不太一样，应用知识操作数据，对于读写操作由内核来完成，看起来像是异步的，就是应用要读写后立即返回。netty的线程模型就是基于reactor的。有很多线程模型，单线程模型、多线程模型、主从线程模型。单线程就是建立连接和读写操作都是一个线程，相当于一个线程干全部的活。弊端很明显，大量并发下，会导致系统的吞吐量降低。多线程模型就是一个 线程只用来建立连接，后面还有很多的线程用来处理读写操作，有点像boss和员工，boss找活干，员工来干活。netty中两个线程组就是这个名字。多线程其实已经满足我们项目的需要了，但是有些情况还是不能满足，像需要认证的情况，因为建立连接的线程还是一个，认证操作也比较耗时。就又了主从模型，还是一个线程建立连接，建立后将其交给boss线程组，这些线程主要进行认证这些比较耗时的操作，完成后，读写操作仍然交给后续的worker线程组。</p>
<p>* </p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/netty/Netty%E7%AE%80%E5%8D%95demo/</url>
    <content><![CDATA[<h2 id="Netty简单demo"><a href="#Netty简单demo" class="headerlink" title="Netty简单demo"></a>Netty简单demo</h2><p>​    上篇博客简单介绍了Netty的一些基础概念和组件，这次就来写一个简单的demo，因为公司需要的是TCP服务端，所以这次的demo就写一个TCP服务端。下面就直接上代码。</p>
<p>​    首先是主类，里面也放着Netty的启动方法和执行流程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nettytrain;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCPServerTrain.java</span></span><br><span class="line"><span class="comment"> * Description:  netty服务端的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerTrain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认端口</span></span><br><span class="line">    <span class="keyword">private</span> Integer port = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCPServerTrain</span><span class="params">(Integer port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 接收传入的连接</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//处理传入的连接，一般是bossGroup的二倍</span></span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务端应用开发的入口</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//设置主从线程池</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workGroup)</span><br><span class="line">                    <span class="comment">//指定通道channel的类型，因为是服务端，所以是NioServerSocketChannel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//设置子通道也就是SocketChannel的处理器</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> TCPServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//配置ServerSocketChannel的选项</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    <span class="comment">//配置子通道也就是SocketChannel的选项</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//绑定并侦听某个端口</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">//如何没有客户端连接就会关闭Channel和两个线程池</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 关闭线程池</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> TCPServerTrain(port).run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码里面的注释已经很清楚了，没有什么可以细讲的地方。下面的就是业务处理类，自己的业务处理主要放在这里。代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nettytrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.ReferenceCountUtil;</span><br><span class="line"><span class="keyword">import</span> network_train.ARPojo;</span><br><span class="line"><span class="keyword">import</span> network_train.ARSwitch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCPServerHandler.java</span></span><br><span class="line"><span class="comment"> * Description: 主要的业务处理类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 通道的读取操作方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/19</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuf recvmg = (ByteBuf) msg;</span><br><span class="line">            String line = recvmg.toString(CharsetUtil.UTF_8);</span><br><span class="line">            System.err.println(<span class="string">&quot;接收到消息&quot;</span> + line);</span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;BG&quot;</span>) &amp;&amp; line.contains(<span class="string">&quot;ED&quot;</span>)) &#123;</span><br><span class="line">                ARPojo arPojo = ARSwitch.LineSwitch(line);</span><br><span class="line">                System.err.println(<span class="string">&quot;转换为pojo对象&quot;</span> + arPojo.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放msg</span></span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description:  异常捕获</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/19</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    也是没有什么可以讲的地方，这里的业务处理我放在其他的地方了，所以这里的代码很少，每个人的业务不同，所以业务处理也不同。</p>
<p>​    下面就说说遇到的问题。就是通道读取的方法，刚开始不知道怎么处理msg，后来转换成<code>ByteBuf</code>,再转换的<code>String</code>，这个地方不知道处理的对不对。其他的问题就是这个代码没有考虑到粘包的现象，现在还没有涉及到，所以没有写，后面慢慢补上。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/netty/Netty%E7%BC%96%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="Netty编写客户端"><a href="#Netty编写客户端" class="headerlink" title="Netty编写客户端"></a>Netty编写客户端</h2><p>​    上一篇博客讲了一下解码器，但是其实没有涉及到客户端的编写，今天补上这篇博客。同时深入了解一下Netty（对于我来说）。加深自己的印象。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201208205126779.png" alt="image-20201208205126779"></p>
<p>​    上面是一个简单的服务端的例子，之前的博客也讲过这个demo，下面按照自己最新的理解再次记录一下。首先是最开始创建两个线程组，boss线程组用来监听客户端的连接，只做到这一步，work线程组相当于干活的，当通道中有IO事件时就开始工作。这样做的好处就是可以提升读写性能。这一块的内容涉及到Netty的线程模型，这一块我不是很熟悉，找到一篇文章，大家可以了解一下，感兴趣的可以继续搜索一下：<a href="https://zhuanlan.zhihu.com/p/87630368">Netty线程模型</a>，以后也会慢慢补上这些内容的，学习无涯。回到代码上，然后就是创建了一个<code>ServerBootstrap</code>，这个启动类的作用就是辅助与编写服务端，降低开发的复杂度。再然后就是设置线程组、设置<code>Channel</code>、配置TCP的参数，编写Netty之前最好还是有点NIO的编写经验，不要像我上来就开始，一点准备工作都没有做，读代码都很吃力。最后的两行代码含义就比较容易懂了，调用辅助类的<code>bind()</code>方法绑定监听某个端口，同时调用同步阻塞方法等待绑定操作完成。最后一行则是等待服务端链路关闭后，退出主方法。</p>
<p>​    说了这么多，其实和客户端的编写一点关系都没有，主要还是记录一下Netty启动的流程，对于Netty原理和底层的一些操作，这个需要等我看完NIO再记录一下。下面就讲一下Netty编写客户端的思路。</p>
<p>​    客户端不需要两个线程组，一个就够了，通道也和服务端不太一样，需要设置为<code>NioSocketChannel</code>,剩下就是设置TCP的参数和handler的设置。发起连接和服务端也不太一样，服务端是监听，客户端就是连接，调用<code>connect()</code>方法发起异步连接，然后再调用同步方法等待连接成功。最后就是连接关闭后释放线程组的资源。代码也比较简单，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置客户端的线程组，客户端只有一个线程组</span></span><br><span class="line">EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class)</span><br><span class="line">            .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">//放入自己的业务Handler</span></span><br><span class="line">                    socketChannel.pipeline().addLast(<span class="keyword">new</span> TCPClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//发起异步连接操作，同步阻等待结果</span></span><br><span class="line">    ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">    <span class="comment">//等待客户端链路关闭</span></span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放NIO线程组</span></span><br><span class="line">    eventLoopGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不要以为到这里就结束了，上面这个只是一个简单的demo，自己写着玩还可以，但是到了生产环境或者实际用的时候，很多东西没有考虑到。断线重连问题、线程管理的问题、连接多服务端的情况。这些问题是我开发时遇到的问题，下面就一一讲一下实现的逻辑，最后则给出整体的代码。</p>
<ul>
<li>断线重连。断线重连一般时客户端要做的事情，也分为两种情况，一开始连接不上和连接上过一段时间断了。这两种情况需要不同处理，一开始连接不上需要添加监听器，异步执行，失败就调用两秒重连。断线则需要再handler中的<code>channelInactive()</code>方法做相应的业务处理。</li>
<li>线程管理和连接多服务端的问题其实是一个场景。就是需要连接多个服务端的情况下，一个连接创建一个线程显然是不太合理的，同时也要对这些线程进行管理。这里暂时的办法是单独启动一个线程，线程的<code>run()</code>方法就是启动netty连接。后续在这个线程里面去完成多个客户端的建立或者一个netty线程去连接多个服务端。目前水平有限，只能想到这个地步。涉及到线程和NIO还有Netty。后续慢慢完善吧。</li>
</ul>
<p>​    所以最后的代码就如下：因为一些原因，没有给出全部的代码，给出了部分核心的代码，其他的细节和本次的内容关系不大。也可以按照自己的需求进行修改。（最好按照自己的想法修改一下，每个人的需求都不太一样，我的代码一定不合适所有人）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectThread</span> <span class="keyword">extends</span> <span class="title">ConnectThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(ConnectThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup eventLoopGroup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean running = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        beginConnect();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                shutDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//阻塞住</span></span><br><span class="line">        <span class="keyword">while</span> (running.get()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200l</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;程序运行发生错误&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                shutDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">            bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            assembleBootStrap();</span><br><span class="line">            reConnect();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;客户端连接发送错误&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            shutDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 组装BootStrap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/12/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assembleBootStrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConnectThread ConnectThread = <span class="keyword">this</span>;</span><br><span class="line">        bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.remoteAddress(host, port);</span><br><span class="line">        bootstrap.option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">6000</span>);</span><br><span class="line">        bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">                socketChannel.pipeline().addFirst(<span class="keyword">new</span> IdleStateHandler(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> Decoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> Handler(ConnectThread));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.reConnect();</span><br><span class="line">        logger.info(<span class="string">&quot;雷达开始重试，雷达信息为：&#123;&#125;:&#123;&#125;&quot;</span>, host, port);</span><br><span class="line">        bootstrap.connect(host, port).addListener(<span class="keyword">new</span> ConnectListener(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running.set(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (closeChannel != <span class="keyword">null</span> &amp;&amp; closeChannel.isActive()) &#123;</span><br><span class="line">            closeChannel.close().awaitUninterruptibly();</span><br><span class="line">            closeChannel = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (eventLoopGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">        eventLoopGroup = <span class="keyword">null</span>;</span><br><span class="line">        logger.error(<span class="string">&quot;客户端关闭连接，雷达服务端信息为：&#123;&#125; : &#123;&#125;&quot;</span>, host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    来讲一下上面的代码大致的思路。连接类继承了线程，重写了<code>run()</code>方法，run方法里面只有三个部分的代码，一个是启动连接，一个是程序运行中有异常执行关闭方法，释放资源。最后一个就是将线程阻塞住，因为启动连接是异步的，如果不阻塞，代码直接就执行完毕了，后续也没法进行重连的操作。启动连接方法里面只有两步，一个是组装BootStrap启动类，另外一个就是执行重连操作，之前说过，断线重连发生在两个地方，最开始没有连接上和中间断掉，所以这里直接掉同一个方法，不用再重复写方法了。组装启动类按照自己的需求组装就可以了，设置超时事件、设置长时间无数据返回、设置解码器，业务处理类。重连方法就是调用启动类的<code>connect()</code>方法，这里和上面的demo有一点不一样，这里是异步返回的，没有阻塞住，添加了一个监听器，也是为了做重连用的。如果和demo一样的话，这里发生断连，程序就直接关闭了，就没法重连了。想要重连必须重新创建线程组、启动类、通道等，这个显然不是我们想看到了，因为断连后，线程组和和启动类还是可以继续使用的，只不过要换一个连接。</p>
<p>​    下面就继续附上监听器和handler的代码。（handler中有一部分断线重连的方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectListener</span> <span class="keyword">implements</span> <span class="title">ChannelFutureListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(ConnectListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConnectThread ConnectThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectListener</span><span class="params">(ConnectThread ConnectThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ConnectThread = ConnectThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;[&quot;</span> + ConnectThread.getHost() + <span class="string">&quot;:&quot;</span> + ConnectThread.getPort() + <span class="string">&quot;] 启动成功!!!&quot;</span>);</span><br><span class="line">            ConnectThread.setTime(<span class="number">0</span>);</span><br><span class="line">            ConnectThread.setCloseChannel(future.channel());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ConnectThread.getTime() &gt;= <span class="number">1800</span>) &#123;</span><br><span class="line">                logger.error(ConnectThread.getHost() + <span class="string">&quot;:&quot;</span> + ConnectThread.getPort() + <span class="string">&quot;重试超过一小时，不再重试&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.warn(<span class="string">&quot;[&quot;</span> + ConnectThread.getHost() + <span class="string">&quot;:&quot;</span> + ConnectThread.getPort() + <span class="string">&quot;]Channel失联，2秒后重连。。。 &quot;</span>);</span><br><span class="line">            future.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    ConnectThread.reConnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">2l</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    监听器的代码就是判断是否连接上，没有的话进行重试，连接上了就重置次数，同时返回通道信息，为后面关闭通道做准备。剩下句没有什么可以说的了。最好就是handler的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XYDHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(XYDHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XYDConnectThread xydConnectThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XYDHandler</span><span class="params">(XYDConnectThread xydConnectThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.xydConnectThread = xydConnectThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;连接断开，IP端口为：&#123;&#125;&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">        ctx.channel().eventLoop().schedule(() -&gt; &#123;</span><br><span class="line">            xydConnectThread.reConnect();</span><br><span class="line">        &#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer((<span class="keyword">byte</span>[]) msg);</span><br><span class="line">        logger.info(<span class="string">&quot;接收到消息为：&#123;&#125;&quot;</span>, ByteBufUtil.hexDump(byteBuf));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    重连的方法就是<code>channelInactive()</code>，和监听器里的代码也是差不多。剩下就没有什么可以说的了。</p>
<p>​    上面的代码就是完成一个断线重连的Netty的客户端，代码直接粘贴是不能用的，需要进行一些修改，我现在也比较烦直接将代码粘贴过来，上来就开始测试。还是要了解一下具体如何实现的，要不然改代码都不知道如何修改。就像这次编写客户端，最开始写很吃力，因为之前是一知半解，不知道如何修改，不知道如何排查，所以走了很多的弯路，代码完全不能看，也不起用。现在了解了一些后，慢慢能够按照自己的想法将代码改造成自己想要的样子，我觉得这样才算一个东西你彻底掌握了，与君共勉。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/netty/Netty%E8%A7%A3%E7%A0%81%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Netty解码器了解和使用"><a href="#Netty解码器了解和使用" class="headerlink" title="Netty解码器了解和使用"></a>Netty解码器了解和使用</h2><p>​    距离上次了解Netty已经过去半年了，最近需要编写一个客户端去连接一个设备，发现Netty编写客户端比服务端复杂一点，回头看自己写的服务端的博客，发现当时的了解也是一知半解，整片博客达不到我想象中的要求。现在才发现写博客原来还是有一些技术含量的。我也没有修改写完的博客的习惯。就当成自己的黑历史吧，但是后续自己还是要记录的。中间发现一片博客对于Netty的入门的一些概念讲的比较清楚，这里也放上来。<a href="https://mp.weixin.qq.com/s/insjE_EJRoCOM-1GqgZP9A">Netty架构与原理</a></p>
<p>​    也就不多说废话了，这边博客讲的是解码器的使用，关于客户端的讲解和代码放到后面一片博客上。下面就直接开始。</p>
<p>​    编码器和解码器其实是一个概念，上一篇博客讲过Netty中的几个重要的组件，其中编解码器在最下面。解码器意如其名，就是对于网络上接收的字节进行解码，将字节转换为相应的java对象，再传给业务处理类，同时对于TCP中的粘包和拆包现象在解码器中处理也是比较方便的。关于粘包问题的解释和做法可以看官网的解释<a href="https://netty.io/wiki/user-guide-for-4.x.html#dealing-with-a-stream-based-transport">官网对于粘包的解释和处理</a>。最开始我的本意也是处理粘包的现象，同时对收到的数据做校验。所以就查询了一下相关的资料。编码器则是发送数据时将java对象转换为字节数据，再通过网络发送出去，和解码器类似，只不过用的地方不一样。我的代码不涉及发送数据，所以本次博客不再记录编码器，估计使用方法和解码器类似，可能就是方法不一样。</p>
<p>​    Netty想到了粘包和拆包的问题，所以有几种自带的解码器，可以直接使用。LineBasedFrameDecoder（基于特殊分隔符的解码器，例如<code>\r\n</code>）、DelimiterBasedFrameDecoder（更加通用的分隔符解码器，支持多个特殊分隔符）、FixedLengthFrameDecoder（固定长度的解码器）、LengthFieldBasedFrameDecoder（可以按照长度字段动态的解码器，比较符合我们的要求了）。基本常用的解码器就这几种了，最后一个比较符合我们的需求，但是因为后续可能会发生变化，同时，我也想在解码器里面对数据做校验，所以这里打算自己编写解码器。</p>
<p>​    自定义解码器只需要让类继承ByteToMessageDecoder，然后重写自己的方法就可以了。这里我记得Netty有几种解码器，分别解析int short和二进制，但是忘记到底是什么了，欢迎大家补充。</p>
<p>​    继承ByteToMessageDecoder后，只需要重写<code>decode()</code>方法就可以完成解码的工作，这里简单列举一下自己的代码，因为大部分都涉及到业务处理，这部分和解码器无关，不再记录。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 先处理粘包的问题，再对所有数据和数据模块做校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx ChannelHandler 和ChannelPipeline 之间的关联</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 输入的Buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 输出的Buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      	<span class="comment">//获取buf中写指针的位置，相当于buf中能读的数据的长度</span></span><br><span class="line">        <span class="keyword">int</span> bufferLength = in.writerIndex();</span><br><span class="line">      	<span class="comment">//获取指定帧头的位置</span></span><br><span class="line">        <span class="keyword">int</span> headIndex = ByteBufUtil.indexOf(RadarMessageUtil.HEAD_BUF, in);</span><br><span class="line">        <span class="keyword">int</span> surplusLength = RadarMessageUtil.HEAD_LENGTH + RadarMessageUtil.SUM_LENGTH + RadarMessageUtil.CALIBRATE_LENGTH;</span><br><span class="line">      	<span class="comment">//获取当前数据最短的长度，帧头+数据长度位+数据+校验位</span></span><br><span class="line">        <span class="keyword">int</span> shortData = in.getUnsignedShort(headIndex + RadarMessageUtil.HEAD_LENGTH) + surplusLength;</span><br><span class="line">        <span class="keyword">if</span> (headIndex &gt;= <span class="number">0</span> &amp;&amp; bufferLength &gt;= shortData) &#123;</span><br><span class="line">            <span class="keyword">int</span> dataLength = shortData - surplusLength;</span><br><span class="line">            <span class="keyword">byte</span>[] rs = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">            in.getBytes(headIndex + RadarMessageUtil.HEAD_LENGTH + RadarMessageUtil.SUM_LENGTH, rs);</span><br><span class="line">            <span class="keyword">if</span> (compareBytes(rs)) &#123;</span><br><span class="line">              	<span class="comment">//添加该buf到输出中，这里也可以将buf再次转换为java对象</span></span><br><span class="line">                out.add(rs);</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//将读写指针复位</span></span><br><span class="line">            in.readerIndex(headIndex + RadarMessageUtil.HEAD_LENGTH + RadarMessageUtil.SUM_LENGTH + dataLength + RadarMessageUtil.CALIBRATE_LENGTH);</span><br><span class="line">            in.discardReadBytes();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;接收的数据不满足最小长度或者不包含帧头&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    代码就是上面的代码，不是很复杂。简单说一下思路。先是获取整个缓冲区的数据长度，再判断帧头的位置，将帧头后两位的数据解析为数据长度，判断缓存区整个数据长度是不是大于这个长度，如果大于就代表这个包全了，可以解析，将这个buf转换成字节数组再放到out里面（不是必须转换为字节数组）。如果小于则代表缓冲区内数据不全，需要继续等待缓冲区内数据补充，直接返回就可以。如果正常读取后，最后需要将buf中的指针操作都复位，要不然buf的大小会越来越小。</p>
<p>​    以上就是一个解决特定帧头，动态长度的解码器。当然，这个解码器还可以做的更多，例如对数据做校验，这里也就不再展开了。运行效果和网上其他的类似，能够解决相应的粘包问题。使用也比较简单，在添加业务处理类前添加解码器即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">       RadarConnectThread radarConnectThread = <span class="keyword">this</span>;</span><br><span class="line">       b.group(eventLoopGroup).channel(NioSocketChannel.class)</span><br><span class="line">               .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">               .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">6000</span>)</span><br><span class="line">               .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">false</span>)</span><br><span class="line">               .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">                       socketChannel.pipeline().addLast(<span class="keyword">new</span> RadarDecoder()).addLast(<span class="keyword">new</span> RadarHandler(radarConnectThread));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> b;</span><br></pre></td></tr></table></figure>

<p>​    中间还是有一些点讲的不是很清楚，后续还会补充一片Netty客户端的博客，这篇博客更加全面的记录，同时修正之前博客的错误（又是一个坑）。</p>
<p>​    那就这样吧，结束。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/storm%E5%AD%A6%E4%B9%A0/Storm%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Storm初步使用"><a href="#Storm初步使用" class="headerlink" title="Storm初步使用"></a>Storm初步使用</h2><p>​    上一篇博客简单的介绍了Strom的一个Demo，但是没有介绍使用中的细节，这篇博客就来介绍一下上次遗漏的细节。算是一个进阶的学习吧。开始。</p>
<h3 id="Strom分组策略"><a href="#Strom分组策略" class="headerlink" title="Strom分组策略"></a>Strom分组策略</h3><ul>
<li><strong>Shuffle grouping</strong>: 随机分组，Tuples以一定方式随机分布在blot的task上，从而确保每个blot都具有相等数量的tuples。</li>
<li><strong>Fields grouping</strong>: 字段分组，stream按fields中指定的字段进行分组。例如，如果stream按照“ user-id”字段分组，则具有相同“ user-id”的Tuples将始终分到相同的task，但是具有不同“ user-id”的元组可能会到不同的task。</li>
<li><strong>Partial Key grouping</strong>: 部分密钥分组，stream按照指定的字段进行分组（如同上面的字段分组策略），但在两个下游blot之间进行负载平衡，当输入数据倾斜时，可以更好地利用资源。官方文档对它的工作原理和优点提供了很好的解释。地址如下：<a href="https://melmeric.files.wordpress.com/2014/11/the-power-of-both-choices-practical-load-balancing-for-distributed-stream-processing-engines.pdf">官网</a></li>
<li><strong>All grouping</strong>: 所有分组，stream在blot的所有task之间复制。请谨慎使用此分组策略。</li>
<li><strong>Global grouping</strong>: 全局分组，整个stream进入blot的task的其中一项。具体来说，它将转到ID最低的task上。</li>
<li><strong>None grouping</strong>:无分组，此分组指定您不关心stream的分组方式。没有分组策略等效于随机分组策略。不过，最终Storm会向下推没有分组的blot，最后让其订阅的blot或spout在同一线程中执行（如果可能）。（翻译就是这样，感觉还是不清楚细节，但是类似于随机分组）</li>
<li><strong>Direct grouping</strong>:直接分组，这是一种特殊的分组。以这种方式分组意味着Tuples的<strong>生产者</strong>决定消费者的哪个task将接收此Tuples。直接分组只能在已经声明为直接流的流上声明。直接流发出的元组必须使用<code>emitDirect</code>方法之一发出。blot可以使用提供的<code>TopologyContext</code>或通过<code>emit</code>在<code>OutputCollector</code>中跟踪方法的输出（返回处理Tuples的task的ID）来获取其使用者的任务ID。</li>
<li><strong>Local or shuffle grouping</strong>: 本地或随机分组，如果目标blot在同一工作进程中具有一个或多个任务，则元组将被随机转换为那些正在进行的任务。否则，这就像常规的随机分组。</li>
</ul>
<p>​    讲完了上面的八种分组策略，下面就来看看之前的demo中是如何使用的。</p>
<p>​    <code>fieldsGrouping(&quot;ExampleSpout&quot;, new Fields(&quot;word&quot;));</code>这段代码表示的是从实体<code>ExampleSpout</code>出来的ID为<code>default</code>的流按照字段分组，字段<code>word</code>内容相同的<code>tuple</code>将会交给相同的<code>task</code>处理。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200904174302403.png" alt="image-20200904174302403"></p>
<p>​    在blot中声明出去的流时，一个blot可能会发送出多个格式的流。同时，也可以指定流的ID，方便下游的多个blot接收。如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200904174842732.png" alt="image-20200904174842732"></p>
<h2 id="Storm中并行度理解"><a href="#Storm中并行度理解" class="headerlink" title="Storm中并行度理解"></a>Storm中并行度理解</h2><p>​    Storm中有一个并行度的概念，在设置blot的时候也可以设置这个东西，下面就来说说这个概念和它牵扯的一下东西。</p>
<p>​    了解并行度需要先了解Strom的三个实体的概念。</p>
<ul>
<li>Worker processes。一个工作进程执行拓扑的一个子集。辅助进程属于特定的拓扑，并且可以为该拓扑的一个或多个组件（blot或spout）运行一个或多个执行程序。正在运行的拓扑就是由在Storm集群中，许多计算机上运行的许多此类进程组成。</li>
<li>Executors (threads)。一个执行者是由一个工作进程催生了的一个线程。它可以为同一组件（blot或spout）运行一项或多项任务。</li>
<li>Tasks。一个任务是执行实际的数据处理的最小单元。您在代码中实现的每个spout或blot在整个集群中执行的任务数量一样多。在拓扑的整个生命周期中，组件的任务数量始终是相同的，但是组件的执行程序（线程）的数量会随着时间而变化。这意味着以下条件成立：threads ≤ tasks。默认情况下，任务数设置为与执行程序数相同，即Storm将在每个线程中运行一个任务。</li>
</ul>
<p>​    他们的关系如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200906234133843.png" alt="image-20200906234133843"></p>
<p>​    详细的解析也可以看这个博客：<a href="https://www.jianshu.com/p/ae619304d881">https://www.jianshu.com/p/ae619304d881</a>这个博客将的比较细，同时还有一些自己想法后的测试。</p>
<p>​    当然，也可以看官网上的解析，这些都是从官网了解到的，官网地址如下：<a href="http://storm.apache.org/releases/2.2.0/Understanding-the-parallelism-of-a-Storm-topology.html">http://storm.apache.org/releases/2.2.0/Understanding-the-parallelism-of-a-Storm-topology.html</a>。</p>
<p>​    了解了这些基础概念，就需要引入一个demo，开始了解并行度。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">conf.setNumWorkers(<span class="number">2</span>); <span class="comment">// use two worker processes</span></span><br><span class="line"></span><br><span class="line">topologyBuilder.setSpout(<span class="string">&quot;blue-spout&quot;</span>, <span class="keyword">new</span> BlueSpout(), <span class="number">2</span>); <span class="comment">// set parallelism hint to 2</span></span><br><span class="line"></span><br><span class="line">topologyBuilder.setBolt(<span class="string">&quot;green-bolt&quot;</span>, <span class="keyword">new</span> GreenBolt(), <span class="number">2</span>)</span><br><span class="line">               .setNumTasks(<span class="number">4</span>)</span><br><span class="line">               .shuffleGrouping(<span class="string">&quot;blue-spout&quot;</span>);</span><br><span class="line"></span><br><span class="line">topologyBuilder.setBolt(<span class="string">&quot;yellow-bolt&quot;</span>, <span class="keyword">new</span> YellowBolt(), <span class="number">6</span>)</span><br><span class="line">               .shuffleGrouping(<span class="string">&quot;green-bolt&quot;</span>);</span><br><span class="line"></span><br><span class="line">StormSubmitter.submitTopology(</span><br><span class="line">        <span class="string">&quot;mytopology&quot;</span>,</span><br><span class="line">        conf,</span><br><span class="line">        topologyBuilder.createTopology()</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>​    代码很好理解，spout和第一个blot的parallelism hint为2，最后的blot则为6。则得出这段程序总的并行度为：（2+2+6）/2=5至于原因上面的博客和官网也有解释。下面的图也是讲解：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200907000012034.png" alt="image-20200907000012034"></p>
<p>​    因为config设置了两个worker，但是总的线程有10个，相除即得并行度为5。但是这里还是不清楚并行度为5的意义和参考价值。可能是一个worker里面有多少executor吧。</p>
<p>​    后续公司也会把Strom的框架换掉，后续很有可能不再更新Strom的博客了。没有深入了解很是遗憾，但是人生不就是这样吧，终会有点不完美。事在人为有时就是说说而已，很多事我们没法决定和左右，只能尽自己最大的努力。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>storm学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/storm%E5%AD%A6%E4%B9%A0/Storm%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Storm基础概念了解"><a href="#Storm基础概念了解" class="headerlink" title="Storm基础概念了解"></a>Storm基础概念了解</h2><p>​    最近公司需要学习Storm，所以就来了解一下。本次的博客也是了解一下基础的概念，不涉及代码和其他的东西。大部分的东西都是来自于官网。</p>
<p>​    Apache Storm是一个免费的开源分布式实时计算系统。通过Apache Storm，可以轻松可靠地处理无限制的数据流，从而可以进行实时处理，而Hadoop可以进行批处理。Apache Storm很简单，可以与任何编程语言一起使用，并且使用起来很有趣！</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200706150422939.png" alt="image-20200706150422939"></p>
<h3 id="Storm中的基础概念"><a href="#Storm中的基础概念" class="headerlink" title="Storm中的基础概念"></a>Storm中的基础概念</h3><ul>
<li>Topologies（拓扑）。实时应用程序的逻辑被封装在 Storm topology（拓扑）中. Storm topology（拓扑）类似于 MapReduce 作业.两者之间关键的区别是 MapReduce 作业最终会完成, 而 topology（拓扑）任务会永远运行（除非 kill 掉它）. 一个拓扑是 Spout 和 Bolt 通过 stream groupings 连接起来的有向无环图.</li>
<li>Streams（流）。stream 是 Storm 中的核心概念.一个 stream 是一个无界的、以分布式方式并行创建和处理的 Tuple 序列. stream 以一个 schema 来定义, 这个 schema 用来命名 stream tuple（元组）中的字段.默认情况下 Tuple 可以包含 integers, longs, shorts, bytes, strings, doubles, floats, booleans, and byte arrays 等数据类型.你也可以定义自己的 serializers, 以至于可以在 Tuple 中使用自定义的类型.</li>
<li>Spouts。Spout 是一个 topology（拓扑）中 streams 的源头. 通常 Spout 会从外部数据源读取 Tuple，然后把他们发送到拓扑中.</li>
<li>Bolts。拓扑中所有的业务处理都在 Bolts 中完成. Bolt 可以做很多事情，过滤, 函数, 聚合, 关联, 与数据库交互等.</li>
<li>Stream groupings。topology（拓扑）定义中有一部分是为每一个 bolt 指定输入的 streams . stream grouping 定义了stream 如何在 Bolts tasks 之间分区.相当于将流分组，内置有八个.</li>
<li>Tasks。每个 Spout 或者 Bolt 都以跨集群的多个 Task 方式执行. 每个 Task 对应一个 execution 的线程.</li>
<li>Workers。Topologies （拓扑）在一个或者跨多个 worker 执行. 每个 Worker 进程是一个物理的 JVM.</li>
</ul>
<p>​    上面的信息都是来自于官网，官网地址为：<a href="http://storm.apache.org/">http://Storm.apache.org</a>。</p>
<p>​    介绍完了一些基础概念，下面就说说具体的流程，把这些概念串起来。</p>
<p>​    Storm集群上有两种节点：主节点和工作节点。主节点运行一个名为“ Nimbus”的守护程序，该守护程序类似于Hadoop的“ JobTracker”。Nimbus负责在集群中分发代码，向计算机分配任务以及监视故障。</p>
<p>​    每个工作程序节点都运行一个称为“ Supervisor”的守护程序。主管侦听分配给它的机器的工作，并根据Nimbus分配给它的东西启动和停止必要的工作程序。每个工作进程执行一个拓扑子集；一个正在运行的拓扑由分布在许多计算机上的许多工作进程组成。</p>
<p>​    Nimbus和主管之间的所有协调都是通过Zookeeper集群完成的。此外，Nimbus守护程序和Supervisor守护程序是快速故障且无状态的。所有状态都保存在Zookeeper或本地磁盘中。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200706221725445.png" alt="image-20200706221725445"></p>
<p>​    Spout是streams的源头。例如，Spout可能会从Kestrel队列中读取元组并将其作为流发出。否则，Spout可能会连接到Twitter API并发出一系列推文。</p>
<p>​    Bolts消耗任何数量的输入流，进行一些处理，并可能发出新的流。复杂的流转换（例如从一条推文流中计算趋势主题流）需要多个步骤，因此需要多个Bolts。Bolts可以执行任何功能，包括运行功能，过滤元组，进行流聚合，进行流联接，与数据库对话等等。</p>
<p>Spout和Bolts网络打包成一个“拓扑”，这是您提交给Storm集群以执行的顶级抽象。拓扑是流转换的图形，其中每个节点都是Spout或Bolts。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200706221938945.png" alt="image-20200706221938945"></p>
<p>​    需要注意：Storm拓扑中的每个节点都并行执行。在拓扑中，您可以为每个节点指定所需的并行度，然后Storm将在整个集群中产生该数量的线程来执行。</p>
<p>​    拓扑将永远运行，或者直到您将其杀死为止。Storm将自动重新分配所有失败的任务。此外，Storm保证即使机器宕机和消息丢失也不会丢失数据。</p>
<p>​    剩下的就是具体编写代码去验证和深入了解了，说实话，看这些枯燥的概念很容易犯困，所以我的意见还是找一个demo，边写代码边理解，这样比较容易理解，同时也会有一个类似于奖励的机制，才能学的更快。</p>
<p>​    下一遍就要来写代码了。    </p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>storm学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/storm%E5%AD%A6%E4%B9%A0/Storm%E7%AE%80%E5%8D%95demo/</url>
    <content><![CDATA[<h2 id="Storm简单demo"><a href="#Storm简单demo" class="headerlink" title="Storm简单demo"></a>Storm简单demo</h2><p>​    上一篇介绍了Storm的基础概念，下面就来实际写个demo。</p>
<p>​    因为是开发，所以基础的配置还是没有做，就是说是在本地跑的，没有集群之类的。</p>
<p>​    先整合一个基础的架子，使用的是SpringBoot的框架，但是移除了基础依赖，添加了Storm的依赖。上代码    前还是需要先解释一下一些基础的概念。然后再上代码。</p>
<p>​    Storm中使用tuple来作为数据元，相当于一个一个水滴，很多水滴汇集成流。每个tuple是一堆值，每个值有一个名字，并且每个值可以是任何类型。tuple中有两个概念，Values和Fields。tuple也是由这两个组成。</p>
<ul>
<li><p>Values类直接继承自Java中的ArrayList类，因为ArrayList类恰好能够很好地满足描述“一行”值的需要——有序、不去重、可伸缩。</p>
</li>
<li><p>Fields是为了定义Values的名字。在使用Values描述了一行值的概念之后，接下来如何知道这行值当中每一列值代表的含义，也就是要知道字段声明，就是Fields。</p>
</li>
</ul>
<p>​    知道这些概念后，剩下的就是代码的流程了。</p>
<p>​    代码首先新建一个拓扑，然后往拓扑中放入数据源Spout，在依次放入处理单元Bolt，根据需要对这些组件进行设置，比如数据的分组策略和线程的个数等等。Bolt有两个，第一个是先对数据进行初步处理，第二个Bolt对处理后的数据进行统计。最后在销毁拓扑的时候打印出统计的结果。流程就是这个样子，上代码。</p>
<p>​    Spout代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.strom.spout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.spout.SpoutOutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichSpout;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ExampleSpout.java</span></span><br><span class="line"><span class="comment"> * Description: 练习Spout，数据当源头。也叫壶嘴</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleSpout</span> <span class="keyword">extends</span> <span class="title">BaseRichSpout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spout输出收集器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SpoutOutputCollector spo;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String filed = <span class="string">&quot;word&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用数组模拟流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] messages = &#123;<span class="string">&quot;My nickname is xuwujing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;My blog address is http://www.panchengming.com/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;My interest is playing games&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 在spout组件初始化时被调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> spoutOutputCollector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;开始调用ExampleSpout的open方法&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.spo = spoutOutputCollector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: spout的核心，主要执行方法，用于输出信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= messages.length) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;第&quot;</span> + count + <span class="string">&quot;次模拟发送数据...&quot;</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Values类所作的优化主要是提供若干个支持可变列表的构造方法，包括全为String的参数类型、全为Integer的参数类型以及通用的Object类型</span></span><br><span class="line"><span class="comment">             * Values类直接继承自Java中的ArrayList类，因为ArrayList类恰好能够很好地满足描述“一行”值的需要——有序、不去重、可伸缩。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 必须设置messageId，才能调用ack方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">this</span>.spo.emit(<span class="keyword">new</span> Values(messages[count - <span class="number">1</span>]), count);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 声明数据格式，即输出的tuple中，包含了几个字段</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;ExampleSpout开始声明数据格式&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里Fields声明了几个字段，传tuple就要传多少个Values</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(filed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 当Topology停止时，会调用这个方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Topology停止&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 处理成功时，会调用这个方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;消息处理成功，消息ID&quot;</span> + msgId);</span><br><span class="line">        <span class="keyword">super</span>.ack(msgId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 当tuple处理失败时，会调用这个方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;消息处理失败&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.fail(msgId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    第一个Bolt代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.strom.bolt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.OutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Tuple;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ExampleBolt.java</span></span><br><span class="line"><span class="comment"> * Description:  Bolt练习，处理流数据的地方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentationBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OutputCollector outputCollector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 在Bolt启动前执行，提供启动的环境。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputCollector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;进入SegmentationBolt的prepare&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.outputCollector = outputCollector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: Bolt的核心,执行的方法。每次接收一个tuple，就会调用一次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tuple</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;开始执行处理方法&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Spout已经定义了这个field</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String msg = tuple.getStringByField(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">        String[] words = msg.toLowerCase().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 发送到下个bolt</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">this</span>.outputCollector.emit(<span class="keyword">new</span> Values(word));</span><br><span class="line">        &#125;</span><br><span class="line">        outputCollector.ack(tuple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 声明数据格式，即输出的tuple中，包含了几个字段。Bolt执行完毕也会输出一个流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;ExampleSpout开始声明数据格式&quot;</span>);</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">&quot;count&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 释放该Bolt占用的资源，Strom在终止时会调用这个方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;SegmentationBolt资源释放&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    第二个Bolt代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.strom.bolt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.OutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CountBolt.java</span></span><br><span class="line"><span class="comment"> * Description: Bolt练习，计数的Bolt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存单词和对应的计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; counts = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;进入CountBolt的prepare&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.counts = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        String msg = tuple.getStringByField(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;第&quot;</span> + count + <span class="string">&quot;次统计单词次数&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(msg)) &#123;</span><br><span class="line">            counts.put(msg, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counts.put(msg, counts.get(msg) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 最后执行，打印统计的单词次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;下面就是单词次数================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;单词&quot;</span> + entry.getKey() + <span class="string">&quot;出现&quot;</span> + entry.getValue() + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;输出结束=======================&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;释放资源&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 不在往下一个Bolt输出，所以没有代码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;CountBolt开始声明数据格式&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    启动入口代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.strom.bolt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.OutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CountBolt.java</span></span><br><span class="line"><span class="comment"> * Description: Bolt练习，计数的Bolt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存单词和对应的计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; counts = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;进入CountBolt的prepare&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.counts = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        String msg = tuple.getStringByField(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;第&quot;</span> + count + <span class="string">&quot;次统计单词次数&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(msg)) &#123;</span><br><span class="line">            counts.put(msg, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counts.put(msg, counts.get(msg) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 最后执行，打印统计的单词次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;下面就是单词次数================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;单词&quot;</span> + entry.getKey() + <span class="string">&quot;出现&quot;</span> + entry.getValue() + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;输出结束=======================&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;释放资源&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 不在往下一个Bolt输出，所以没有代码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;CountBolt开始声明数据格式&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    剩下就没有什么主要代码了，还有就是pom文件和一些配置文件。因为没有使用SpringBoot的基础类，所以没有Spring的配置文件，只有一个日志文件是为了方便调试。配置文件代码如下。</p>
<p>pom文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>strom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>strom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--storm相关jar  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.storm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>storm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    日志配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;60&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%-4r [%t] %-5p %c&#123;1.&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.storm&quot;</span> <span class="attr">level</span>=<span class="string">&quot;OFF&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.zookeeper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;OFF&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;OFF&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    以上就是代码了，因为是简单的demo，只是本地模式，所以运行起来也很简单。后续的集群部署还需要在了解一下。运行的截图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200708212602792.png" alt="image-20200708212602792"></p>
<p>​    没有什么可以讲的了，后面就是要再写一个集群部署的知识点。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>storm学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/storm%E5%AD%A6%E4%B9%A0/Storm%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Storm集群部署"><a href="#Storm集群部署" class="headerlink" title="Storm集群部署"></a>Storm集群部署</h2><p>​    上一篇博客写了一个demo，在IDEA中也跑成功了，下面就是部署到集群环境中去运行，也是搞了一天，和普通的Java项目有点不太一样。开始。</p>
<p>​    部署Storm集群比较繁琐，网上资料也鱼龙混杂，所以还是建议大家去官网上找官方文档。</p>
<p>​    Storm官方部署流程：<a href="http://storm.apache.org/releases/2.2.0/Setting-up-a-Storm-cluster.html">http://storm.apache.org/releases/2.2.0/Setting-up-a-Storm-cluster.html</a></p>
<p>​    首先就是下载基础的东西，jdk和Strom、zookeeper安装包。地址如下：</p>
<p>​    JDK下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a></p>
<p>​    Storm下载地址：<a href="http://storm.apache.org/downloads.html">http://storm.apache.org/downloads.html</a></p>
<p>​    ZooKeeper下载地址：<a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p>
<p>​    需要注意的是下载的时候注意，Storm和ZooKeeper需要下载发行版本，不要下载源码版本，要不然会出现问题，很蛋疼。如下图</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200710104725796.png" alt="image-20200710104725796"></p>
<p>​    下载完毕，放到自己指定的目录，解压就可以了。一步一步来吧。</p>
<ul>
<li><p>安装JDK</p>
<p>1.查看是否已经安装jdk</p>
<p>rpm -qa|grep jdk</p>
<p>2.卸载原有jdk，因为openjdk不适用</p>
<p>yum -y remove java-1.8.0-openjdk-headless-1.8.0.65-3.b17.el7.x86_64</p>
<p>3.将jdk安装包上传到服务器上。将其解压到指定位置。记得先创建文件夹</p>
<p>tar -zxvf jdk-8u191-linux-x64.tar.gz -C /usr/local/java/</p>
<p>4.在/etc/profile文件末尾添加</p>
<p>export JAVA_HOME=/usr/local/java/jdk1.8.0_191</p>
<p>export JRE_HOME=${JAVA_HOME}/jre</p>
<p>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib</p>
<p>export PATH=${JAVA_HOME}/bin:$PATH</p>
<p>5.使/etc/profile文件生效</p>
<p>source /etc/profile</p>
<p>6.验证安装是否成功</p>
<p>Java -version</p>
</li>
<li><p>安装ZooKeeper</p>
<p>Zookeeper有一个官方安装文档，很详细。地址：<a href="https://zookeeper.apache.org/doc/r3.3.3/zookeeperAdmin.html#sc_systemReq">https://zookeeper.apache.org/doc/r3.3.3/zookeeperAdmin.html#sc_systemReq</a></p>
<p>需要注意的就是，Storm使用Zookeeper协调集群。ZooKeeper 不用于消息传递，因此Storm在Zookeeper上的负载非常低。在大多数情况下，单节点Zookeeper集群就足够了。所以我安装的就是单节点的ZooKeeper。按照文档来就可以了，没有什么可以讲的点，如果不行在网上搜一下错误信息。</p>
</li>
<li><p>安装Storm</p>
<p>把Storm的包解压到指定目录，修改配置文件，这一步需要注意的是，例如：<code>storm.local.dir: &quot;/mnt/storm&quot;</code>前面是有一个空格的，要不然启动时会抱错误。安装流程文档就是最上面的一个链接。</p>
<p>修改完毕配置文件后，依次启动服务。<code>bin/storm nimbus</code>,<code>bin/storm nimbus</code>,<code>bin/storm ui</code>。因为UI服务默认占用的是8080端口，如果有修改需要，只需要在配置文件添加：<code>ui.port: 8083</code>（注意空格）。</p>
<p>剩下就没有什么了，启动三个服务后，输入一下网址：<code>http://&#123;ui host&#125;:8080</code>就可以看到Storm的UI，如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200710110638215.png" alt="image-20200710110638215"></p>
<p>这里就不再介绍各个组件的意思了，都很容易看懂。</p>
</li>
<li><p>提交自己的Topology</p>
<p>提交自己的Topology也很简单，官网上也有详细的介绍，地址：<a href="http://storm.apache.org/releases/2.2.0/Running-topologies-on-a-production-cluster.html">http://storm.apache.org/releases/2.2.0/Running-topologies-on-a-production-cluster.html</a></p>
<p>需要注意的是，如果你的Storm没有加入环境变量，需要使用全路径，如下：</p>
<p><code>/apache-storm-2.2.0/bin/storm jar strom-0.0.1-SNAPSHOT.jar com.example.strom.StromApplication count </code> </p>
<p>另外，打包的时候也需要注意，要指定主类，要不然会一直报找不到主类的错误。</p>
<p>打包需要注意去除SpringBoot的依赖，因为他本身带有打包插件，打包会报错误。</p>
<p>打包插件代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.example.strom.StromApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上传正常截图如下：<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200710114634347.png" alt="image-20200710114634347"><br>删除Topology截图如下：<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200710112836552.png" alt="image-20200710112836552"></p>
<p>StormUI截图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200710114916495.png" alt="image-20200710114916495"></p>
</li>
</ul>
<p>​    剩下就没有什么要说的了。这样就初步完成集群部署了。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>storm学习</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E5%BF%83%E5%BE%97/%E8%AE%B0%E6%9C%80%E8%BF%91%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="记最近一段时间的学习"><a href="#记最近一段时间的学习" class="headerlink" title="记最近一段时间的学习"></a>记最近一段时间的学习</h2><p>​    最近一段时间在学习红黑树，中间也停过一段时间，本以为是一个简单的事情，最后发现并没有想象中的简单。还是太年轻了啊。学习中间遇到了一些问题，这里也列举出来，分析一下原因，后面防止再犯。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>​    如果看到我之前的博客，可以看出这一段时间再梳理红黑树的相关知识点，中间还穿插了其他的东西。其实穿插不是我的本意，我以为一个星期就能啃完，但是中间的过程出乎我的意料，比我想象中的要麻烦和难缠。</p>
<p>​    两篇博客其实没有远没有达到我想象中的要求，感觉还是差点意思。原因也很简单，中间因为一些事情困惑了很久，最后写出来的文章自然差点意思。下面就具体说一说这两篇博客中间遇到的问题。</p>
<ul>
<li>在编写博客时，查阅了很多的资料。但是国内的环境大家都懂，水平层次不齐，找文章也是找了很久，最后不得己在外网找到一些文章，通过多篇文章联合补充了自己的认知。</li>
<li>写到一半就没有动力继续写了，只要打开编辑器就感觉知乎是这么好看，手头的工具是多么的不好用，指甲为什么没剪齐等等等。只要开始写，就没有了动力和激情。</li>
<li>编写这类博客或者学习这类知识点时，没有一个框架去套这些东西。就是说自己的逻辑思维里很少有学习这些知识的套路，不清楚如何学、怎样写。说白了，没有建立起自己的知识体系。</li>
<li>事情拖延太过于严重，总觉得写博客的紧张感没有工作时的紧张感大，也不强烈。可能也是导致没有动力的原因。</li>
<li>以算法为例：自己这一块的知识储备很少，  和上面的问题类似，遇到这类知识的学习没有头脑。</li>
</ul>
<h3 id="建议的方法"><a href="#建议的方法" class="headerlink" title="建议的方法"></a>建议的方法</h3><p>​    给出问题只是第一步，根据这些问题想出自己的答案才是最重要的。这里的方法只是针对于我自己，每个人的问题表现可能一样，但是原因可能有很大不同，万不可直接对号入座。</p>
<ul>
<li><strong>资料的重要性。</strong>学习时，资料时非常重要的，我是已经吃过苦头了，这里给出自己对于资料的先后排序。纸质书籍&gt;电子书籍&gt;维基百科&gt;谷歌资料&gt;国内资料。这里简单说明一下，首先一个作者能够出书显然已经证明了自己的实力，要不然一般人不会去花这个时间和精力的，所以书籍应该在前面。书籍的选择要看个人，并不是所有的书籍都合适，有些水书还是不要看了。外网的资料是比较全面，维基百科上面还是比较准确的（就技术方面资料而言），谷歌搜集的资料相对于国内的资料还是比较准确的，国内因为搜索引擎的限制，搜出来的文章都是粘贴复制，这个是大家都能看到的事实，并没有刻意贬低的意思。</li>
<li><strong>兴趣的重要性。</strong>兴趣是最好的老师，上学时，老师教导遇到困难要迎难而上，但是学习不是搞项目，兴趣才是最好的老师。所以尽量去专研哪些自己感兴趣的知识点，或者提升自己做事的兴趣，例如将自己的博客记录下来就是我编写这两篇博客最大的动力。想要将自己的知识展示出来或者说炫耀出来可能是我学习最大的动力。（。。。。汗颜）针对于每个人的情况，最好找到适合自己的兴趣，不要去做让自己痛苦并且毫无成就感的事，工作亦是如此。</li>
<li><strong>逻辑的重要性。</strong>学习一样东西，最好是有类似的经验，知道怎么个套路去学习。但是套路都是摸索出来的，多记录就会让自己的逻辑感慢慢增强。（个人对于逻辑感的理解，可能这里形容的不是很准确）如何形成自己的逻辑感？1.将学习过程中的迷惑记录下来。2.还有就是学习中对于知识点的感悟也记录下来，用于形成知识体系。还是多记录吧。</li>
<li><strong>一件事情最好三天内能够结束，要不然就可以放弃了。</strong>这个是我在《小狗钱钱》里面看到的一个理论（非常推荐这本书）。理论的正确性不去探讨，但是这个理论可以在一定程度上给予我们学习中的紧张感，所以在学习中间要制定一个里程碑，给出三天的时间，完不成就放弃，这样就可以让规则束缚自己去前进了。遇到大的问题，要进行细化，在将合理的小问题规划时间。（是不是和工作中的任务的制定类似，有没有那味了？）</li>
<li><strong>考虑问题要全面。</strong>这个是在学习红黑树删除时意识到的，网上将删除只是列举了几种情况，但是不说情况的来由或者没有详细说，导致自己看的很迷惑。所以在遇到类似的问题时，可以通过穷举法列举出所有的可能，再逐一去排除这些可能，或者将这些可能中的几种整合到一起。达到最后融会贯通的目的。</li>
</ul>
<p>​    感觉写了很多东西，但是回头看并没有多少字。千言万语仿佛吐不出来，还是自己写作的水平需要提高啊。记录一下，给后来的自己提个醒。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E5%BF%83%E5%BE%97/%E8%AE%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E6%83%91/</url>
    <content><![CDATA[<h2 id="记最近的一次工作中遇到的困惑"><a href="#记最近的一次工作中遇到的困惑" class="headerlink" title="记最近的一次工作中遇到的困惑"></a>记最近的一次工作中遇到的困惑</h2><p>​    在接近年底的时候，一般都没有什么重要的活了，今年不太一样，到了年底活还是比较多。我最开始以为这次的任务其他的没有什么不一样，如果是这样的话，我也不会写这一篇博客了，这次的任务中遇到的问题和一些事情改变了我的一些想法，有一些困惑和想法，不记录有些难受，也希望后面遇到类似的问题可以不再走弯路。先说说任务吧。</p>
<p>​    任务还是比较简单的，就是开发两个简单的平台，一个边缘端，一个中心端。边缘端相当于一个协议转换器，对一些设备的协议做转换，接收的数据存储和解析，然后上传到中心端。中心端类似于展示平台，对边缘端的数据收集和展示，同时也有着边缘端的设备信息的维护。很简单的两个小平台。但是我也没有想到就是这两个平台在后面对我造成的困惑比之前做过的许多东西都多。慢慢说吧。</p>
<p>​    边缘端的开发比较简单，就是利用netty开发一个协议转换器，同时编写http接口，完成设备信息从中心端下发到边缘端。需要注意的就是设备可能存在多个，需要维护多种类型和多种协议的设备。</p>
<p>​    中心端目前相对于边缘端还要简单一些，就是几种设备的简单的增删改查，还有就是通过OpenFeign集成了接口的调用，还是简单的数据的展示。</p>
<p>​    整体功能也比较简单，甚至没有什么难点。但是中间边缘端我是一直在卡着，不知道怎么下手，曾经一度想要将项目重写，编写功能的时候也不知道如何开始，抓不到头。感觉陷入了一个非常奇怪的圈：想要抓住一个头进行开发，但是不知道从哪里进行开发，又陷入了无限的思考中，去想各个细节，但是随着花费时间过多，又想要赶紧有产出，就又开始想要抓住一个头进行开发，就是这样的一个圈。</p>
<p>​    下面说一下自己的感受。感觉还是自己编写代码太少，虽然毕业已经快两年了，但是除去耽误的时间，实际用来编写代码的时间太少了，还是自己的能力不足，没有能力去尝试搭建起一个项目，项目中需要考虑的很多东西都没有遇到过，也没有良好的解决方法。让我这样的人去解决一个困难和协议我可能做起来比较轻松，但是如果要让我去想一个系统的架构或者去想一种思路去解决一类问题就有些吃力。遇到的场景和编写的代码太少导致这个现象。</p>
<p>​    还有就是开发过程中的一些状态不太对劲。作为开发，需求的变更和前期收集资料不全这些情况应该是被考虑在内的，不应该因为这些客观原因导致后面系统的变更太过于频繁和不确定性。应该在初期或多或少考虑到这些问题，然后在开发中对这些情况进行预留处理或者找到改动较小的办法。中间我的状态很差，一度怀疑是自己的问题，怀疑自己并不是适合干这一行，然后也对自己的身体状态产生了怀疑，怀疑自己的注意力无法集中，无法再去思考问题。这种情况很危险，至少我事后回想是很危险的，工作上的任何事情都不应该归结到自己的身上，要始终记得，工作只是人生中的一段经历，不是自己不适合工作，而是没有找到适合自己的工作。所以也就有了编写这篇博客的欲望，记录一下这个特殊时期的自己。</p>
<p>​    然后就是工作中一些方法的总结，在开发过程中有一段时间一直在想如何去实现具体的功能，这些功能需要哪些基础，应该先写哪些地方。然后就是越想越多，越来越不知道如何编写。所以后面的感悟就是：当做一件不确定的事时，要让行动主导思维，不要让思维去主导行动，这样就会一直处在拖延中，无法找到目的和线头。只要确定了目的，就算一团乱麻，中间也会一个一个遇到你可能想到的任何问题。所以没必要让很多暂时没有遇到的问题成为你的第一块挡脚石。</p>
<p>​    下面就来总结一下自己的收获。</p>
<p>1.<strong>没有具体的能力时，做相应的事情是较困难的，但是过去后会发现自己的思维不一样了</strong></p>
<p>2.<strong>开发中的不确定性和调研不稳定性是正常的，不要抱怨，只有经历的多了才会考虑到这些</strong></p>
<p>3.<strong>永远不要将工作的不顺利归结到自己身上，没有不适合的人，只有不适合的工作</strong></p>
<p>4.<strong>当做的是一件不确定和无从下手的事时，要让行动主导思维，不要让思维主导行动，某些情况下考虑的越多越是无用</strong></p>
<p>5.<strong>对自己的困惑和迷茫要多总结，生活和工作不能迷迷糊糊就过去</strong></p>
<p>​    记录这些作为对自己的一个提示和警醒。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    冒泡排序是非常基础的排序算法之一，也很容易理解。过程简单来说就是：每次比较相邻的两个元素，如果前一个元素大于后一个元素就交换这两个元素的位置（不一定大于，小于也可以）。一直重复这个操作，知道数组中所有的元素排序正确后，即所有的元素都不需要交换位置。</p>
<p>​    也可以看看动图去理解。动图这里放上一个链接，菜鸟教程的：<a href="https://www.runoob.com/w3cnote/bubble-sort.html">菜鸟教程冒泡排序</a><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡算法动图链接"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>​    实现起来也是比较简单的：代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) BaseSort.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>​    当然，这个算法还有一些可以优化的点，但是对于算法的总体效果来说，作用不大，当作一个了解吧。</p>
<h3 id="优化进入排序的条件"><a href="#优化进入排序的条件" class="headerlink" title="优化进入排序的条件"></a>优化进入排序的条件</h3><p>​    通过一些特殊的例子，我们可以看到，某些情况下，当数组内没有进行交换后，循环还是会继续，这个时候其实可以中断循环，这个优化的思路就是这样：当发现某次循环后元素没有进行交换，就退出循环，因为当前数组已经有序了。需要增加一个变量记录当前循环是否交换变量。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> swaped = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//如果没有发生交换，代表当前数组有序，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (!swaped) <span class="keyword">break</span>;</span><br><span class="line">        swaped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                BaseSort.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swaped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记录最近一次交换的数组下标"><a href="#记录最近一次交换的数组下标" class="headerlink" title="记录最近一次交换的数组下标"></a>记录最近一次交换的数组下标</h3><p>​    如果在一次循环中，数组前几次排序进行了交换，但是后面没有交换位置，其实我们这里可以在下一次循环时，只循环到最后一次交换的下标，因为后面的元素没有交换过，代表已经有序了。这个优化的思路就是如此。这里也可以结合前一个优化，都添加进来。具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  当前循环是否交换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> swaped = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前循环的最后一个index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> lastIndex = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后交换的数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> swapedIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swaped) &#123;</span><br><span class="line">        swaped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//因为第一次的循环，交换的index只会到arr.length - 2,所以这里用小于</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                BaseSort.swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                swaped = <span class="keyword">true</span>;</span><br><span class="line">                swapedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastIndex = swapedIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    注释写的也比较清楚了，这里就不再详细讲解了。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​    力扣上面其实也有相关的题，可以练手。下面就写两道题。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></li>
</ul>
<p>​    思路不是很容易想到，最主要的就是想明白排序的依据，即决定数组元素位置的依据。规则已经写在题目中了。剩下就没有什么需要注意的了。送上代码，使用的是冒泡，效率不是很高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.offer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * offer45.java</span></span><br><span class="line"><span class="comment"> * Description: 把数组排成最小的数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">offer45</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String result = <span class="keyword">new</span> offer45().minNumber(nums);</span><br><span class="line">        System.err.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                String tmp1 = nums[j] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                String tmp2 = nums[j + <span class="number">1</span>] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">              <span class="comment">//排序的依据，即题目里面的意思。tmp1+tmp2&gt;tmp2+tmp1  tmp1&quot;&gt;&quot;tmp2</span></span><br><span class="line">                <span class="keyword">if</span> (Long.parseLong(tmp1 + tmp2) &gt; Long.parseLong(tmp2 + tmp1)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            stringBuilder.append(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></li>
</ul>
<p>​    这个思路就比较简单了，因为冒泡排序不会影响数组中原有元素的位置顺序，所以直接冒泡即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LeetCode283.java</span></span><br><span class="line"><span class="comment"> * Description: 移动零</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode283</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> LeetCode283().moveZeroes(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.err.print(num + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><ul>
<li><p>堆是一个完全二叉树，这样的堆也被称为二叉堆。（之前了解过相关知识，但是现在大部分忘记了。后续博客上会补充上去）</p>
</li>
<li><p>子节点大于如果大于节点，这样的堆称为小顶堆。子节点小于节点的堆称为大顶堆。</p>
<p>堆的基本操作有插入、删除堆顶元素。</p>
</li>
</ul>
<h2 id="堆的操作图解"><a href="#堆的操作图解" class="headerlink" title="堆的操作图解"></a>堆的操作图解</h2><ul>
<li>堆化。将堆中的元素重新按照堆的结构插入，类似于排序。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_DC4BB8DB8C61-1.jpeg" alt="IMG_DC4BB8DB8C61-1"></p>
<ul>
<li><p>删除堆顶元素。将堆顶的元素删除，再将堆进行堆化。（其中，如果出现了数组空洞，可以将最后一个元素覆盖堆顶元素，再执行堆化）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_A1368FA8ADD6-1.jpeg" alt="IMG_A1368FA8ADD6-1"></p>
</li>
</ul>
<h2 id="在平时代码中的应用"><a href="#在平时代码中的应用" class="headerlink" title="在平时代码中的应用"></a>在平时代码中的应用</h2><p>可能是因为我了解的太少，感觉用处不是很大，因为基础的工具对于这些数据的操作大部分都已经封装好了，只需要知道怎么调用就可以了。但是作为程序员来说，知道其内部原理还是比较好的。</p>
<p>因为很长时间没有学习数据结构了，所以这个写着相当费力，后面陆续会写相关博客，但是可能不是很多。。。</p>
<p>代码在下面。注释中对于代码的解释已经很详细了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> arraytrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HeapTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 堆的练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆内当前堆元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆内最大堆元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description:初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapTrain</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        capacity = count;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            System.err.print(<span class="string">&quot;[&quot;</span> + arr[i] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 换位方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> swap = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = swap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description:向堆中插入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">        arr[n] = value;</span><br><span class="line">        <span class="keyword">int</span> i = n;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 两个判断条件，一个是i是不是标号最小的元素、节点是不是大于子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (i / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; arr[i / <span class="number">2</span>] &lt; arr[i]) &#123;</span><br><span class="line">            swap(i / <span class="number">2</span>, i);</span><br><span class="line">            i = i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description:删除堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 堆内可以放负数，如果arr[1]=0,负数就没法比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将最后的元素放到跟节点，防止数组空洞。同时将两步堆化合并为一步</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        arr[<span class="number">1</span>] = arr[count];</span><br><span class="line">        n--;</span><br><span class="line">        heaply(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 堆化处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heaply</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 默认当前节点是最大节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> maxValueIndex = index;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  先计算左节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (maxValueIndex * <span class="number">2</span> &lt;= n &amp;&amp; arr[maxValueIndex] &lt; arr[maxValueIndex * <span class="number">2</span>]) &#123;</span><br><span class="line">                maxValueIndex = maxValueIndex * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 计算右节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (maxValueIndex * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; arr[maxValueIndex] &lt; arr[maxValueIndex * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                maxValueIndex = maxValueIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 经过比较确实是最大节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (maxValueIndex == index) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(index, maxValueIndex);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 把最大节点给到当前节点的子节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            index = maxValueIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeapTrain heapTrain = <span class="keyword">new</span> HeapTrain(<span class="number">10</span>);</span><br><span class="line">        heapTrain.insert(<span class="number">3</span>);</span><br><span class="line">        heapTrain.insert(<span class="number">1</span>);</span><br><span class="line">        heapTrain.insert(<span class="number">9</span>);</span><br><span class="line">        heapTrain.heapPrint();</span><br><span class="line">        System.err.println();</span><br><span class="line">        heapTrain.deleteMax();</span><br><span class="line">        heapTrain.heapPrint();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="算法复习"><a href="#算法复习" class="headerlink" title="算法复习"></a>算法复习</h2><p>把想法转换成代码也是很困难的</p>
<p>先把几个排序算法都写写博客，最好找几个题练习一下</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>​    动态规划适用的问题：原问题的解可以用子问题的答案回答。他也有两个重要的点：1）找到最优解子结构，即原问题和子问题的关系。2）子问题之间的联系（不是必须），主要是防止解答重复的子问题。</p>
<ul>
<li>将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。（核心）</li>
<li>分治法和动态规划的区别主要就是有无子问题重复的情况。</li>
</ul>
<h4 id="线性动态规划"><a href="#线性动态规划" class="headerlink" title="线性动态规划"></a>线性动态规划</h4><p>​    线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。</p>
<h3 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h3><p>广度优先搜索算法（Breadth-First-Search，缩写为 BFS），是一种利用队列实现的搜索算法。简单来说，其搜索过程和 “湖面丢进一块石头激起层层涟漪” 类似。</p>
<p>深度优先搜索算法（Depth-First-Search，缩写为 DFS），是一种利用递归实现的搜索算法。简单来说，其搜索过程和 “不撞南墙不回头” 类似。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>​    冒泡排序是比较基础的排序，就是将数组中的元素两两比较，如果前一个元素大于后一个元素，就将其交换。大的放在数组后面，直到元素循环完毕。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。选择排序是不稳定的。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序的思想就是，将数组分为两个部分，后面部分的元素循环和前一部分的元素比较，直到找到自己合适的位置。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>插入排序的优化版：思想就是：将数组分为间隔不同的字数组，分别为这些字数组进行插入排序。然后将间隔缩小，再进行排序，最好间隔为1，就是插入排序。主要是利用了排序中间产生的多个逆序对来缩小排序时间。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>从数组中取出一个基数，比这个基数大的放右边，小的放左边。这样在递归的调用两边的数组。直到排序完成</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>将两个有序的数组进行组合排序就是归并排序，将数组分为两个字数组，分别递归让字数组有序，再比较两个数组头部元素的大小。分别插入到新的数组中。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    前面学习了冒泡排序，其实我一直将冒泡和选择搞混淆，因为冒泡也是每次循环找到最大或者最小的元素，但是冒泡多了一步交换。选择排序就不同，每次循环找到最大值或者最小值，最后才将其放到队尾或者队首。</p>
<p>​    说这这里，选择排序的概念就很清楚了，有两个循环，外循环遍历所有的元素，内循环遍历找到最大值，内循环完成后，将当前循环的最大值移动到队尾。外循环完成后，排序也就完成了。示意图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8c42ffa5ab7186aa7f09e4ce68e338b9.png" alt="img"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​    代码来说就比较简单了，甚至比冒泡排序还要简单。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环到数组到前一个元素即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        BaseSort.swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看代码也能看出来，选择排序对于数组中元素的位置有破坏，即大家常说的选择排序不稳定。（如果数组中两个元素的位置经过排序后发生了变化，这种算法就是不稳定的）冒泡排序因为每次比较都可能交换了位置，所以冒泡排序后的数组元素的位置仍然能够保持之前的位置。（相同的元素）这也是选择排序的一个缺点吧。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>​    选择排序的优化思路也比较好想，就是在比较多过程中同时找到最大值和最小值。这样会比原有的写法快一点。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        minIndex = maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[maxIndex]) maxIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        BaseSort.swap(arr, i, minIndex);</span><br><span class="line">        <span class="comment">//防止最大值为i的情况。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) &#123;</span><br><span class="line">            BaseSort.swap(arr, length - <span class="number">1</span> - i, minIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BaseSort.swap(arr, length - <span class="number">1</span> - i, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码中间唯一需要注意的地方也写了注释了，其他就没有什么可讲的了。代码我自己测试了几个用例，没有发现什么问题，但是测试较少，怀疑还是存在一些没有考虑到的情况。这里也欢迎大家指正。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​    还是把选择排序练习一下。这里上两个题目。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></li>
</ul>
<p>​    思路比较简单，利用选择排序，找最大值，如果是第k大大元素，就返回，否则继续排序。优化的点其实也有：可以判断k是否大于数组中间长度，然后决定是找最大还是最小，能一定程度减少一些运算。但是因为时间问题，我实现的代码并没有做这个优化。具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">int</span> maxIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[maxIndex]) maxIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == k) <span class="keyword">return</span> nums[maxIndex];</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[maxIndex];</span><br><span class="line">        nums[maxIndex] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a></li>
</ul>
<p>​    这个也很简单，思路是直接用选择排序，可以用二元选择排序。没有什么可讲的点，但是因为力扣的时间限制，该代码没有通过。思路是正确的，后面这道题也可以选择其他时间复杂度较低的排序算法，例如：快速排序，归并排序等。选择排序思路如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        minIndex = maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) minIndex = j;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[maxIndex]) maxIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        swap(nums, i, minIndex);</span><br><span class="line">        <span class="comment">//防止最大值为i的情况。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) &#123;</span><br><span class="line">            swap(nums, length - <span class="number">1</span> - i, minIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(nums, length - <span class="number">1</span> - i, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    至此，选择排序基本讲完了，也欢迎大家补充、指正。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%9D%82%E9%A1%B9/JAVA%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%9A%8435%E4%B8%AA%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="JAVA代码优化的35个细节"><a href="#JAVA代码优化的35个细节" class="headerlink" title="JAVA代码优化的35个细节"></a>JAVA代码优化的35个细节</h1><ul>
<li><p>1、尽量指定类、方法的final修饰符<br>  为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程就是内联。</p>
</li>
<li><p>2、尽量重用对象<br>新建对象不仅仅要花时间去生成，还要花时间去回收。对于字符串的操作最好是使用StringBuilder/StringBuffer。</p>
<pre><code>  /**
   * 不正确的方式，会新建多个String对象
   */
  String s = &quot;a&quot; + &quot;b&quot;;
  System.out.println(s);
  /**
   * 使用StringBuilder/StringBuffer的方法来拼接字符串
   */
  StringBuilder stringBuilder = new StringBuilder();
  stringBuilder.append(&quot;a&quot;).append(&quot;b&quot;);
  System.out.println(stringBuilder);
  
</code></pre>
</li>
<li><p>3、尽可能使用局部变量<br>  调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p>
<ul>
<li>栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。  </li>
<li> 堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。  </li>
</ul>
<pre><code> int [] arr=new int [3];
</code></pre>
<p>  这样先在栈中创建一个arr变量，再给这个变量赋值，发现右边是一个实体，所以在堆中创建一个实体空间。</p>
</li>
<li><p>4、及时关闭流<br>  对流的操作结束了，要及时关闭以释放资源。</p>
</li>
<li><p>5、尽量减少对变量的重复计算<br>  调用方法，哪怕只有一行，也是有消耗的。</p>
<pre><code>  for (int i = 0; i &lt; arr.length; i++) &#123;
      //频繁调用了arr.length方法
  &#125;
  int length = arr.length;
  for (int i = 0; i &lt; length; i++) &#123;
      //比上一个少调用了length方法
  &#125;
</code></pre>
</li>
<li><p>6、尽量采用懒加载的策略，即在需要的时候才创建<br>  判断创建对象时，尽量在if语句里面创建对象，采用懒加载方式。</p>
</li>
<li><p>7、慎用异常<br>  异常只能用于错误处理，不应该用来控制程序流程。</p>
</li>
<li><p>8、不要在循环中使用try…catch…，应该把其放在最外层</p>
</li>
<li><p>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度    如果初始容量为5000，默认初始长度为16（StringBuilder），这样就会一直在扩展和复制数组，造成资源浪费。</p>
</li>
<li><p>10、当复制大量数据时，使用System.arraycopy命令</p>
</li>
<li><p>11、乘法和除法使用移位操作<br>  最好加上注释，方便别人理解</p>
<pre><code>  for (int var = 0; var &lt; 100; var += 5) &#123;
      int a = var * 8;
      int b = var / 2;
      System.err.println(&quot;a=&quot;+a+&quot;: b=&quot;+b);
  &#125;
  for (int var = 0; var &lt; 100; var += 5) &#123;
      int a = var &lt;&lt; 3;
      int b = var &gt;&gt; 1;
      System.err.println(&quot;a=&quot;+a+&quot;: b=&quot;+b);
  &#125;
  
  &lt;&lt;      :    左移运算符，num &lt;&lt;1,相当于num乘以2
  &gt;&gt;      :    右移运算符，num &gt;&gt;1,相当于num除以2
  &gt;&gt;&gt;    :    无符号右移，忽略符号位，空位都以0补齐，（计算机中数字以补码存储，首位为符号位）。
</code></pre>
</li>
<li><p>12、循环内不要不断创建对象引用<br>  这样导致内存中有循环次数个对象。建议在循环外声明，在循环内重新赋值。</p>
</li>
<li><p>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</p>
</li>
<li><p>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</p>
</li>
<li><p>15、不要将数组声明为public static final<br>  将数组声明为static和final没有意义，因为数组的内容还是可以改变。</p>
</li>
<li><p>16、尽量在合适的场合使用单例<br>单例适用的范围。</p>
<ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
</li>
<li><p>17、尽量避免随意使用静态变量<br>  如果某个对象被静态变量引用，除非静态变量所在的类被卸载，否则这个对象是不会被gc回收的。</p>
</li>
<li><p>18、及时清除不再需要的会话<br>  当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。</p>
</li>
<li><p>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历<br>  实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；</p>
<pre><code>  ArrayList arrayList = new ArrayList&lt;String&gt;(100);
  if (arrayList instanceof RandomAccess) &#123;
      /**
       *  先判断list是不是RandomAccess的实现类，如果是使用for循环，否则使用迭代器
       */
      int listLength = arrayList.size();
      for (int i = 0; i &lt; listLength; i++) &#123;
      &#125;
  &#125; else &#123;
      Iterator&lt;String&gt; stringIterator = arrayList.iterator();
      while (stringIterator.hasNext()) &#123;
          stringIterator.next();
      &#125;
  &#125;
  
</code></pre>
</li>
<li><p>20、使用同步代码块替代同步方法<br>  除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p>
</li>
<li><p>21、将常量声明为static final，并以大写命名</p>
</li>
<li><p>22、不要创建一些不使用的对象，不要导入一些不使用的类</p>
</li>
<li><p>23、程序运行过程中避免使用反射<br>  将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存</p>
</li>
<li><p>24、使用数据库连接池和线程池</p>
</li>
<li><p>25、使用带缓冲的输入输出流进行IO操作</p>
</li>
<li><p>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList<br>ArrayList从名字上来讲是数组列表，表面上是动态大小，其底层实现原理其实还是一个数组。LinkedList实际上是用双向循环链表实现的。因为ArrayList有索引，所以顺序插入使用ArrayList比较快。中间插入使用LinkedList比较快，因为只需要修改两个引用就可以了。</p>
</li>
<li><p>27、不要让public方法中有太多的形参<br>  形参太多不符合java万物皆对象的理念，多个形参可以封装为一个实体对象。</p>
</li>
<li><p>28、字符串变量和字符串常量equals的时候将字符串常量写在前面<br>避免空指针异常。</p>
</li>
<li><p>29、在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</p>
</li>
<li><p>30、不要对数组使用toString方法<br>数组的toString方法会打印出数组引用对象的地址，有可能产生空指针异常。集合的toString可以打印所有元素，因为它重写了父类的toString方法。</p>
</li>
<li><p>31、不要对超出范围的基本数据类型做向下强制转型<br>超出范围的基本数据强转的1话会导致数据变化，并且很难得到想要的数据。</p>
<pre><code>  Long aLong = 123456789012345L;
  int i = (int) aLong;
  System.out.println(i);
</code></pre>
</li>
<li><p>32、公用的集合类中不使用的数据一定要及时remove掉<br>公用集合（也就是说不是方法里面的属性）中的数据不及时remove掉会有内存泄漏的危险。</p>
</li>
<li><p>33、把一个基本数据类型转为字符串，基本数据类型.toString是最快的方式、String.valueOf次之、数据+””最慢        </p>
<ul>
<li>1、String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断</li>
<li>2、Integer.toString方法就不说了，直接调用了</li>
<li>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符 这个暂时不知道原因，现在也没法得出结论，有大佬知道的可以指点一下。    </li>
</ul>
</li>
<li><p>34、使用最有效率的方式去遍历Map    </p>
<pre><code>  HashMap&lt;String, String&gt; stringStringHashMap = new HashMap&lt;&gt;();
  stringStringHashMap.put(&quot;aaa&quot;, &quot;111&quot;);
  /**
   * 先获取map中各个键值对映射关系的集合，再使用迭代器来遍历这个集合达到遍历map的作用
   * 如果只是想遍历一下这个Map的key值，可以使用 Set keySet = hm.keySet;
   */
  Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = stringStringHashMap.entrySet();
  Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entrySet.iterator();
  while (iterator.hasNext()) &#123;
      Map.Entry&lt;String, String&gt; stringStringEntry = iterator.next();
      System.out.println(stringStringEntry.getKey() + &quot;\t&quot; + stringStringEntry.getValue());
  &#125;
</code></pre>
</li>
<li><p>35、对资源的close建议分开操作<br>这样操作是为了避免一个资源关闭异常导致下一个资源无法关闭的情况。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%9D%82%E9%A1%B9/Maven%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>​    又是工作中遇到了一个Maven的问题，解决了好久都是迷迷糊糊的，这次记录下来防止自己再次忘记。</p>
<h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><p>​    Maven 是一个意第绪语单词，意思是知识的积累，最初是为了简化 Jakarta Turbine 项目中的构建过程。每个项目都有自己的 Ant 构建文件，都略有不同。我们想要一种构建项目的标准方法、对项目组成的清晰定义、一种发布项目信息的简单方法以及一种在多个项目之间共享 JAR 的方法。</p>
<p>​    结果是现在可以用于构建和管理任何基于 Java 的项目的工具。我们希望我们已经创建了一些东西，使 Java 开发人员的日常工作更容易，并且通常有助于理解任何基于 Java 的项目。</p>
<p>​    这个是Maven官网上对于Maven是什么的一个介绍。也可以看出Maven这个工具的用处，就是简单的管理项目依赖的jar包，但是随着Maven的发展，后续也增加了许多有用的功能。想我们使用的话，也就是简单的管理jar包或者依赖。</p>
<h2 id="配置Maven环境"><a href="#配置Maven环境" class="headerlink" title="配置Maven环境"></a>配置Maven环境</h2><p>​     配置Maven环境不是本篇博客的重点，所以不在这里详细的介绍，只是说一下大致的环节。</p>
<p>​     安装Java环境，将Java的安装地址配置到系统的环境变量里面。下载Maven压缩包，解压到你指定的目录，配置Maven的系统环境变量即可。最后修改一下settings文件，修改镜像地址和本地仓库地址即可。</p>
<p>​    执行<code>mvn -version</code>出现以下画面就代表安装成功。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902214851086.png" alt="image-20210902214851086"></p>
<h2 id="简单使用Maven"><a href="#简单使用Maven" class="headerlink" title="简单使用Maven"></a>简单使用Maven</h2><p>​    Maven安装完毕，下面就可以搞一个简单的小Demo，看到成功的画面才有学下去的动力，这个Demo也是官方的例子，具体的地址如下： <a href="https://maven.apache.org/guides/getting-started/Maven-in-five-minutes.html">Maven简单Demo</a></p>
<p>​    在目录下执行如下命令：</p>
<p><code>mvn archetype:generate -DgroupId=com.psq.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false</code></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902215259888.png" alt="image-20210902215259888"></p>
<p>​    这个命令就是依据你选定的原型创建了一个Maven结构的项目，项目名称为<code>my-app</code>。项目的结构如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902215525898.png" alt="image-20210902215525898"></p>
<p>​    可以看到和我们平时的SpringBoot应用相差不多，其实SpringBoot应用也是按照Maven的原型修改了一下。</p>
<p>​    下面执行<code>mvn package</code>，可以看到</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902215723521.png" alt="image-20210902215723521"></p>
<p>​    这里因为我依赖都下载过了，所以很快，第一次执行会稍微慢一些。能够看到项目目录中多了一些东西，多出来的东西就是Maven编译和打包产生的文件，还有一些其他的文件，目前暂时不清楚。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902215910039.png" alt="image-20210902215910039"></p>
<p>​    我们再执行命令<code>java -cp ./target/my-app-1.0-SNAPSHOT.jar com.psq.app.App </code>就能够看到一个输出了。到此，Maven的简单Demo就结束了。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902220047445.png" alt="image-20210902220047445"></p>
<p>​    这个例子完成是不是对于Maven的使用更加的清晰了。下面就介绍一下涉及到的点，当然目前肯定不全，后续遇到其他的知识点也会慢慢补齐。</p>
<h2 id="一些关于Maven的知识点"><a href="#一些关于Maven的知识点" class="headerlink" title="一些关于Maven的知识点"></a>一些关于Maven的知识点</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>​    Maven将构建和分发项目的过程进行了明确的定义，这个就是Maven中的生命周期。一般默认的有以下几种：</p>
<ul>
<li><code>validate</code> 验证项目正确，并获取所有必要信息</li>
<li><code>compile</code>编译项目源代码</li>
<li><code>test</code>使用合适的单元测试框架测试编译后的源代码。这些测试不应要求打包或部署代码</li>
<li><code>package</code> 取编译后的代码，并以可分发格式打包，例如JAR</li>
<li><code>verify</code>对集成测试结果进行任何检查，以确保满足质量标准</li>
<li><code>install</code>将软件包安装到本地存储库中，用于本地其他项目中的依赖项</li>
<li><code>deploy</code>在构建环境中完成，将最终的软件包复制到远程存储库中，以便与其他开发人员和项目共享</li>
</ul>
<p>​    看着是不是特别熟悉，Idea中的Maven也有类似的。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902220700371.png" alt="image-20210902220700371"></p>
<p>​    是不是也知道了Idea中这些按钮的含义。也知道了自己以后应该在什么步骤执行点击什么按钮了吧。</p>
<h3 id="Maven文件结构介绍"><a href="#Maven文件结构介绍" class="headerlink" title="Maven文件结构介绍"></a>Maven文件结构介绍</h3><p>​    这一部分就是Maven对于项目各种文件的一种限制，不一定非要你完全执行，只是一个建议，和我们平时的项目结构差不多，和我上面的截图类似。具体含义如下：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>存放文件类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>src/main/java</code></td>
<td>应用程序代码</td>
</tr>
<tr>
<td><code>src/main/resources</code></td>
<td>资源库资源</td>
</tr>
<tr>
<td><code>src/main/filters</code></td>
<td>资源筛选文件</td>
</tr>
<tr>
<td><code>src/main/webapp</code></td>
<td>网络应用程序资源</td>
</tr>
<tr>
<td><code>src/test/java</code></td>
<td>测试代码</td>
</tr>
<tr>
<td><code>src/test/resources</code></td>
<td>测试需要资源</td>
</tr>
<tr>
<td><code>src/test/filters</code></td>
<td>测试资源筛选文件</td>
</tr>
<tr>
<td><code>src/it</code></td>
<td>集成测试（主要用于插件）</td>
</tr>
<tr>
<td><code>src/assembly</code></td>
<td>汇编描述符</td>
</tr>
<tr>
<td><code>src/site</code></td>
<td>站点</td>
</tr>
<tr>
<td><code>LICENSE.txt</code></td>
<td>项目许可证</td>
</tr>
<tr>
<td><code>NOTICE.txt</code></td>
<td>项目所依赖的库需要的通知和归属</td>
</tr>
<tr>
<td><code>README.txt</code></td>
<td>项目介绍</td>
</tr>
</tbody></table>
<p>​    还有一些文件没有列出来，例如git、svn的文件，但是大致的结构都差不多。现在是不是清楚了为什么GitHub上下载的代码都是一个结构了吧。</p>
<h3 id="原型简单介绍"><a href="#原型简单介绍" class="headerlink" title="原型简单介绍"></a>原型简单介绍</h3><p>​    上面简单Demo中使用到了一个原型，原型就是Maven为了方便我们创建项目而创建的基础项目。我们按照这个原型创建自己的项目。Maven的原型挺多的，当然，我们也可以自己定制自己的原型。</p>
<table>
<thead>
<tr>
<th align="center">原型工件</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Maven-archetype-archetype</td>
<td align="center">生成示例原型项目的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-j2ee-simple</td>
<td align="center">生成简单示例J2EE应用程序的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-mojo</td>
<td align="center">用于生成示例Maven插件示例的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-plugin</td>
<td align="center">生成示例 Maven 插件的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-plugin-site</td>
<td align="center">生成Maven插件站点示例的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-portlet</td>
<td align="center">生成JSR-268 Portlet样本的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-quickstart</td>
<td align="center">生成Maven项目示例的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-simple</td>
<td align="center">生成简单 Maven 项目的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-site</td>
<td align="center">一个原型，用于生成Maven站点示例，演示一些受支持的文档类型，如APT、XDoc和FML，并演示如何i18n您的站点。</td>
</tr>
<tr>
<td align="center">Maven-archetype-site-simple</td>
<td align="center">生成Maven站点样本的原型。</td>
</tr>
<tr>
<td align="center">Maven-archetype-webapp</td>
<td align="center">生成Maven Webapp项目示例的原型。</td>
</tr>
</tbody></table>
<p>​    可以按照自己的需求下载对应的原型，然后进行改造和开发。具体的介绍地址在这里：<a href="https://maven.apache.org/guides/introduction/introduction-to-archetypes.html">Maven原型介绍</a></p>
<h3 id="pom文件介绍"><a href="#pom文件介绍" class="headerlink" title="pom文件介绍"></a>pom文件介绍</h3><p>​    Maven项目最重要的就是Pom文件，但是Pom文件里面的内容实在太多了，我一篇博客很难讲完，这里偷个懒，讲Maven的介绍和参考链接放上来，也算是防止自己忘记吧。还是要说一句，任何的教程和文档都没有官方文档讲的详细。</p>
<p><a href="https://maven.apache.org/pom.html">Maven官方Pom文件参考</a></p>
<p>​    其实我们常用的就是本项目的坐标配置和项目需要的依赖。再顶多配置一下远程仓库、插件。细看这些配置就可以满足日常开发需求了。</p>
<h2 id="开发中常用的功能"><a href="#开发中常用的功能" class="headerlink" title="开发中常用的功能"></a>开发中常用的功能</h2><p>​    最后一个环节介绍一下平时开发中会用到的功能。也算比较常见吧。</p>
<h3 id="配置私服地址-从私服下载依赖"><a href="#配置私服地址-从私服下载依赖" class="headerlink" title="配置私服地址,从私服下载依赖"></a>配置私服地址,从私服下载依赖</h3><p>​    大部分公司都搭建了私服，也就是边缘端端中心仓库。你的项目要想从这些仓库下载地址也很简单，有以下办法。</p>
<ul>
<li>修改你的Maven的配置文件settings.xml,如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>myprofile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>your custom repo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jarsm2.dyndns.dk<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>myprofile<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改你的项目文件（会覆盖上一步的配置，所以是常用做法）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>your custom repo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jarsm2.dyndns.dk<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>your custom repo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jarsm2.dyndns.dk<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="pom中增加构建配置"><a href="#pom中增加构建配置" class="headerlink" title="pom中增加构建配置"></a>pom中增加构建配置</h3><p>​    通过配置profiles标签，来达到选定打包文件的操作，idea中的显示也比较方便，如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210902223704130.png" alt="image-20210902223704130"></p>
<p>​    具体的代码看自己项目定。    </p>
<h3 id="上传jar包到私服"><a href="#上传jar包到私服" class="headerlink" title="上传jar包到私服"></a>上传jar包到私服</h3><p>​    这个步骤也是简单，首先在项目增加配置，你要上传的仓库的地址。再在你的Maven全局配置文件里面配置私服的用户名和地址，也可以配置其他验证方式。配置完成后，执行deploy命令即可。这里就不再详细的展示步骤了，不清楚的可以看看官网的介绍。</p>
<p><a href="https://maven.apache.org/guides/getting-started/index.html#How_do_I_deploy_my_jar_in_my_remote_repository">部署到远程仓库</a></p>
<p>​    但是需要注意，开发版本和稳定版本是有区别的，有时某些远程仓库是只能上传开发版本的，有些是只能上传稳定版本的。需要你上传时注意。</p>
<h3 id="打包到本地仓库"><a href="#打包到本地仓库" class="headerlink" title="打包到本地仓库"></a>打包到本地仓库</h3><p>​    这个就更加简单了，就是本地install命令即可，在仓库中寻找对应目录的jar即可。我这里也不演示了。</p>
<p>​    至此，Maven的介绍和一些我能想到的点就全部介绍完毕了。后续有机会还是会继续更新的。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%9D%82%E9%A1%B9/RESTful%E9%A3%8E%E6%A0%BC%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="RESTful风格了解"><a href="#RESTful风格了解" class="headerlink" title="RESTful风格了解"></a>RESTful风格了解</h2><p>​    又一次工作中要求接口的形式需要按照RESTful风格，由于第一次听到这个名词，所以来了解一下。</p>
<p>​    RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。</p>
<p>​    其实RESTful不是一个新技术，是原有的技术添加了一些规则或者重新定义了使用方法。下面就介绍RESTful风格的重要的一些概念。</p>
<p>​    RESTful的特点。（来自百度百科）</p>
<ul>
<li>每一个URI代表1种资源；</li>
<li>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li>
<li>通过操作资源的表现形式来操作资源；</li>
<li>资源的表现形式是XML或者HTML；</li>
<li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li>
</ul>
<p>​    其实看到这里就发现了RESTful并没有添加了什么新的概念，只是将所有的操作定义为对资源的操作。它的优点也显而易见，<em>扩展性强、结构清晰</em>。但是缺点也是有的，当项目很小，使用这种风格就显得没有必要甚至比较繁琐。剩下就没有什么需要说的了，然后就是列出一下比较好的例子。</p>
<ul>
<li>从账户a转账到账户b里面100元</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /accounts/a/transfer/100/to/b</span><br></pre></td></tr></table></figure>

<p>可以修改为这样。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /transaction HTTP/1.1</span><br><span class="line">from=a&amp;to=b&amp;money=100</span><br></pre></td></tr></table></figure>

<p>​    需要注意的地方（这个东西感觉还是使用过程中慢慢去了解，后面也会慢慢补充）：</p>
<ul>
<li>版本号应该是放在HTTP请求头信息的Accept字段中，而不是放在URL中。</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%9D%82%E9%A1%B9/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="代码整洁记录"><a href="#代码整洁记录" class="headerlink" title="代码整洁记录"></a>代码整洁记录</h2><h3 id="对于命名的规定"><a href="#对于命名的规定" class="headerlink" title="对于命名的规定"></a>对于命名的规定</h3><ul>
<li>对于变量和方法的名称，应该尽量降低这些名称的模糊度。<code>gameBoad</code>要比<code>theList</code>好的太多</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201126140253927.png" alt="image-20201126140253927"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201126140333426.png" alt="image-20201126140333426"></p>
<ul>
<li>要使起的名称有意义，减少名称中的废话，例如<code>nameString</code>,<code>getActiveAccount()</code>,<code>getActiveAccountInof()</code>.</li>
<li>使用正确的单词或者名称，不要自己造一些只有自己能够理解的单词或者名称。例如:<code>genymdhms</code>.</li>
<li>是自己的名称能够文件中直接搜索到，不要搜索变量名时出来大量不符合的匹配项，长名称要比短名称好）（不废话的名称）<code>e</code>就是个错误示例。</li>
<li>不要在代码中做思维映射，即使阅读的人知道这段代码的意思。例如<code>for(int i = o;i&lt;sum;i++)</code>有些情况可以使用，但是会导致阅读代码的人做无谓的思维映射。</li>
<li>类的名称最好为名词或者名词短语，方法名最好为动词或者动词短语。</li>
<li>同一个概念最好用同一个词，例如获取就用<code>get</code>,不要多个词语表达同一个概念。</li>
</ul>
<h3 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h3><ul>
<li>函数应该尽可能的短小，越短越好。</li>
<li>if、else、while里面的代码块应该只有一行，就是函数的调用，这样不仅可以使代码更加清晰也可以使函数保持短小。</li>
<li>函数应该就只做一件事，做好这件事就可以了。该函数只做与该函数名同一层级下的抽象层的步骤，比较绕口，简单举个例子。</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%9D%82%E9%A1%B9/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="字符语法"><a href="#字符语法" class="headerlink" title="字符语法"></a>字符语法</h3><ul>
<li><code>[ABC]</code>：匹配括号内的字符。例如： <strong>[aeiou]</strong> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</li>
<li><code>[^ABC]</code>：匹配除括号内的字符。例如： <strong>[^aeiou]</strong> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</li>
<li><code>[A-Z]</code>：匹配A到Z的所有字符。例如：<code>[a-z]</code>匹配所有的小写字母。</li>
<li><code>.</code>:匹配除换行符（\n、\r）之外的任何单个字符。</li>
<li><code>[\s\S]</code>:匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</li>
<li><code>\w</code>:匹配字母、数字、下划线。等价于 [A-Za-z0-9_]。</li>
</ul>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210528211629833.png" alt="image-20210528211629833"></p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>匹配特殊字符时需要在前面添加转义字符\，即 <strong>runo*ob</strong> 匹配字符串 <strong>runo*ob</strong>。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210528211942426.png" alt="image-20210528211942426"></p>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>​    各种符号之间有重复，但是意思没有歧义。</p>
<p>​    限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。限定符出现在范围表达式之后，因此，它应用于整个范围表达式，就是应用于前面的范围表达式。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210528212220698.png" alt="image-20210528212220698"></p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>​    定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210528214324071.png" alt="image-20210528214324071"></p>
<h3 id="选择（了解）"><a href="#选择（了解）" class="headerlink" title="选择（了解）"></a>选择（了解）</h3><p>​    用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p>
<p>​    <strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p>
<p>​    对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>​    标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。一般是在正则表达式的两侧。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210529151941439.png" alt="image-20210529151941439"></p>
<p><code>^[-]?[0-9]?[0-9]*(\.[0-9]+)?$</code>匹配浮点数（不是很完善，其实有一部分的漏洞）</p>
<p>匹配邮箱正则表达式的解析</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210529155625846.png" alt="image-20210529155625846"></p>
<h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><ul>
<li>[]里面的似乎不需要转义字符。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Mybatis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h3><p>​    对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
<p>​    MySQL中存储的是关系型数据，但是项目中使用的是对象型数据。ORM框架就是这两种数据的中间层，将两种数据进行转换。这也是它要做的事。</p>
<h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><p>​    Hibernate 框架是一个全表映射的框架。通常开发者只要定义好持久化对象到数据库表的映射关系，就可以通过 Hibernate 框架提供的方法完成持久层操作。</p>
<p>​    相较于MyBatis，Hibernate是全自动的ORM框架，有它的优点：开发效率快，不需要开发人员懂SQL。但是也有着缺点：对于多表联合复杂查询支持较差，很难对SQL进行优化，更新的时候需要传全部的字段。</p>
<h4 id="MyBatis-1"><a href="#MyBatis-1" class="headerlink" title="MyBatis"></a>MyBatis</h4><p>​    MyBatis 框架是一个半自动映射的框架。这里所谓的“半自动”是相对于 Hibernate 框架全表映射而言的，MyBatis 框架需要手动匹配提供 POJO、SQL 和映射关系，而 Hibernate 框架只需提供 POJO 和映射关系即可。</p>
<p>​    缺点：需要写SQL，开发效率相对于Hibernate较慢。对于互联网来说，SQL的执行效率需要优化，同时查询的复杂度也比较高。MyBatis就成了互联网行业比较好的选择。</p>
<h3 id="Spring连接JDBC的基本步骤"><a href="#Spring连接JDBC的基本步骤" class="headerlink" title="Spring连接JDBC的基本步骤"></a>Spring连接JDBC的基本步骤</h3><p>​    因为JDBC是面向接口编程，所以很多的驱动厂商已经写好了。只需要加载对应的驱动，就可以获取对应的数据库连接。Sping中是通过DataSource来获取数据库连接的。但是spring没有局限于此，又提供了JdbcTemplate这么一个类给我们使用！它封装了DataSource，也就是说我们可以在Dao中使用JdbcTemplate就行了。JdbcTemplate返回的是map，它并不知道我们需要的是什么类型的数据。</p>
<h3 id="MyBatis流程"><a href="#MyBatis流程" class="headerlink" title="MyBatis流程"></a>MyBatis流程</h3><p>​    工作原理图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210622110302194.png" alt="image-20210622110302194"></p>
<p>​    读取mybatisxml配置文件，读取数据库信息和mybatis设置信息。然后再读取映射xml文件。再通过Configuration对象构建SqlSessionFactory，再通过SqlSessionFactory创建SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。需要查询时，通过Executor 执行器，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。从数据库中查询出数据后，再通过MappedStatement对象将数据进行封装，该对象是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。    </p>
<ul>
<li>建造者模式是日常开发中比较常见的设计模式，它的主要作用就是将复杂事物创建的过程抽象出来，该抽象的不同实现方式不同，创建出的对象也不同。通俗的讲，创建一个对象一般都会有一个固定的步骤，这个固定的步骤我们把它抽象出来，每个抽象步骤都会有不同的实现方式，不同的实现方式创建出的对象也将不同。</li>
</ul>
<h3 id="Mybatis中的执行器（Executor）"><a href="#Mybatis中的执行器（Executor）" class="headerlink" title="Mybatis中的执行器（Executor）"></a>Mybatis中的执行器（Executor）</h3><p>​    Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<ul>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>
</ul>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>​    延迟加载就是在查询一对多关系时，延迟加载一所对应的表中的信息，只有在需要一的信息时，才回去执行SQL查询一的信息。</p>
<p>​    它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<h3 id="Mybatis如何将xml文件映射为对象"><a href="#Mybatis如何将xml文件映射为对象" class="headerlink" title="Mybatis如何将xml文件映射为对象"></a>Mybatis如何将xml文件映射为对象</h3><p>​    通过mybatis的配置信息生成一个Configuration实例，然后Configuration实例读取mapper文件，来源分为xml文件和java注解。将SQL信息解析为MappedStatement对象，这个对象包含了传入参数映射配置、执行的SQL语句、结果映射配置。用户如果想要调用一条请求时，Mybatis会根据SQL的ID找到对应的MappedStatement对象，然后将请求的参数传入，得到解析后的SQL，拿着这条SQL在数据库中执行，得到结果后，将结果按照配置的映射关系转换，转换成java对象，完成一次请求。</p>
<p>​    Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h3 id="和-的区别，和原理"><a href="#和-的区别，和原理" class="headerlink" title="#和$的区别，和原理"></a>#和$的区别，和原理</h3><p>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</p>
<p>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p>
<p>Mybatis在处理${}时，是原值传入，就是把${}替换成变量的值，相当于JDBC中的Statement编译。</p>
<p>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</p>
<h3 id="Mybatis中的一级缓存和二级缓存"><a href="#Mybatis中的一级缓存和二级缓存" class="headerlink" title="Mybatis中的一级缓存和二级缓存"></a>Mybatis中的一级缓存和二级缓存</h3><p>​    每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。</p>
<p>默认的是一级缓存，通过设置Mybatis的配置文件即可。共有两个选项，<code>SESSION</code>或者<code>STATEMENT</code>，默认是<code>SESSION</code>级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是<code>STATEMENT</code>级别，可以理解为缓存只对当前执行的这一个<code>Statement</code>有效。建议配置成STATEMENT级别。</p>
<p>​    在同一个方法里面，两个不同的SqlSession分别执行查询和修改，可能会造成脏读的情况。</p>
<p>注意：</p>
<ul>
<li>MyBatis一级缓存的生命周期和SqlSession一致。</li>
<li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li>
</ul>
<p>​    如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p>
<p>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<p>注意：</p>
<ul>
<li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ul>
<h3 id="Mybatis的核心组件"><a href="#Mybatis的核心组件" class="headerlink" title="Mybatis的核心组件"></a>Mybatis的核心组件</h3><h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>​    SqlSessionFactory是一个接口，主要的作用就是初始化Mybatis框架和提供SqlSession对象。实现类主要有两个：一个是 SqlSessionManager 类，一个是 DefaultSqlSessionFactory 类。</p>
<ul>
<li>DefaultSqlSessionFactory : SqlSessionFactory 的默认实现类，是真正生产会话的工厂类，这个类的实例的生命周期是全局的，它只会在首次调用时生成一个实例（单例模式），就一直存在直到服务器关闭。</li>
<li>SqlSessionManager ： 已被废弃，原因大概是: SqlSessionManager 中需要维护一个自己的线程池，而使用MyBatis 更多的是要与 Spring 进行集成，并不会单独使用，所以维护自己的 ThreadLocal 并没有什么意义，所以 SqlSessionManager 已经不再使用。</li>
</ul>
<p>​    流程就是：SqlSessionFactoryBuilder根据Mybatis配置的xml文件通过建造者模式的设计思想构建一个SqlSessionFactory对象。解析完成后返回一个 <code>DefaultSqlSessionFactory</code>对象，它是 SqlSessionFactory 的默认实现类。</p>
<h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>​    SqlSessionFactory.openSession 过程中我们可以看到，会调用到 DefaultSqlSessionFactory 中的 openSessionFromDataSource 方法，这个方法主要创建了两个与我们分析执行流程重要的对象，一个是 Executor 执行器对象，一个是 SqlSession 对象。</p>
<p>​    SqlSession 对象是 MyBatis 中最重要的一个对象，这个接口能够让你执行命令，获取映射，管理事务。SqlSession 中定义了一系列模版方法，让你能够执行简单的 CRUD 操作，也可以通过 getMapper 获取 Mapper 层，执行自定义 SQL 语句，因为 SqlSession 在执行 SQL 语句之前是需要先开启一个会话，涉及到事务操作，所以还会有 commit、 rollback、close 等方法。这也是模版设计模式的一种应用。</p>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>​    每一个 SqlSession 都会拥有一个 Executor 对象，这个对象负责增删改查的具体操作，我们可以简单的将它理解为 JDBC 中 Statement 的封装版。 也可以理解为 SQL 的执行引擎，要干活总得有一个发起人吧，可以把 Executor 理解为发起人的角色。</p>
<p>​    Executor 执行器，它有两个实现类，分别是BaseExecutor和 CachingExecutor。</p>
<h4 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h4><p>​    <code>StatementHandler</code> 是四大组件中最重要的一个对象，负责操作 Statement 对象与数据库进行交互，在工作时还会使用 <code>ParameterHandler</code> 和 <code>ResultSetHandler</code>对参数进行映射，对结果进行实体类的绑定。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>//ORM框架</p>
<p>//Spring连接JDBC的过程和步骤</p>
<p>//MyBatis如何将xml映射为对象</p>
<p>//statement是什么</p>
<p>​    Statement对象表示一个原始语句，其中将单个方法应用于目标和一组参数</p>
<p>//#和$的区别，和原理</p>
<p>//延迟加载</p>
<p>//一级缓存和二级缓存</p>
<p>//Mybatis的四个核心组件</p>
<p>//Mybatis中的执行器（Executor）</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h3><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="计算机网络层次"><a href="#计算机网络层次" class="headerlink" title="计算机网络层次"></a>计算机网络层次</h4><p>​    现在市面上大概有三种网络体系结构。</p>
<ul>
<li>OSI的七层协议体系结构，包含：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层。但是因为太过于理论，所以没有得到广泛应用。</li>
<li>TCP/IP体系结构，包含:应用层、运输层、网际层、网络接口层。该理论得到了广泛的应用。</li>
<li>五层协议体系结构，包含：应用层、运输层、网络层、数据链路层、物理层。是将上面两种体系结合起来的一种结构，学习起来比较适合。</li>
</ul>
<p>应用层：应用层是直接为用户的进程提供服务。该层的协议也比较多：HTTP、FTP、SMTP等</p>
<p>运输层：运输层的任务就是负责向两个主机中的进程提供通信服务。分为分用（分别交付信息）和复用（多个进程同时使用服务）。协议有：TCP、UDP</p>
<p>网络层：网络层负责为交换网上的主机提供通信服务。协议为IP协议。</p>
<p>数据链路层：数据链路层将网络层交下来的数据报组装成帧，在两个相邻的节点间的链路上透明的传输帧，帧中包含数据和必要的控制信息。（两个相邻的节点例如两个路由器）</p>
<p>物理层：物理层的任务就是透明的传输比特（就是0和1）。</p>
<h4 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><ul>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ul>
<p>为什么要再发送最后一次报文？一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><ul>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2 ∗ * ∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ul>
<p>为什么客户端最后还要等待2MSL？</p>
<p>​    第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。</p>
<p>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<p>​    三次握手是客户端主动连接，服务端可以将syn和ack放在一起发送出去。但是断开链接时，服务端这时可能还会有数据继续发送，所以会将ack和syn分别发送，所以就多了一次。</p>
<h4 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h4><p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<p>不同点：</p>
<p>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。<br>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。<br>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。<br>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。<br>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</p>
<h4 id="HTTP相关知识点"><a href="#HTTP相关知识点" class="headerlink" title="HTTP相关知识点"></a>HTTP相关知识点</h4><h5 id="HTTP中的方法"><a href="#HTTP中的方法" class="headerlink" title="HTTP中的方法"></a>HTTP中的方法</h5><ul>
<li>GET ：获取资源” “GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。”</li>
<li>“POST：传输实体主体” “POST 方法用来传输实体的主体。”</li>
<li>PUT：传输文件 “PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。”</li>
<li>“HEAD：获得报文首部” “HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。”</li>
<li>DELETE：删除文件 “DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。”</li>
<li>“OPTIONS：询问支持的方法” “OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。”</li>
<li>TRACE：追踪路径 “TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。”</li>
<li>“CONNECT：要求用隧道协议连接代理” “CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。”</li>
</ul>
<h5 id="报文首部结构"><a href="#报文首部结构" class="headerlink" title="报文首部结构"></a>报文首部结构</h5><ul>
<li>“请求行 包含用于请求的方法，请求 URI 和 HTTP 版本。</li>
<li>状态行 包含表明响应结果的状态码，原因短语和 HTTP 版本。</li>
<li>首部字段 包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li>
<li>其他 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。”</li>
</ul>
<h3 id="Linux面试相关点"><a href="#Linux面试相关点" class="headerlink" title="Linux面试相关点"></a>Linux面试相关点</h3><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>示例：列出所有文件：ls -a</p>
<p>列出当前目录中所有以”t”开头的目录的详细内容: ls -l t*</p>
<h4 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h4><p>示例：进入上一次工作路径：cd -</p>
<h4 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h4><p>示例：查看当前路径： pwd</p>
<h4 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h4><p>示例：在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建：mkdir -p /tmp/test/t1/t</p>
<h4 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h4><p>cat 主要有三大功能：1.一次显示整个文件:2.从键盘创建一个文件:3.将几个文件合并为一个文件:</p>
<p>示例：把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat -n log2012.log log2013.log</span><br></pre></td></tr></table></figure>

<h4 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h4><p>功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p>
<h4 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h4><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>
<h4 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h4><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>
<p>示例：显示 1.log 文件前 20 字节：head -c 20 log2014.log</p>
<h4 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h4><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>
<p>示例：循环读取逐渐增加的文件内容：tail -f ping.log</p>
<h4 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h4><p>which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p>示例：查看 ls 命令是否存在，执行哪个：which ls</p>
<h4 id="whereis-命令"><a href="#whereis-命令" class="headerlink" title="whereis 命令"></a>whereis 命令</h4><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。</p>
<h4 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h4><p>locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。</p>
<p>示例：查找和 pwd 相关的所有文件(文件名中包含 pwd）：locate pwd</p>
<h4 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h4><p>用于在文件树中查找文件，并作出相应的处理。</p>
<p>示例：在当前目录查找 以 .log 结尾的文件。 <strong>.</strong> 代表当前目录：find ./ -name ‘*.log’</p>
<h4 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h4><p>用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p>
<p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。</p>
<p>示例：增加文件 t.log 所有用户可执行权限：chmod a+x t.log</p>
<h4 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h4><p>显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。</p>
<p>示例：显示磁盘使用情况:df -l</p>
<h4 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h4><p>du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：</p>
<p>示例：以易读方式显示文件夹内及子文件夹大小：du -h scf/</p>
<h4 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h4><p>强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。</p>
<p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p>
<p>示例：查找指定进程：ps -ef | grep svn</p>
<h4 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h4><p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top</p>
<p>示例：显示当前所有进程环境变量及进程间关系：ps -ef</p>
<h4 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h4><p>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</p>
<h4 id="Kill命令"><a href="#Kill命令" class="headerlink" title="Kill命令"></a>Kill命令</h4><p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p>
<p>示例：先使用ps查找进程pro1，然后用kill杀掉：kill -9 $(ps -ef | grep pro1)</p>
<h4 id="free-命令"><a href="#free-命令" class="headerlink" title="free 命令"></a>free 命令</h4><p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p>
<p>示例：显示内存使用情况：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">free</span><br><span class="line">free -k</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>如何查看端口号被哪个进程占用</p>
<p>lsof -i:端口号</p>
<p>netstat -tunpl | grep 端口号</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E6%8D%AE%E4%BD%8D%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="计算机数据位学习"><a href="#计算机数据位学习" class="headerlink" title="计算机数据位学习"></a>计算机数据位学习</h2><ul>
<li><p>位：计算机存储和处理的信以二进制信号表示，这些二进制称为<code>位</code></p>
</li>
<li><p>三种数字表示。</p>
<ul>
<li>无符号：基于传统的二进制表示法，表示大于或者等于零的数字。</li>
<li>补码：补码编码是最常见的表示有符号的方式，表示为正或者为负的数字。</li>
<li>浮点数：浮点数编码是表示实数的科学记数法以二为基数的版本。</li>
</ul>
</li>
<li><p>大多数计算机使用8位的块，或者字节（byte）作为最小的可寻址的存储器单位，而不是存储器中的访问单独的位。</p>
</li>
<li><p>0x或者0X开头的数字一般表示十六进制的数字。</p>
</li>
<li><p>一个汉字=2字节（2byte）一个字节(1byte)=8位（8bit）1KB=1024Byte</p>
</li>
<li><p>byte是java的<strong>基本数据类型</strong>，存储整型数据，占据1个字节(8 bits)，能够存储的数据范围是-128～+127。</p>
<p>Byte是java.lang中的一个类，目的是为基本数据类型byte进行封装。</p>
</li>
</ul>
<p><em>在工作中遇到的数据的问题，也是就这个问题记录了一下，后面感觉计算机网络和计算机基础还是非常重要的，后面也会对这些知识慢慢补充。</em></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><ul>
<li><p>目前流行的计算机网络的各层及其协议的集合（网络的体系结构）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_0E4AB3775BF4-1.jpeg" alt="IMG_0E4AB3775BF4-1"></p>
<p>应用层：体系结构中最高层。</p>
<p>运输层：负责向两个主机中进程之间的通信提供服务。主要使用了TCP和UDP协议。</p>
<p>网络层：使用分组交换负责为网上不同的主机提供通信服务。</p>
<p>数据链路层：将网络层的数据组装成帧，在两个相邻节点之间传送数据。</p>
<p>物理层：负责透明的传送比特流。</p>
</li>
<li><p>当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。<code>SOH</code>开始帧、<code>EOT</code>结束帧。如果传输的数据存在帧定界符，通过转义字符<code>ESC</code>来区分数据和帧定界符。</p>
</li>
<li><p>循环冗余检验原理。<br><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_058CB781B01A-1.jpeg" alt="IMG_058CB781B01A-1"></p>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="ElasticSearch相关知识点"><a href="#ElasticSearch相关知识点" class="headerlink" title="ElasticSearch相关知识点"></a>ElasticSearch相关知识点</h2><h3 id="ES基础知识点"><a href="#ES基础知识点" class="headerlink" title="ES基础知识点"></a>ES基础知识点</h3><p>​    ES集群可以包含多个索引（indices）(数据库)，每一个索引可以包含多个类型（types）（表），每一个类型包含多个文档（documents）（行），然后每个文档包含多个字段（fields）（列）。</p>
<h4 id="索引（Index）"><a href="#索引（Index）" class="headerlink" title="索引（Index）"></a>索引（Index）</h4><p>​    索引是文档(Document)的容器，是一类文档的集合。在ES中有三种索引的概念，意思分别为：</p>
<ul>
<li>索引(名词)。类比传统的关系型数据库领域来说，索引相当于SQL中的一个数据库(Database)。索引由其名称(必须为全小写字符)进行标识。</li>
<li>索引(动词)。保存一个文档到索引(名词)的过程。这非常类似于SQL语句中的 INSERT关键词。如果该文档已存在时那就相当于数据库的UPDATE。</li>
<li>倒排索引。关系型数据库通过增加一个B+树索引到指定的列上，以便提升数据检索速度。索引ElasticSearch 使用了一个叫做 倒排索引 的结构来达到相同的目的。</li>
</ul>
<h4 id="类型（Type）"><a href="#类型（Type）" class="headerlink" title="类型（Type）"></a>类型（Type）</h4><p>​    Type 可以理解成关系数据库中Table。</p>
<p>​    之前的版本中，索引和文档中间还有个类型的概念，每个索引下可以建立多个类型，文档存储时需要指定index和type。从6.0.0开始单个索引中只能有一个类型，7.0.0以后将将不建议使用，8.0.0 以后完全不支持。但是后续的版本弃用了，原因如下：</p>
<p>​    我们虽然可以通俗的去理解Index比作 SQL 的 Database，Type比作SQL的Table。但这并不准确，因为如果在SQL中,Table 之前相互独立，同名的字段在两个表中毫无关系。但是在ES中，同一个Index 下不同的 Type 如果有同名的字段，他们会被 Luecence 当作同一个字段 ，并且他们的定义必须相同。所以我觉得Index现在更像一个表，而Type字段并没有多少意义。目前Type已经被Deprecated，在7.0开始，一个索引只能建一个Type为_doc</p>
<h4 id="文档（Document）"><a href="#文档（Document）" class="headerlink" title="文档（Document）"></a>文档（Document）</h4><p>​    Document Index 里面单条的记录称为Document（文档）。等同于关系型数据库表中的行。</p>
<h4 id="映射（Mapping）"><a href="#映射（Mapping）" class="headerlink" title="映射（Mapping）"></a>映射（Mapping）</h4><p>​    映射(Mapping)相当于数据表的表结构。ElasticSearch中的映射（Mapping）用来定义一个文档，可以定义所包含的字段以及字段的类型、分词器及属性等等。</p>
<p>​    映射定义了类型中的域，每个域的数据类型，以及Elasticsearch如何处理这些域。映射也用于配置与类型有关的元数据。（元数据就是指和文档相关的数据，例如：文档的id、文档的index、文档的版本号）</p>
<p>​    映射创建完毕后就不能修改了，只能后续增加映射，不能修改已经存在的映射。映射也分为动态和静态。动态就是根据传入的json的类型去猜测映射的类型，例如“123”回被当为String。静态映射是在创建index时指定映射。</p>
<h4 id="字段（fields）"><a href="#字段（fields）" class="headerlink" title="字段（fields）"></a>字段（fields）</h4><p>​    代表传统DB中的列的概念，例如学生表中的name列，一般映射也是对字段进行限制。</p>
<h4 id="分片（Shard）"><a href="#分片（Shard）" class="headerlink" title="分片（Shard）"></a>分片（Shard）</h4><p>​    一个分片是一个底层的工作单元 ，它仅保存了全部数据中的一部分。索引实际上是指向一个或者多个物理分片的逻辑命名空间 。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。分片分为主分片和副本。</p>
<ul>
<li>主分片：主要的数据存储分片，也是和用户打交道的主要分片。</li>
<li>副本：主要对主分片的数据做冗余备份。当主分片异常时，副本可以继续提供读访问。</li>
</ul>
<p>注意：一个index可能存在多个主分片上。主分片数量在创建时指定后就不能修改了，但是副本的数量可以修改。主分片不能和本分片的副本在同一个节点上。</p>
<h4 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h4><p>​    节点是一个ElasticSearch的实例，其本质就是一个Java进程；Node 是组成集群的一个单独的服务器，用于存储数据并提供集群的搜索和索引功能。与集群一样，节点也有一个唯一名字，默认在节点启动时会生成一个uuid作为节点名，该名字也可以手动指定。单个集群可以由任意数量的节点组成。如果只启动了一个节点，则会形成一个单节点的集群。一台机器可以部署多个节点，但是建议一台机器部署一个节点。</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>​    Elasticsearch 使用一种称为倒排索引的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。文档列表里面存储该词出现的文档和文档中该词出现的频率。</p>
<p>​    倒排索引就是将文档中出现的不重复的词语建立一个列表，然后对于各个文档，标注出该词语在文档中出现的次数。第一列是不重复词语，第一行是各个文档的id或者名称。表格中间填写的就是各个文档中各个词语出现的次数。</p>
<p>​    正排索引就是像MySQL这样类似，根据id查询该行的信息。倒排就是根据信息查询id。</p>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>​    分析器就是从一串文本中切分出一个一个的词条，并対每个词条进行标准化。分析器实际上是将三个功能封装到了一个包里</p>
<ul>
<li>字符过滤器：首先，字符串按顺序通过每个字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 and。</li>
<li>分词器：其次，字符串被分词器分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</li>
<li>Token 过滤器：最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。</li>
</ul>
<p>​    内置的分析器有一下几种：</p>
<ul>
<li>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。</li>
<li>简单分析器在任何不是字母的地方分隔文本，将词条小写。</li>
<li>空格分析器在空格的地方划分文本。</li>
<li>特定语言分析器可用于很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的词干。</li>
</ul>
<h3 id="ES中相关原理"><a href="#ES中相关原理" class="headerlink" title="ES中相关原理"></a>ES中相关原理</h3><h4 id="如何索引到文档"><a href="#如何索引到文档" class="headerlink" title="如何索引到文档"></a>如何索引到文档</h4><p>​    当索引一个文档的时候，文档会被存储到一个主分片中。这个时候是通过计算得到该文档所在的分片的。通过以下公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure>

<p>​    routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。这也就是为什么不能修改主分片的数量，如果修改了，后续的索引就无法找到对应的分片，之前的存放的文档也会有影响。</p>
<h4 id="搜索的过程"><a href="#搜索的过程" class="headerlink" title="搜索的过程"></a>搜索的过程</h4><p>​    先说普通的CURD操作，因为CURD一般都带有三个属性：_index, _type, 和 routing values ，基本可以确定集群中的那个分片处理这个请求。</p>
<p>​    但是搜索比较复杂一些。主要分为查询阶段和取回阶段。</p>
<h5 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h5><p>​    当一个搜索请求被发送到某个节点时，这个节点就变成了协调节点。 这个节点的任务是广播查询请求到所有相关分片并将它们的响应整合成全局排序后的结果集合，这个结果集合会返回给客户端。</p>
<p>​    第一步是广播请求到索引中每一个节点的分片拷贝。就像 document GET requests 所描述的， 查询请求可以被某个主分片或某个副本分片处理， 这就是为什么更多的副本（当结合更多的硬件）能够增加搜索吞吐率。 协调节点将在之后的请求中轮询所有的分片拷贝来分摊负载。</p>
<p>​    每个分片在本地执行查询请求并且创建一个长度为 from + size 的优先队列—也就是说，每个分片创建的结果集足够大，均可以满足全局的搜索请求。 分片返回一个轻量级的结果列表到协调节点，它仅包含文档 ID 集合以及任何排序需要用到的值，例如 _score 。</p>
<p>​    协调节点将这些分片级的结果合并到自己的有序优先队列里，它代表了全局排序结果集合。至此查询过程结束。</p>
<h5 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h5><p>​    协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { “from”: 90, “size”: 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。</p>
<p>​    协调节点给持有相关文档的每个分片创建一个 multi-get request ，并发送请求给同样处理查询阶段的分片副本。</p>
<p>​    分片加载文档体– _source 字段—如果有需要，用元数据和 search snippet highlighting 丰富结果文档。 一旦协调节点接收到所有的结果文档，它就组装这些结果为单个响应返回给客户端。</p>
<ul>
<li><p>想象一下有两个文档有同样值的时间戳字段，搜索结果用 timestamp 字段来排序。 由于搜索请求是在所有有效的分片副本间轮询的，那就有可能发生主分片处理请求时，这两个文档是一种顺序， 而副本分片处理请求时又是另一种顺序。</p>
<p>这就是所谓的结果震荡问题: 每次用户刷新页面，搜索结果表现是不同的顺序。 让同一个用户始终使用同一个分片，这样可以避免这种问题， 可以设置 preference 参数（偏好参数选定对应的节点）为一个特定的任意值比如用户会话ID来解决。</p>
</li>
</ul>
<h4 id="节点故障后选举的流程"><a href="#节点故障后选举的流程" class="headerlink" title="节点故障后选举的流程"></a>节点故障后选举的流程</h4><p>​    Elasticsearch在满足如下时间点的时候会触发选举1.集群启动初始化2.集群的Master崩溃的时候3.任何一个节点发现当前集群中的Master节点没有得到n/2 + 1节点认可的时候，触发选举。</p>
<p>​    选举的流程：</p>
<p><img src="https://pic2.zhimg.com/v2-7c4b590346650f5e32088458da5df48d_r.jpg" alt="preview"></p>
<p>​    详细看文章：<a href="https://zhuanlan.zhihu.com/p/110079342">https://zhuanlan.zhihu.com/p/110079342</a></p>
<p>​    <a href="https://zhuanlan.zhihu.com/p/281021501">https://zhuanlan.zhihu.com/p/281021501</a></p>
<h4 id="处理冲突的流程"><a href="#处理冲突的流程" class="headerlink" title="处理冲突的流程"></a>处理冲突的流程</h4><p>​    每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p>
<p>​    我们可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。</p>
<p>也可以通过外部版本号：</p>
<p>如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp — 那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号， 版本号必须是大于零的整数， 且小于 9.2E+18 — 一个 Java 中 long 类型的正值。</p>
<p>外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前 _version 是否 小于 指定的版本号。 如果请求成功，外部的版本号作为文档的新 _version 进行存储。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="POSTMAN练习"><a href="#POSTMAN练习" class="headerlink" title="POSTMAN练习"></a>POSTMAN练习</h4><ul>
<li>PUT /index/type/id {body} 添加一个文档。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request PUT &#x27;http://127.0.0.1:9200/megacorp/employee/4&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;first_name&quot; : &quot;Li&quot;,</span><br><span class="line">    &quot;last_name&quot; :  &quot;Si&quot;,</span><br><span class="line">    &quot;age&quot; :        26,</span><br><span class="line">    &quot;about&quot; :      &quot;I love to sleep&quot;,</span><br><span class="line">    &quot;interests&quot;: [ &quot;bed&quot;, &quot;work&quot; ]</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>GET /megacorp/employee/1 查询一个id为1的文档。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request GET &#x27;http://127.0.0.1:9200/megacrop/employee/1&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;from&quot;:2,</span><br><span class="line">    &quot;size&quot;:1</span><br><span class="line">&#125; &#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>GET /megacorp/employee/_search    搜索文档。可以添加相关的json来限制查询条件</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request GET &#x27;http://127.0.0.1:9200/megacrop/employee/_search&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;last_name&quot; : &quot;Smith&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>HEAD /megacorp/employee/123 查询文档是否存在。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --head &#x27;http://127.0.0.1:9200/megacrop/employee/23&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>PUT /website/blog/123/_create    如果ID不存在创建新文档</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request PUT &#x27;http://127.0.0.1:9200/website/blog/123/_create&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">  &quot;text&quot;:  &quot;I am starting to get the hang of this...&quot;,</span><br><span class="line">  &quot;date&quot;:  &quot;2014/01/02&quot;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>DELETE /website/blog/123    删除文档</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request DELETE &#x27;http://127.0.0.1:9200/website/blog/123&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>POST /website/blog/1/_update    更新文档，存在的字段就更新，不存在的字段就增加。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request POST &#x27;http://127.0.0.1:9200/megacorp/employee/4/_update&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">   &quot;doc&quot; : &#123;</span><br><span class="line">      &quot;about&quot; : &quot;l love to sleep and work&quot;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_most_important_queries.html">ES常用的查询语句</a></p>
</li>
<li><p>多个查询的组合。比较复杂，后面如果经常使用需要多看</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;must&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;age&quot;</span>: <span class="number">25</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;must_not&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;first_name&quot;</span>: <span class="string">&quot;Zhang&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;about&quot;</span>: <span class="string">&quot;rock&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;exists&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;interests&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续需要多看官方的文档，多了解了解</p>
<h4 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><p>​    整合依赖，添加esstarter即可，注意这个依赖使用的是elasticsearch-rest-high-level-client</p>
<p>​    添加相关配置，例如集群的url，这里可以添加多个，客户端会轮询</p>
<p>​    添加相关实体类，加上@Document(indexName = “user”)注解</p>
<p>​    添加UserRepository接口继承ElasticsearchRepository&lt;User, Integer&gt;，一般的方法默认都实现了，也可以是使用@Query注解修改你方法的Query</p>
<p>​    查询即可，后续高级的用法再说。</p>
<h3 id="ES的面试问题"><a href="#ES的面试问题" class="headerlink" title="ES的面试问题"></a>ES的面试问题</h3><ul>
<li>ES集群相关的配置。</li>
</ul>
<p>我们公司使用的是单节点架构，分片是默认的5分片。索引大概4个索引。主要存储的数据都是设备的历史数据和状态记录。这样是没法达到高可用的，可以设置多节点，保证高可用，因为主分片和他的副本是不会在同一个节点上的。索引的话可以设置多个主分片，但是后续不能修改，这个就需要结合你的业务增长速度，每个分片其实会占用一定的计算机资源。副本的话可以后续修改，如果你某个索引吞吐量达，可以添加副本的数量。</p>
<ul>
<li>ES是如何找到一个文档的</li>
</ul>
<p>​    首先以我们公司使用的单节点架构为例，寻找一个文档很简单，知道文档的id和index，直接就能判断出文档在哪个分片，然后获取数据并且返回即可。这一步骤没有什么可以讲的点。搜索就复杂一点，因为不知道文档属于哪个分片，所以需要将请求发送到这个索引的所有副本分片上，同时后续的请求会轮询其他分片。每个分片建立一个优先队列，长度为from+size。默认的是0和10。然后该分片将符合要求的文档的id和排序值返回给协调节点，协调节点将所有节点的结果排序，取出客户端需要的数据，再次请求对应的分片，将分片返回的文档返回给客户端即可。多节点的话，最先请求的节点会处理客户端的请求，也叫做协调节点，但是我们只有一个节点，所以也就只有一个协调节点。</p>
<ul>
<li>项目中什么地方使用到ES，为什么这样用？</li>
</ul>
<p>因为我们公司项目本身是用来给政府单位开发的，所以在设计上会存在一些过量的设计，以此凸显自己项目的优势。这个我认为在开发中是没法避免的。后期的话，公司会做一个设备信息状态的判断 ，然后演算某些隧道的设备是否达到替换的标准，以此给业主提供参考意见，我觉这个地方可以展示es的一些优势，将es利用起来，例如：对某条隧道故障设备进行排名，再按照设备的供应商、地理位置等等条件。当然，这只是我的一个想法，目前的使用还是简单的将其作为一个数据库，对设备的历史数据进行维护。</p>
<ul>
<li>ES如果某一时刻需要开启大批量的查询，如何做？</li>
</ul>
<p>可以通过游标查询，游标查询允许我们 先做查询初始化，然后再批量地拉取结果。游标查询是取某个时间点的快照数据，通过请求中设置游标的时间参数，获取到游标的id，后续的请求发送这个id即可。达到大批量的查询。 游标查询的过期时间会在每次做查询的时候刷新，所以你的时间点设置只要本地查询处理就可以了。不需要设置很大。初始搜索请求和每个后续滚动请求返回一个新的 _scroll_id。</p>
<ul>
<li>ES如何解决脑裂现象的</li>
</ul>
<p>脑裂现象是指集群中因为网络分区或者其他原因导致出现两个master的现象，例如123选举3节点为master节点。456选举6节点为master节点。esmaster节点的选举来源分为两个地方，activemaster列表和mastercanditancees列表，前者是通过禁止本地节点入选来解决脑裂现象，后者是通过通过设置最小节点数来解决脑裂现象。当然，在我们项目实际使用过程中没有涉及到集群的这一方面，所以有些实际的问题可能没有涉及到。</p>
<ul>
<li>什么是倒排索引</li>
</ul>
<p>​    说到倒排索引，其实可以先提一下正排索引，类似MySQL这种，根据某行记录的ID查询该行记录，例如查询id为9的用户的信息，这就是正排索引，倒排索引相反，根据信息查询id，例如，有很多用户的信息，每个用户有一个备注，例如：我喜欢打篮球或者我喜欢打排球。倒排索引就是将这段话分词，分为各个词语，然后将形成一个列表，第一列就是各个词语，第一行就是各个文档id，中间内容就是记录各个词语在各个文档中是否出现或者出现的频率。这样就能达到一个效果，根据词语搜索文档的id，再搜索文档的信息。这样的表格就是倒排索引。</p>
<ul>
<li>ES集群是如何处理故障的？</li>
</ul>
<p>​    其他节点发现master节点故障后，发起选举，选举出新的master节点，然后新的主节点重新分配主分片，为挂掉的主节点创建分片的副本。</p>
<ul>
<li>ES集群的选举过程？</li>
</ul>
<p>​    选举的情况有三种：1）master节点崩溃。2）集群初始化的时候。3）任意节点发现当前master节点没有n/2+1节点支持时。</p>
<p>​    es的节点成员先发送ping请求给其他节点，构建两个列表：当前其他节点认为的存活的master节点列表和master候选节点列表。activeMaster和masterCanditances存在优先级，先从activeMaster中选举，如果该列表为空，在从masterCanditance列表中选举。</p>
<p>activeMaster节点不包含本地节点，这样就可以避免脑裂现象。该列表的选举采用Bully算法，就是每个节点都有一个优先级，从这些节点中选取出优先级最高的节点当作master节点。优先级的判断主要有两点：版本号和id。版本号越大优先级越高、id越小优先级越高。</p>
<p>masterCanditances列表里面先判断是否达到最小节点数，如果达到了就按照优先级进行选举。</p>
<p>选举出来master节点后，还存在两种情况：本地节点是master节点，会等待其他节点投票，如果超时或者设置的最小节点，就重新选举，如果票数大于，就当选为master节点。本地节点不是master时，首先禁止其他节点加入自己，然后监听集群的发布状态。如果新的master和自己的一致，就进行状态更新，否则重新发起选举。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>//索引的概念</p>
<p>//文档的概念</p>
<p>//映射的相关概念</p>
<p>//主分片和复制分片的概念</p>
<p>//es如何确保请求被分开（可能是轮询）</p>
<p>//es中的文本分析和</p>
<p>//倒排索引（分词）</p>
<p>//分析器</p>
<p>//结构化查询（通过json体进行查询）</p>
<p>//查询语句和过滤语句</p>
<p>//结果震荡</p>
<p>//字典树</p>
<p>练习</p>
<p>//简单的CURD</p>
<p>//指定映射和分析器</p>
<p>//结构化查询（通过json体进行查询）</p>
<p>//查询语句和过滤语句</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>ElasticSearch</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/elasticsearch%E6%90%AD%E5%BB%BA%E5%92%8Capi%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Elasticsearch搭建和简单API使用"><a href="#Elasticsearch搭建和简单API使用" class="headerlink" title="Elasticsearch搭建和简单API使用"></a>Elasticsearch搭建和简单API使用</h1><p>​    之前的博客介绍了SpringBoot如何使用ES，但是ES最新版本的安装没有说明，最近需要做这个了发现没有具体的文档，这篇博客就来说一下ES在CentOS下的安装文档，同时也介绍一下一些简单的ES使用的API。不多逼逼了，开始。</p>
<h3 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h3><ul>
<li><p>下载RPM包。</p>
<p>本次的安装步骤是使用RPM包安装的，因为步骤比较简单。所以第一步需要下载RPM包，这个需要到官网下载，地址如下：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a>。根据自己的需要下载对应的版本就可以了。把RPM包上传到服务器上即可。</p>
</li>
<li><p>安装ES</p>
<p>在RPM包目录下执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm  --install elasticsearch-7.9.1-x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>出现以下画面就表示安装完成</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200904104228179.png" alt="image-20200904104228179"></p>
</li>
<li><p>配置ES</p>
<p>配置ES前需要先安装Java，但是这个比较简单，并且不在本次叙述内容里面，这里就不再累述了，网上博客一搜一大堆。</p>
<ul>
<li><p>配置ES中的JAVA_HOME。</p>
<p>配置一下ES中的JAVA_HOME，这样ES启动的时候就会自己去找Java环境了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/elasticsearch</span><br><span class="line"></span><br><span class="line">修改JAVA_HOME属性为本机的配置即可</span><br></pre></td></tr></table></figure></li>
<li><p>修改ES配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/elasticsearch/elasticsearch.yml</span><br><span class="line"></span><br><span class="line">修改以下配置</span><br><span class="line">cluster.initial_master_nodes</span><br><span class="line">network.host</span><br><span class="line">http.port</span><br><span class="line">node.name</span><br><span class="line">cluster.name</span><br><span class="line">详细文件内容如下：</span><br><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Elasticsearch comes with reasonable defaults for most settings.</span></span><br><span class="line"><span class="comment">#       Before you set out to tweak and tune the configuration, make sure you</span></span><br><span class="line"><span class="comment">#       understand what are you trying to accomplish and the consequences.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The primary way of configuring a node is via this file. This template lists</span></span><br><span class="line"><span class="comment"># the most important settings you may want to configure for a production cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please consult the documentation for further information on configuration options:</span></span><br><span class="line"><span class="comment"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for your cluster:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">cluster.name: elasticsearch</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">node.name: node-1</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Add custom attributes to the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#node.attr.rack: r1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">path.data: /var/lib/elasticsearch</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">path.logs: /var/<span class="built_in">log</span>/elasticsearch</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lock the memory on startup:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#bootstrap.memory_lock: true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make sure that the heap size is set to about half the memory available</span></span><br><span class="line"><span class="comment"># on the system and that the owner of the process is allowed to use this</span></span><br><span class="line"><span class="comment"># limit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Elasticsearch performs poorly when the system is swapping the memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the network module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Pass an initial list of hosts to perform discovery when this node is started:</span></span><br><span class="line"><span class="comment"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;node-1&quot;</span>]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the discovery and cluster formation module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Gateway -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Block initial recovery after a full cluster restart until N nodes are started:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#gateway.recover_after_nodes: 3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the gateway module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Various -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Require explicit names when deleting indices:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#action.destructive_requires_name: true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>启动ES，添加到开机自启</p>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service elasticsearch start</span><br><span class="line">chkconfig --add elasticsearch</span><br></pre></td></tr></table></figure></li>
<li><p>其他信息</p>
<ul>
<li><p>删除ES</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -e elasticsearch-7.9.1-x86_64.rpm</span><br></pre></td></tr></table></figure></li>
<li><p>开放防火墙端口（建议开启防火墙）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9200/tcp --permanent</span><br></pre></td></tr></table></figure></li>
<li><p>把日志目录到权限赋予es用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R es:es /opt/elasticsearch</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="API简单介绍"><a href="#API简单介绍" class="headerlink" title="API简单介绍"></a>API简单介绍</h3><p>​    ES可以通过使用RESTful API来进行交互，使用的是9200端口。更极端的情况下，可以使用curl命令来进行交互。</p>
<p>​    一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; <span class="string">&#x27;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#x27;</span> -d <span class="string">&#x27;&lt;BODY&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>VERB</code></td>
<td align="center">适当的 HTTP <em>方法</em> 或 <em>谓词</em> : <code>GET</code>、 <code>POST</code>、 <code>PUT</code>、 <code>HEAD</code> 或者 <code>DELETE</code>。</td>
</tr>
<tr>
<td align="center"><code>PROTOCOL</code></td>
<td align="center"><code>http</code> 或者 <code>https</code>（如果你在 Elasticsearch 前面有一个 <code>https</code> 代理）</td>
</tr>
<tr>
<td align="center"><code>HOST</code></td>
<td align="center">Elasticsearch 集群中任意节点的主机名，或者用 <code>localhost</code> 代表本地机器上的节点。</td>
</tr>
<tr>
<td align="center"><code>PORT</code></td>
<td align="center">运行 Elasticsearch HTTP 服务的端口号，默认是 <code>9200</code> 。</td>
</tr>
<tr>
<td align="center"><code>PATH</code></td>
<td align="center">API 的终端路径（例如 <code>_count</code> 将返回集群中文档数量）。Path 可能包含多个组件，例如：<code>_cluster/stats</code> 和 <code>_nodes/stats/jvm</code> 。</td>
</tr>
<tr>
<td align="center"><code>QUERY_STRING</code></td>
<td align="center">任意可选的查询字符串参数 (例如 <code>?pretty</code> 将格式化地输出 JSON 返回值，使其更容易阅读)</td>
</tr>
<tr>
<td align="center"><code>BODY</code></td>
<td align="center">一个 JSON 格式的请求体 (如果请求需要的话)</td>
</tr>
</tbody></table>
<ul>
<li><p>例子</p>
<ul>
<li><p>创建一个商品的索引，指定四个属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/commodity</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;number_of_shards&quot;</span>:3,</span><br><span class="line">        <span class="string">&quot;number_of_replicas&quot;</span>:2</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;commodity_id&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>:<span class="string">&quot;long&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;commodity_name&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;picture_url&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;price&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>:<span class="string">&quot;double&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回结果：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;shards_acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;commodity&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200904143546873.png" alt="image-20200904143546873"></p>
</li>
</ul>
<p>还有一些用法，这里就不再列出来了，详细的文档可以看看官方文档，官方文档是基于2.0版本的，但是安装的是7.9，所以部分用法可能有些不一样，但是了解ES的一些基础的东西估计没有问题。中文文档地址在下方。<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p>
</li>
</ul>
<p>​    这样就基础的就差不多了，就这样吧，结束。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>ElasticSearch</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="MySQL事务了解"><a href="#MySQL事务了解" class="headerlink" title="MySQL事务了解"></a>MySQL事务了解</h2><p>​    上次使用了最基本的MySQL，只是简单的查询一个表中的数据，这次练习一下事务。开始。</p>
<p>​    MySQL有四层架构，分别为：<strong>连接层</strong>、<strong>服务层</strong>、<strong>引擎层</strong>、<strong>存储层</strong>。这四层的作用如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200608233609217.png" alt="image-20200608233609217"></p>
<p>​    需要注意的是，事务的执行是在引擎层，并不是服务层。目前使用最广泛的就是InnoDB，其他的引擎很少有支持事务的。</p>
<p>​    事务的特性有四个。<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>、<strong>持久性</strong>。四个特性简称为<strong>ACID</strong>，其含义和解释如下：</p>
<ul>
<li>原子性：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。</li>
<li>一致性：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。</li>
<li>隔离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
<li>持久性：当事务正确完成后，它对于数据的改变是永久性的。</li>
</ul>
<p>​    MySQL中的事务为了保证原子性，通过undo log日志来进行事务的撤销和数据的回滚。一致性则是MySQL中最终追求的目标，需要其他三个特性的支持。为了保持隔离性，MySQL中使用锁来对数据进行保护和同步。持久性则是使用InnoDB存储引擎中的redo log日志来实现的。下面分别介绍。</p>
<ul>
<li><p>undo log 日志。回滚日志的作用就是对数据进行回滚，属于逻辑日志。它对SQL语句执行相关的信息进行记录。当发生回滚时，InnoDB引擎会根据undo log日志中的记录做与之前相反的工作。比如对于每个数据插入操作（insert），回滚时会执行数据删除操作（delete）。</p>
</li>
<li><p>说锁之前先说一下MySQL中的数据存储形式，分为：数据库、数据表、数据页、行。各个形式如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612170140499.png" alt="image-20200612170140499"></p>
<p>MySQL中的锁有下面几种：行锁、表锁、页锁。粒度分别如下：</p>
<ul>
<li><p>行锁：粒度最小的锁，表示只针对当前操作的行进行加锁；</p>
</li>
<li><p>表锁：粒度最大的锁，表示当前的操作对整张表加锁；</p>
</li>
<li><p>页锁：粒度介于行级锁和表级锁中间的一种锁，表示对页进行加锁；</p>
</li>
</ul>
<p>表锁因为锁定的是整张表，所以并发性比较差，行锁如果过多，占用的资源比较多。</p>
<p>涉及到锁了，就要提及数据的读写问题了，读写问题有三类：脏读、不可重复读、幻读。</p>
<ul>
<li><p>脏读。当前事务中读到其他事务未提交的数据，也就是脏数据。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202259136.png" alt="image-20200612202259136"></p>
</li>
<li><p>不可重复读。在事务A中先后两次读取同一个数据，但是两次读取的结果不一样。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202326662.png" alt="image-20200612202326662"></p>
</li>
<li><p>幻读。在事务A中按照某个条件先后两次查询数据库，两次查询结果的行数不同，这种现象称为幻读。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202505995.png" alt="image-20200612202505995"></p>
</li>
</ul>
<p>根据这些问题产生了四种隔离级别，如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202611299.png" alt="image-20200612202611299"></p>
<p>然后就是MVCC（多版本的并发控制协议）相当于git，这个可以解决脏读和不可重复读读问题。这个放在后面讲吧。</p>
</li>
<li><p>redo log日志。重做日志是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。InnoDB引擎对数据的更新，是先将更新记录写入redo log日志，然后会在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的<strong>预写式技术（Write Ahead logging）</strong>。这种技术可以大大减少IO操作的频率，提升数据刷新的效率。redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑，比如”给ID=2这一行的a字段加1 “。binlog日志中的内容是二进制的，根据日记格式参数的不同，可能基于SQL语句、基于数据本身或者二者的混合。一般常用记录的都是SQL语句。详细执行步骤如下：（在对redo log写入时有两个阶段的提交，一是binlog写入之前<code>prepare</code>状态的写入，二是binlog写入之后<code>commit</code>状态的写入。）</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612212946695.png" alt="image-20200612212946695"></p>
<p>其实是看了一篇博客，详细了了解了事务的原理和关于MySQL的一些信息。链接如下：<a href="https://mp.weixin.qq.com/s/HQh_HpbtvJv6Y5k3OAlfsQ">https://mp.weixin.qq.com/s/HQh_HpbtvJv6Y5k3OAlfsQ</a></p>
<p>后面也回简单写一个demo，具体把这些概念了解一下。就这样吧，结束。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="MySQL知识点"><a href="#MySQL知识点" class="headerlink" title="MySQL知识点"></a>MySQL知识点</h1><h2 id="MySQL基础知识"><a href="#MySQL基础知识" class="headerlink" title="MySQL基础知识"></a>MySQL基础知识</h2><h3 id="MySQL查询流程"><a href="#MySQL查询流程" class="headerlink" title="MySQL查询流程"></a>MySQL查询流程</h3><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210719230933044.png" alt="image-20210719230933044"></p>
<p>​    分为server层和存储层，innodb就是位于存储层，主要负责对于磁盘的读写。server层主要就是mysql的一些基础服务，以查询sql为例，先是连接器管理连接，然后分析器分析语法是否有错误，没有错误查询缓存，缓存不存在将sql优化，最后调用执行器查询结果。</p>
<h3 id="MySQL中锁的相关知识点"><a href="#MySQL中锁的相关知识点" class="headerlink" title="MySQL中锁的相关知识点"></a>MySQL中锁的相关知识点</h3><p>​    数据库中分为三种情况</p>
<p>​    读-读：没有对数据进行影响，不需要操作。</p>
<p>​    写-写：需要对操作加锁。</p>
<p>​    读-写：会出现脏读、幻读。所以要对写操作加锁。</p>
<ul>
<li>表级锁：开销小，加锁快。不会出现死锁，锁颗粒度大，也就导致发生冲突概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢。会出现死锁，锁颗粒度小，锁的冲突比较低，并发度最高。</li>
<li>页面锁（BDB引擎）：开销介于表级锁和行级锁之间，会出现死锁，锁颗粒度一般，并发度一般。</li>
<li>共享锁(Shared Locks)：简称S锁，在事务要读取一条记录时，需要先获取该记录的S锁。S锁可以在同一时刻被多个事务同时持有。</li>
<li>排他锁(Exclusive Locks)：简称X锁，在事务要改动一条记录时，需要先获取该记录的X锁。X锁在同一时刻最多只能被一个事务持有。</li>
</ul>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul>
<li><p>意向共享锁(IS锁)：当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加一个意向共享锁(IS锁)，主要是快速查询表中记录有没有被上锁，提升效率。</p>
</li>
<li><p>意向排他锁(IX锁)：和上面的类似，只不过是排他锁。</p>
</li>
<li><p>自增锁(AUTO-INC锁)：在执行插入语句的时先加上表级别的AUTO-INC锁，插入执行完成后立即释放锁。无法确定插入多少记录时使用。</p>
</li>
<li><p>轻量级锁：在插入语句生成AUTO_INCREMENT值时先才获取这个轻量级锁，然后在AUTO_INCREMENT值生成之后就释放轻量级锁。确定插入多少列时使用。</p>
</li>
</ul>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614213241155.png" alt="image-20210614213241155"></p>
<ul>
<li>记录锁(Record Locks) 所谓记录，就是指聚簇索引中真实存放的数据，比如上面的1、4、7、10都是记录。</li>
<li>间隙锁(Gap Locks) 间隙指的是两个记录之间逻辑上尚未填入数据的部分，比如上述的(1,4)、(4,7)等。</li>
<li>临键锁(Next-Key Locks) 临键指的是间隙加上它右边的记录组成的左开右闭区间。比如上述的(1,4]、(4,7]等。</li>
</ul>
<h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><p>​    数据引擎常用的四种</p>
<ul>
<li>InnoDB：InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。<ul>
<li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。</li>
<li>InnoDB是为处理巨大数据量的最大性能设计。</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。</li>
<li>InnoDB被用在众多需要高性能的大型数据库站点上。</li>
</ul>
</li>
<li>MyISAM：MyISAM基于ISAM存储引擎，并对其进行扩展。MyISAM拥有较高的插入、查询速度，但不支持事物。<ul>
<li>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持。</li>
<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。</li>
<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>
<li>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</li>
</ul>
</li>
</ul>
<h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><p>​    事务包含四大特性，即<strong>原子性（Atomicity）</strong>、<strong>一致性（Consistency）</strong>、<strong>隔离性（Isolation）</strong>和<strong>持久性（Durability）</strong>(ACID)。</p>
<ul>
<li>原子性（Atomicity） 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的。 </li>
<li>一致性（Consistency） 一致性是指数据库的完整性约束没有被破坏，在事务执行前后都是合法的数据状态。这里的一致可以表示数据库自身的约束没有被破坏，比如某些字段的唯一性约束、字段长度约束等等；还可以表示各种实际场景下的业务约束，比如上面转账操作，一个账户减少的金额和另一个账户增加的金额一定是一样的。应用系统从一个正确的状态到另一个正确的状态。</li>
<li> 隔离性（Isolation） 隔离性指的是多个事务彼此之间是完全隔离、互不干扰的。隔离性的最终目的也是为了保证一致性。</li>
<li> 持久性（Durability） 持久性是指只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态。</li>
</ul>
<h4 id="关于事务的其他知识点"><a href="#关于事务的其他知识点" class="headerlink" title="关于事务的其他知识点"></a>关于事务的其他知识点</h4><ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 insert,update,delete 语句</li>
<li>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</li>
</ul>
<h3 id="MySQL中的隔离级别"><a href="#MySQL中的隔离级别" class="headerlink" title="MySQL中的隔离级别"></a>MySQL中的隔离级别</h3><h4 id="出现数据错乱的情况"><a href="#出现数据错乱的情况" class="headerlink" title="出现数据错乱的情况"></a>出现数据错乱的情况</h4><ul>
<li>脏写：脏写是指一个事务修改了其它事务未提交的数据。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614201951702.png" alt="image-20210614201951702"></p>
<ul>
<li>脏读：脏读是指一个事务读到了其它事务未提交的数据。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202018063.png" alt="image-20210614202018063"></p>
<ul>
<li>不可重复读：不可重复读指的是在一个事务执行过程中，读取到其它事务已提交的数据，导致两次读取的结果不一致。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202120848.png" alt="image-20210614202120848"></p>
<ul>
<li>幻读：幻读是指的是在一个事务执行过程中，读取到了其他事务新插入数据，导致两次读取的结果不一致。</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202228292.png" alt="image-20210614202228292"></p>
<h4 id="MySQL中的隔离级别-1"><a href="#MySQL中的隔离级别-1" class="headerlink" title="MySQL中的隔离级别"></a>MySQL中的隔离级别</h4><p>​    SQL中隔离级别有四种：</p>
<ul>
<li>READ UNCOMMITTED：未提交读。 就是一个事务可以读取另一个未提交事务的数据。</li>
<li>READ COMMITTED：已提交读。 就是事务要等另一个事物提交后才能读取数据</li>
<li>REPEATABLE READ：可重复读。 就是在开始读取数据（事务开启）时，不再允许修改操作</li>
<li>SERIALIZABLE：串行化。事务串行化顺序执行，可以避免脏读，不可重复读与幻读。（但是效率低）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读（READ UNCOMMITTED）</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">已提交读（READ COMMITTED）</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">可重复读（REPEATABLE READ）</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">false（InnoDB为true）</td>
</tr>
<tr>
<td align="center">串行化（SERIALIZABLE）</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
</tbody></table>
<h4 id="MySQL的处理办法（MVCC）"><a href="#MySQL的处理办法（MVCC）" class="headerlink" title="MySQL的处理办法（MVCC）"></a>MySQL的处理办法（MVCC）</h4><p>​    MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。主要实现有两个手段：版本链和ReadView。</p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>​    对每条记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。修改一行记录时，都会将本次的事务ID和undo日志记录下来。undo日志里面则是存放的旧值。</p>
<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><p>​    ReadView包含四个内容：</p>
<ul>
<li>m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</li>
<li>min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。</li>
<li>max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。</li>
<li>creator_trx_id：表示生成该ReadView的事务的事务id。</li>
</ul>
<p>流程：</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
<p>​    READ COMMITTED（读提交）在每次读取数据前都会生成一个ReadView，这样就能保证每次都能读到其它事务已提交的数据。</p>
<p>​    REPEATABLE READ （可重复读）只在第一次读取数据时生成一个ReadView，这样就能保证后续读取的结果完全一致。</p>
<h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>​    MySQL中日志有二进制日志（binlog）、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种日志：redo log（重做日志）和undo log（回滚日志）。</p>
<h4 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h4><p>​    重做日志（redo log）是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。</p>
<p>​    InnoDB引擎对数据的更新，是先将更新记录写入redo log日志，然后会在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的预写式技术（Write Ahead logging）。</p>
<p>​    redo log日志的大小是固定的，为了能够持续不断的对更新记录进行写入，在redo log日志中设置了两个标志位置，checkpoint和write_pos，分别表示记录擦除的位置和记录写入的位置。</p>
<p>​    当write_pos标志到了日志结尾时，会从结尾跳至日志头部进行重新循环写入。所以redo log的逻辑结构并不是线性的，而是可看作一个圆周运动。write_pos与checkpoint中间的空间可用于写入新数据，写入和擦除都是往后推移，循环往复的。</p>
<p>​    缓冲池<code>buffer pool</code>是在内存中分配的一个区域，包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当数据修改时，除了修改buffer pool中的数据，还会在redo log中记录这次操作；当事务提交时，会根据redo log的记录对数据进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复，从而保证了事务的持久性，使得数据库获得crash-safe能力。</p>
<p>​    redo log日志可分为两个部分，一是存在易失性内存中的缓存日志redo log buff，二是保存在磁盘上的redo log日志文件redo log file。</p>
<p>​    为了确保每次记录都能够写入到磁盘中的日志中，每次将redo log buffer中的日志写入redo log file的过程中都会调用一次操作系统的fsync操作。（和redis中AOF备份类似）</p>
<h4 id="binlog（二进制日志）"><a href="#binlog（二进制日志）" class="headerlink" title="binlog（二进制日志）"></a>binlog（二进制日志）</h4><p>​    二进制日志binlog是服务层的日志，还被称为归档日志。binlog主要记录数据库的变化情况，内容包括数据库所有的更新操作。所有涉及数据变动的操作，都要记录进二进制日志中。因此有了binlog可以很方便的对数据进行复制和备份，因而也常用作主从库的同步。二进制日志的文件大小不固定，写完会切换下一个文件。</p>
<p>​    和redo log的区别：redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑。redo log是基于crash recovery，保证MySQL宕机后的数据恢复；而binlog是基于point-in-time recovery，保证服务器可以基于时间点对数据进行恢复，或者对数据进行备份。binlog是服务层的日志，因此所有引擎都能够使用。redo log是引擎层的日志，是InnoDB引擎持有。</p>
<p>​    MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。不仅如此，在对redo log写入时有两个阶段的提交，一是binlog写入之前<code>prepare</code>状态的写入，二是binlog写入之后<code>commit</code>状态的写入。</p>
<h4 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h4><p>​    回滚日志同样也是InnoDB引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。但是undo log不redo log不一样，它属于逻辑日志。它对SQL语句执行相关的信息进行记录。</p>
<h4 id="什么是双阶段提交"><a href="#什么是双阶段提交" class="headerlink" title="什么是双阶段提交"></a>什么是双阶段提交</h4><p>​    修改一条数据时，以innodb为例，innodb在内存中修改完毕后，将其写入redolog，状态标记为准备，然后返回结果，服务层将这次的修改写入binlog，标记事务完成，然后redolog将状态标记为提交，等待将其写入磁盘中。双阶段提交是为了保证两个日志中逻辑上的一致，同一条数据不会因为宕机出现混乱。</p>
<h3 id="MySQL中数据类型"><a href="#MySQL中数据类型" class="headerlink" title="MySQL中数据类型"></a>MySQL中数据类型</h3><p>​    MySQL中数据类型分为三大块，数值类型、日期和时间类型、字符串类型。</p>
<p>​    数值类型：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180123419.png" alt="image-20210617180123419"></p>
<p>​    日期和时间类型</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180149314.png" alt="image-20210617180149314"></p>
<p>​    字符串类型</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180214099.png" alt="image-20210617180214099"></p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="B-树概念"><a href="#B-树概念" class="headerlink" title="B+树概念"></a>B+树概念</h4><h5 id="选择B-实现的原因"><a href="#选择B-实现的原因" class="headerlink" title="选择B+实现的原因"></a>选择B+实现的原因</h5><p>​    因为Mysql查询的形式是有以下几种：1）查询特定数据。2）查询范围数据。</p>
<ul>
<li>hash表并不支持范围查询，其他平衡树也是对于范围查询很低效。</li>
<li>B树和B+树的区别就是：B+树的数据存储只在叶子节点。因为系统IO并不是需要什么就读取什么，而是会读取这块空间的周围存储。B树因为非叶子结点也存储数据，所以会造成多次的IO读取。B+树因为叶子结点是链表的形式，所以可以较少次的IO读取。</li>
<li>跳表比较适合内存空间存储，对于磁盘空间查询不友好。（也是没有利用磁盘缓存的特点）跳表的查询相对于B+树稍微差些。</li>
</ul>
<h5 id="B-树概念-1"><a href="#B-树概念-1" class="headerlink" title="B+树概念"></a>B+树概念</h5><p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210615113558216.png" alt="image-20210615113558216"></p>
<ul>
<li>B+树非叶子节点上是不存储数据的，仅存储键值。键就是排序的因素，值就是直线下一个节点的地址。</li>
<li>B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值。</li>
<li>B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</li>
<li>根节点至少拥有两个子树</li>
<li>每个树节点最多拥有M个子树</li>
<li>每个树节点(除了根节点)拥有至少M/2个子树</li>
</ul>
<h5 id="B-树的性质"><a href="#B-树的性质" class="headerlink" title="B+树的性质"></a>B+树的性质</h5><ul>
<li>索引字段要尽量的小。因为索引字段过大，就会导致数据项变小，即B+树的阶数变小。导致B+树的高度变高，读取IO的次数也变多。</li>
<li>索引的最左匹配特性。因为B+树建立复合索引时是根据从左到右的方向来建立搜索树的，查询也是根据第一个字段来决定查询的方向，如果没有带第一个字段，就无法匹配。查到第一个字段后，这段数据的附近则是根据其他索引进行排序的。</li>
</ul>
<h4 id="MySQL中索引的分类"><a href="#MySQL中索引的分类" class="headerlink" title="MySQL中索引的分类"></a>MySQL中索引的分类</h4><ul>
<li><p>按照数据结构可以分为B+tree索引、Hash索引、Full-text索引。</p>
</li>
<li><p>B+tree索引：上面讲的差不多，有点就是查询快，读取IO磁盘的次数较低</p>
</li>
<li><p>Hash索引：单个查询可以快速，但是范围查询就很慢了</p>
</li>
<li><p>Full-text索引：full-text在mysql里仅有myisam支持它，而且支持full-text的字段只有char、varchar、text数据类型。full-text主要是用来代替like “%***%”效率低下的问题。</p>
<p>  按照物理存储可以分为：聚簇索引、二级索引（辅助索引或者非聚簇索引）</p>
</li>
<li><p>聚簇索引：聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。</p>
</li>
<li><p>非聚簇索引：二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。</p>
<p>  按照字段特性可以分类为：主键索引、普通索引、前缀索引。</p>
</li>
<li><p>主键索引：建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。</p>
</li>
<li><p>普通索引：建立在普通字段上的索引被称为普通索引。</p>
</li>
<li><p>前缀索引：前缀索引是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。</p>
</li>
<li><p>唯一索引：建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。</p>
<p>  按照字段个数可以分类为：单列索引、联合索引（复合索引、组合索引）。</p>
</li>
<li><p>单列索引：建立在单个列上的索引被称为单列索引。</p>
</li>
<li><p>联合索引：建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。</p>
</li>
</ul>
<h4 id="建立索引的几个原则"><a href="#建立索引的几个原则" class="headerlink" title="建立索引的几个原则"></a>建立索引的几个原则</h4><ul>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li>
<li>尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>在建立联合索引的时候，安排索引内的字段顺序的原则：1.如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。2.在必须维护两个重复索引时，这个时候需要考虑字段大小问题。</li>
<li></li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。</li>
</ul>
<h3 id="MySQL中的存储过程"><a href="#MySQL中的存储过程" class="headerlink" title="MySQL中的存储过程"></a>MySQL中的存储过程</h3><p>储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。特点有以下几点：</p>
<ul>
<li>存储过程能实现较快的执行速度。</li>
<li>存储过程允许标准组件是编程。</li>
<li>存储过程可被作为一种安全机制来充分利用。</li>
<li>存储过程能过减少网络流量。</li>
</ul>
<h3 id="SQL中的范式理解"><a href="#SQL中的范式理解" class="headerlink" title="SQL中的范式理解"></a>SQL中的范式理解</h3><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>​    在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 </p>
<p>​    所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<p>​    如：学生表中，有3个字段 学号 姓名 家庭地址(XXX省XXX市）,由于地址字段是可以再拆分的所以不满足第一范式。</p>
<p>​    改造为：学号 姓名 出生省份 出生城市既满足第一范式</p>
<h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>​    第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。<br>​    第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p>
<p>​    如：学生表中 有 学号 姓名 选课号 出生日期 成绩 五个字段， 其中学号为主键，成绩并不依赖与学号，所以不满足第二范式。应该删除选课号，然后构建一张选课表。</p>
<h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>​    满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 </p>
<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><ul>
<li>查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。(from后面跟多个表，通过where的形式做限定是内连接，只寻找两个表中都存在的数据)</li>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li>
<li>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li>
<li>MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。</li>
</ul>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>​    update 表名称 set 列名称=新值 where 更新条件;</p>
<ul>
<li>你可以同时更新一个或多个字段。</li>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以在一个单独表中同时更新数据。</li>
</ul>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><ul>
<li>如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li>
<li>你可以在 WHERE 子句中指定任何条件</li>
<li>您可以在单个表中一次性删除记录。</li>
</ul>
<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><ul>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以在 WHERE 子句中使用LIKE子句。</li>
<li>你可以使用LIKE子句代替等号 **=**。</li>
<li>LIKE 通常与 <strong>%</strong> 一同使用，类似于一个元字符的搜索。</li>
<li>你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</li>
<li>**%**：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</li>
<li>**_**：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。</li>
<li>**[]**：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</li>
<li><strong>[^]</strong> ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</li>
<li>查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。</li>
</ul>
<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n</span><br><span class="line"><span class="keyword">FROM</span> tables</span><br><span class="line">[<span class="keyword">WHERE</span> conditions]</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>]</span><br><span class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n</span><br><span class="line"><span class="keyword">FROM</span> tables</span><br><span class="line">[<span class="keyword">WHERE</span> conditions];</span><br></pre></td></tr></table></figure>

<p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p>
<ul>
<li><strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li>
<li><strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li>
<li>要注意UNION的两个查询条件返回结果要一致。</li>
<li>UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！</li>
<li>官网要求两个子查询列的名称和数据类型、和数目必须一致。但是数据类型和名称可以不一致也可以执行，只是后续又可能会出错。</li>
<li>UNION结果集的列名取自第一个SELECT语句的列名。</li>
<li>如果相应的SELECT列的数据类型不匹配，则UNION结果中的列的类型和长度将考虑所有SELECT语句检索的值。</li>
</ul>
<h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a><strong>ORDER BY</strong></h3><ul>
<li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li>
<li>你可以设定多个字段来排序。</li>
<li>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li>
<li>你可以添加 WHERE…LIKE 子句来设置条件。</li>
<li>如果字符集采用的是 utf8(万国码)，需要先对字段进行转码然后排序：<code>ORDER BY CONVERT(runoob_title using gbk);</code></li>
</ul>
<h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><p>GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。(count是统计，sum是求和)</p>
<h3 id="null值比较"><a href="#null值比较" class="headerlink" title="null值比较"></a>null值比较</h3><p>MySQL提供了三大运算符:用来对bull值比较</p>
<ul>
<li><strong>IS NULL:</strong> 当列的值是 NULL,此运算符返回 true。</li>
<li><strong>IS NOT NULL:</strong> 当列的值不为 NULL, 运算符返回 true。</li>
<li><strong>&lt;=&gt;:</strong> 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。</li>
<li>可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的控制语句"><a href="#事务的控制语句" class="headerlink" title="事务的控制语句"></a>事务的控制语句</h4><ul>
<li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li>
<li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>
<li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>
<li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li>
<li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>
<li>ROLLBACK TO identifier 把事务回滚到标记点；</li>
<li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>常用的函数，这个链接：<a href="https://www.runoob.com/mysql/mysql-functions.html">菜鸟网络</a> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span>[&#123;,<span class="operator">&lt;</span>expression<span class="operator">&gt;</span>...&#125;]</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], [&#123;,<span class="operator">&lt;</span>expression<span class="operator">&gt;</span>...&#125;]</span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<ul>
<li>首先，<code>PARTITION BY</code>子句将<code>FROM</code>子句生成的结果集划分为分区。<code>DENSE_RANK()</code>函数应用于每个分区。</li>
<li>其次，<code>ORDER BY</code> 子句指定<code>DENSE_RANK()</code>函数操作的每个分区中的行顺序。</li>
<li>与<code>RANK()</code>函数不同，<code>DENSE_RANK()</code>函数始终返回连续的排名值。</li>
</ul>
<ul>
<li><p>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。也可以使用OFFSET设定偏移量，你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</p>
</li>
<li><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。显示为一行，所以要对其他列进行聚合显示，求和或者求最大。</p>
</li>
<li><p>where后面的条件需要带上引号，单引号和双引号都可以。除了int和数字不需要带引号。</p>
</li>
<li><p>mysql没有full join，可以通过将左连接和右连接组合一起打到full join</p>
</li>
<li><p>各个SQL关键字执行的顺序</p>
<ol>
<li>FROM, including JOINs</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>WINDOW functions</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>UNION</li>
<li>ORDER BY</li>
<li>LIMIT and OFFSET</li>
</ol>
</li>
<li><p><code>count(1)和count（*）count（cloum）统计列值的数量时，会忽略空值，当括号内的值不可能为空时，就直接统计行数。count（1）和count（*）都是一样的，都是统计行数，都是根据索引来统计行数。</code></p>
</li>
<li><p>group by后面的having中的字段必须要查询到，如果相对表做个筛选，可以在group by前面添加where语句，having语句是对group by语句到补充。</p>
</li>
<li><p>in后面可以跟多个字段，和concat函数类似。</p>
</li>
<li><p>join当两个表中不匹配时，不返回任何行。</p>
</li>
<li><p>慢查询日志就是查询超过阈值的语句会被记录下来，一般的默认值就是10秒。这个可以设置。</p>
</li>
<li><p>CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result …] [ELSE result] END case的用法，一般用来做判断。</p>
</li>
<li><p>mod函数用来求余的，mod（3,2）返回1</p>
</li>
<li><p>COALESCE取值的，COALESCE（1，2）如果1为null，就取2。</p>
</li>
<li><p><code>LEFT(Str,length)</code>函数是一个字符串函数，它返回具有指定长度的字符串的左边部分。str是字符串，length是要截取的长度。</p>
</li>
<li><p>ROW_NUMBER()是一个窗口函数或分析函数，它为从1开始应用的每一行分配一个序号。用例：id - row_number() over(order by id) as rk</p>
</li>
<li><p>with tmp as (select * from table） 可以将查询结果作为临时表，子查询互相之间是不能访问的。</p>
</li>
<li><p><code>CROSS JOIN</code>子句从连接的表返回行的笛卡儿乘积。</p>
</li>
</ul>
<h2 id="MySQL语句优化"><a href="#MySQL语句优化" class="headerlink" title="MySQL语句优化"></a>MySQL语句优化</h2><p>​    大概30点个点。</p>
<ul>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li>尽量不要使用like进行匹配，要不然也会导致全表扫描。</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描。</li>
<li>如果在 where 子句中使用参数，也会导致全表扫描。</li>
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</li>
<li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
<li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</li>
<li>不要写一些没有意义的查询，如需要生成一个空表结构。</li>
<li>很多时候用 exists 代替 in 是一个好的选择。</li>
<li>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</li>
<li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>
<li>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</li>
<li>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li>
<li>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</li>
<li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
<li>临时表并不是不可使用，适当地使用它们可以使某些例程更有效。</li>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</li>
<li>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</li>
<li>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li>
<li>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</li>
<li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</li>
<li>尽量避免大事务操作，提高系统并发能力。</li>
<li>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</li>
<li>MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。</li>
<li>你可以在 MySQL 数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。</li>
</ul>
<h4 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h4><p>首先是通过慢查询日志来记录数据库中查询比较慢的SQL</p>
<p>然后是用explain来判断语句使用了哪些索引，以及一些基础的信息。看看和自己的预期是否一致</p>
<p>最后做对应的修改，例如增加索引或者修正索引的顺序。</p>
<h3 id="MySQL中问到的问题"><a href="#MySQL中问到的问题" class="headerlink" title="MySQL中问到的问题"></a>MySQL中问到的问题</h3><ul>
<li>MySQL中优化的场景和具体的做法。</li>
</ul>
<p>​    举个例子：我们有一个表，里面存储了点位的一些信息，建立了一个联合索引，点位id和设备id。有一次需要执行一条语句，查询某个设备的所有模拟信号点位信息。where后面的语句就是point_id=1 and mn&gt;0 and equipment_id=2.但是后来发现执行的效率不太对，通过explain查询发现只了一个索引，就是point_id，按理说应该走equipment_id。因为最左匹配原则，遇到范围查询时停止使用索引，所以最后造成这样的结果，可以调整sql的顺序，将范围查询放到后面。这样的例子其实在网上挺多的，这个需要你平时写sql多注意和多总结，遇到不正常的SQL去解析查询的流程。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>//MySQL中锁的分类，行级锁、排查锁、共享锁</p>
<p>// MySQL中的隔离级别</p>
<p>//事务</p>
<p>//索引</p>
<p>//数据类型</p>
<p>//B+树和B-树</p>
<p>//范式（了解即可）</p>
<p>//优化MySQL</p>
<p>//存储过程</p>
<p>//慢查询日志</p>
<p>慢SQL优化</p>
<p>//MySQL的事务文件就是redolog和undolog</p>
<p>//Mysql binlog和Relog</p>
<p>其他</p>
<p>分布式事务</p>
<p>需要学习窗口函数</p>
<p>ranking&gt;=countNum/2 and ranking&lt;=countNum/2+1</p>
<p>select Id,Company,Salary<br>from<br>(<br>select Id,Company,Salary,<br>row_number()over(partition by Company order by Salary)as ranking,<br>count(Id) over(partition by Company)as cnt<br>from Employee<br>)a<br>where ranking&gt;=cnt/2 and ranking&lt;=cnt/2+1</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/SQL%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="一些重要的SQL命令："><a href="#一些重要的SQL命令：" class="headerlink" title="一些重要的SQL命令："></a>一些重要的SQL命令：</h3><ul>
<li><strong>SELECT</strong> - 从数据库中提取数据</li>
<li><strong>UPDATE</strong> - 更新数据库中的数据</li>
<li><strong>DELETE</strong> - 从数据库中删除数据</li>
<li><strong>INSERT INTO</strong> - 向数据库中插入新数据</li>
<li><strong>CREATE DATABASE</strong> - 创建新数据库</li>
<li><strong>ALTER DATABASE</strong> - 修改数据库</li>
<li><strong>CREATE TABLE</strong> - 创建新表<ul>
<li><strong>NOT NULL</strong> - 指示某列不能存储 NULL 值。</li>
<li><strong>UNIQUE</strong> - 保证某列的每行必须有唯一的值。</li>
<li><strong>PRIMARY KEY</strong> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><strong>FOREIGN KEY</strong> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><strong>CHECK</strong> - 保证列中的值符合指定的条件。</li>
<li><strong>DEFAULT</strong> - 规定没有给列赋值时的默认值。</li>
</ul>
</li>
<li><strong>ALTER TABLE</strong> - 变更（改变）数据库表</li>
<li><strong>DROP TABLE</strong> - 删除表</li>
<li><strong>CREATE INDEX</strong> - 创建索引（搜索键）</li>
<li><strong>DROP INDEX</strong> - 删除索引</li>
</ul>
<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ul>
<li>SQL 使用单引号来环绕文本值，如果是数值字段，请不要使用引号。</li>
<li>通过使用 SQL，可以为表名称或列名称指定别名。基本上，创建别名是为了让列名称的可读性更强。</li>
<li>更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。</li>
</ul>
<h3 id="关键字用法"><a href="#关键字用法" class="headerlink" title="关键字用法"></a>关键字用法</h3><ul>
<li><p>SELECT DISTINCT 语句。在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>DISTINCT 关键词用于返回唯一不同的值。</p>
</li>
<li><p>WHERE语句。WHERE 子句用于提取那些满足指定条件的记录。</p>
<ul>
<li>BETWEEN：在某个范围内<code>Select * from emp where sal between 1500 and 3000;</code></li>
<li>LIKE：搜索某种模式<code>Select * from emp where ename like &#39;M%&#39;;</code>（通配符类似正则表达式）</li>
<li>MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。<code>SELECT * FROM Websites WHERE name REGEXP &#39;^[GFs]&#39;;</code></li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210601165337182.png" alt="image-20210601165337182"></p>
<ul>
<li>IN：指定针对某个列的多个可能值<code>Select * from emp where sal in (5000,3000,1500);</code></li>
</ul>
</li>
<li><p>AND &amp; OR 运算符。如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
</li>
<li><p>ORDER BY关键字。 关键字用于对结果集按照一个列或者多个列进行排序。(多列时，先排前面字段，再拍后面字段)ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。<code>SELECT * FROM Websites ORDER BY alexa DESC;</code></p>
</li>
<li><p>SELECT TOP 子句。MYSQL中为LIMIT。<code>SELECT * FROM Websites LIMIT 2;</code>SELECT TOP 子句用于规定要返回的记录的数目。</p>
</li>
<li><p>JOIN语句。SQL join 用于把来自两个或多个表的行结合起来。<strong>on</strong> 条件是在生成临时表时使用的条件，它不管 <strong>on</strong> 中的条件是否为真，都会返回左边表中的记录。<strong>where</strong> 条件是在临时表生成好后，再对临时表进行过滤的条件。</p>
<ul>
<li><strong>INNER JOIN</strong>：如果表中有至少一个匹配，则返回行</li>
<li><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行。LEFT JOIN语句后面的表被称为右表。</li>
<li><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li>
<li><strong>FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li>
</ul>
</li>
<li><p>UNION 操作符合并两个或多个 SELECT 语句的结果。UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。UNION ALL用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p>
</li>
<li><p>SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。</p>
</li>
<li><p>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p>
</li>
<li><p>TRUNCATE TABLE 语句。仅仅删除表内的数据，但并不删除表本身。</p>
</li>
<li><p>AUTO INCREMENT 字段。我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">LastName <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">FirstName <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h3><ul>
<li>AVG() 函数返回数值列的平均值。</li>
<li>COUNT() 函数返回匹配指定条件的行数。<ul>
<li>COUNT(column_name) 函数返回指定列的值的数目</li>
<li>COUNT(*) 函数返回表中的记录数</li>
<li>COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目</li>
</ul>
</li>
<li>FIRST() 函数返回指定的列中第一个记录的值。</li>
<li>LAST() 函数返回指定的列中最后一个记录的值。</li>
<li>MAX() 函数返回指定列的最大值。</li>
<li>MIN() 函数返回指定列的最小值。</li>
<li>SUM() 函数返回数值列的总数。</li>
<li>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</li>
<li>HAVING 子句。在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。HAVING 子句可以让我们筛选分组后的各组数据。</li>
<li>EXISTS 运算符用于判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。</li>
<li>UCASE() 函数把字段的值转换为大写。</li>
<li>LCASE() 函数把字段的值转换为小写。</li>
<li>MID() 函数用于从文本字段中提取字符。</li>
<li>LEN() 函数返回文本字段中值的长度。</li>
<li>ROUND() 函数用于把数值字段舍入为指定的小数位数。</li>
<li>NOW() 函数返回当前系统的日期和时间。</li>
<li>FORMAT() 函数用于对字段的显示进行格式化。</li>
<li>DATEDIFF() 函数返回两个日期之间的天数。用前一个参数减去后一个参数。</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p># Write your MySQL query statement below</p>
<p>select  count(distinct sender_id send_to_id)/count(distinct requester_id accepter_id) from FriendRequest,RequestAccepted</p>
<p>select product_id,sum(rest),sum(paid),sum(canceled),sum(refunded) from Invoice group by product_id;</p>
<p>select distinct</p>
<p>a.follower,</p>
<p>count(f.followee) as num</p>
<p>from </p>
<p>(select distinct followee as follower</p>
<p>from follow </p>
<p>where</p>
<p>followee in (select distinct follower from follow)) as a</p>
<p>left join follow as f on a.follower = f.followee</p>
<p>group by f.followee</p>
<p>order by a.follower</p>
<p>select distinct</p>
<p>a1.player_id</p>
<p>from Activity as a1,Activity as a2</p>
<p>where a1.event_date = a2.event_date-1</p>
<p>select </p>
<p>b.book_id</p>
<p>from Orders as o</p>
<p>left join Books as b</p>
<p>on o.book_id = b.book_id</p>
<p>where datediff(2019-06-23,b.available_from)&gt;30 </p>
<p>and datediff(o.dispatch_date,2018-06-23)&gt;0</p>
<p>group by book_id</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/PostgreSQL/Centos%E5%AE%89%E8%A3%85Postgresql%E5%92%8Cposogis%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Centos安装Postgresql和posogis插件"><a href="#Centos安装Postgresql和posogis插件" class="headerlink" title="Centos安装Postgresql和posogis插件"></a>Centos安装Postgresql和posogis插件</h2><p>​    公司临时让装一个数据库，正好是之前了解过的Postgresql，顺带把之前的安装的坑填。并且这次也安装了插件。下面直接开始。</p>
<p>​    安装的插件有：fuzzystrmatch、postgis、uuid-ossp。其中uuid-ossp需要再初始化数据库的时候指定，剩下的都可以在安装完数据库后进行安装。下面直接上教程，不逼逼了。很详细。</p>
<ul>
<li>下载postgresql官方压缩包，选择对应的版本。地址：<a href="https://www.postgresql.org/ftp/source/">https://www.postgresql.org/ftp/source/</a>，下载tar.gz</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806103650919.png" alt="image-20200806103650919"></p>
<ul>
<li><p>解压到指定目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf postgresql-9.6.10.tar -C /home/program/soft/</span><br></pre></td></tr></table></figure></li>
<li><p>执行配置命令，中间出现部分错误，按照指示安装对应插件即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install uuid uuid-devel</span><br><span class="line">./configure --prefix=/bigdata/work/postgresql --with-uuid=ossp</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806104151703.png" alt="image-20200806104151703"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install readline-devel</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806104250201.png" alt="image-20200806104250201"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel</span><br></pre></td></tr></table></figure>

<p>出现下面命令即可以执行make命令。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806104818429.png" alt="image-20200806104818429"></p>
</li>
<li><p>执行make命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>出现以下截图即安装成功：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806105752457.png" alt="image-20200806105752457"></p>
</li>
<li><p>后续的配置</p>
<p>创建一个postgres用户，创建数据目录和日志目录，将权限给这个用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser postgres</span><br><span class="line">mkdir /bigdata/work/postgresql/data</span><br><span class="line">chown -R postgres:postgres /bigdata/work/postgresql/data</span><br></pre></td></tr></table></figure></li>
<li><p>添加环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PGDATA=/bigdata/work/postgresql/data</span><br><span class="line"><span class="built_in">export</span> PGHOME=/bigdata/work/postgresql</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PGHOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li>
<li><p>初始化数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - postgres</span><br><span class="line">initdb</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806111651152.png" alt="image-20200806111651152"></p>
</li>
<li><p>修改两个配置，使用root用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /bigdata/work/postgresql/data/pg_hba.conf</span><br><span class="line">vim /bigdata/work/postgresql/data/postgresql.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806141658615.png" alt="image-20200806141658615"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806141724073.png" alt="image-20200806141724073"></p>
</li>
<li><p>将启动脚本复制到linux中去管理。</p>
<p>从postgresql中的解压目录复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp contrib/start-scripts/linux  /etc/init.d/postgresql</span><br><span class="line">vim /etc/init.d/postgresql</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200807090320846.png" alt="image-20200807090320846"></p>
</li>
<li><p>授予权限，设置开机自启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/init.d/postgresql</span><br><span class="line">chkconfig --add postgresql</span><br></pre></td></tr></table></figure></li>
<li><p>启动，设置密码。</p>
<p>直接使用root用户启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service postgresql start</span><br></pre></td></tr></table></figure>

<p>使用postgrees用户查看进程信息</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806142450969.png" alt="image-20200806142450969"></p>
<p>使用自带的工具连接数据库，设置密码。可以讲这个设置为系统环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bigdata/work/postgresql/bin/psql</span><br><span class="line">\password</span><br></pre></td></tr></table></figure></li>
<li><p>使用远程工具连接测试</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200806142714037.png" alt="image-20200806142714037"></p>
</li>
<li><p>安装Postgis插件</p>
<ul>
<li>先做准备工作，设置postgres用户的环境变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - postgres</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PGDATA=/bigdata/work/postgresql/data</span><br><span class="line"><span class="built_in">export</span> PGHOME=/bigdata/work/postgresql</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PGHOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$PGHOME</span>/lib:/lib64:/usr/lib64:/usr/<span class="built_in">local</span>/lib64:/lib:/usr/lib:/usr/<span class="built_in">local</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装需要依赖包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y python-devel perl-ExtUtils-Embed python-devel gcc-c++ openssl-devel readline readline-devel bzip2 zlib zlib-devel openssl openssl-devel pam pam-devel libxml2 libxml2-devel libxslt libxslt-devel openldap openldap-devel libgeos-dev libproj-dev libgdal-dev xsltproc docbook-xsl docbook-xml imagemagick libmagickcore-dev dblatex tcl tcl-devel unixODBC unixODBC-devel libpng12 libpng12-devel</span><br></pre></td></tr></table></figure>

<ul>
<li><p>下载其他依赖包</p>
<ul>
<li><p>安装Proj4</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.osgeo.org/proj/proj-4.9.3.tar.gz</span><br><span class="line">  tar -xf proj-4.9.3.tar.gz</span><br><span class="line">  <span class="built_in">cd</span> proj-4.9.3</span><br><span class="line">  ./configure --prefix=/bigdata/work/postgresql/plugin/proj</span><br><span class="line">  make </span><br><span class="line">  make install</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;/bigdata/work/postgresql/plugin/proj/lib&quot;</span> &gt; /etc/ld.so.conf.d/proj-4.9.3.conf</span><br><span class="line">  ldconfig</span><br></pre></td></tr></table></figure></li>
<li><p>安装GEOS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  wget http://download.osgeo.org/geos/geos-3.6.1.tar.bz2</span><br><span class="line">  tar -jxf geos-3.6.1.tar.bz2</span><br><span class="line">  <span class="built_in">cd</span> geos-3.6.1</span><br><span class="line">serivice jj</span><br><span class="line">  make</span><br><span class="line">  make install</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;/bigdata/work/postgresql/plugin/geos/lib&quot;</span> &gt; /etc/ld.so.conf.d/geos-3.6.1.conf</span><br><span class="line">  ldconfig</span><br></pre></td></tr></table></figure></li>
<li><p>安装GDAL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.osgeo.org/gdal/2.1.2/gdal-2.1.2.tar.gz</span><br><span class="line">tar -xf gdal-2.1.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gdal-2.1.2</span><br><span class="line">./configure --prefix=/bigdata/work/postgresql/plugin/gdal</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/bigdata/work/postgresql/plugin/gdal/lib&quot;</span> &gt; /etc/ld.so.conf.d/gdal-2.1.2.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure></li>
<li><p>安装PostGIS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.osgeo.org/postgis/<span class="built_in">source</span>/postgis-2.2.5.tar.gz</span><br><span class="line">tar -xf postgis-2.2.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> postgis-2.2.5</span><br><span class="line">./configure --prefix=/bigdata/work/postgresql/plugin/postgis --with-pgconfig=/bigdata/work/postgresql/bin/pg_config --with-geosconfig=/bigdata/work/postgresql/plugin/geos/bin/geos-config --with-gdalconfig=/bigdata/work/postgresql/plugin/gdal/bin/gdal-config --with-projdir=/bigdata/work/postgresql/plugin/proj</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200807094928599.png" alt="image-20200807094928599"></p>
<p>解决这个问题。需要将postgresql的lib目录导入ld.so.conf.d</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">/bigdata/work/postgresql/lib</span><br><span class="line"></span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>验证插件正常安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su postgres</span><br><span class="line">psql</span><br><span class="line">create database postgis;</span><br><span class="line">\c postgis</span><br><span class="line">CREATE EXTENSION postgis;</span><br><span class="line">CREATE EXTENSION postgis_topology;</span><br><span class="line">CREATE EXTENSION fuzzystrmatch;</span><br><span class="line">CREATE EXTENSION postgis_tiger_geocoder;</span><br><span class="line">CREATE EXTENSION <span class="string">&quot;uuid-ossp&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200807150426313.png" alt="image-20200807150426313"></p>
<p>即成功。</p>
<p>fuzzystrmatch是在源码中的有的，但是没有包含编译的时候没有包含进去，需要make一下。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> contrib/fuzzystrmatch/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>UUID-OSSP插件也是</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> contrib/uuid-ossp/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>  如下图：</p>
<p>  <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200807151502098.png" alt="image-20200807151502098"></p>
</li>
</ul>
<p>​    剩下就没有什么可以讲的了，按照步骤来就可以了。以为一些centos的依赖指定了版本，如果你的PostgreSQL版本和我的不一致，这一点需要注意。如何查询对应的版本需要到网上搜一搜。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>PostgreSQL</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="RabbitMQ基础知识了解"><a href="#RabbitMQ基础知识了解" class="headerlink" title="RabbitMQ基础知识了解"></a>RabbitMQ基础知识了解</h2><p>​    公司前一段时间重构了一个老项目的代码，转为了SpringBoot，但是中间RabbitMQ在转换的时候我问了大佬一个很弱智的问题，所以抽了空，了解一下这个之前一直用但是不懂原理的中间件。</p>
<p>​    RabbitMQ是基于AMQP（高级消息队列协议）开发的一个消息队列产品，相当于一个软件，所以其实要讲的AMQP，下面也就简单介绍一下AMQP，然后在介绍中间的一些组件。</p>
<p>​    AMQP高级消息队列协议）是一种消息传递协议，使一致的客户端应用程序可以与一致的消息传递中间件代理进行通信。消息发布到<em>exchanges</em>（交换机），交换机类似于邮局或邮箱。然后，交换机使用称为<em>bindings</em>（绑定）的规则将消息副本分发到队列中。然后，代理要么将消息传递给订阅了队列的消费者，要么消费者按需从队列中获取/拉取消息。这就是AMQP的一些基础概念，下面就来一一叙述中间提及到的概念。概念如下图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200924085039570.png" alt="image-20200924085039570"></p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>​    交换机是接收消息的AMQP中的一种实体。交换记接收一条消息并将其路由到零个或多个队列中。使用的路由算法取决于交换机的类型和绑定的规则。交换机在RabbitMQ官网上只有四种，但是实际使用中还多了一个默认的类型。四种交换机名称分别为：Direct exchange（直接交换）、Fanout exchange（扇形交换）、Topic exchange（主题交换）、Headers exchange（标头交换）。下面就说说实际使用到的五种交换。</p>
<ul>
<li>默认交换。默认交换是一种特殊的直接交换，特殊的地方在于：默认交换是预先声明的不带名称（空字符串）的直接交换。创建的每个队列都使用与队列名称相同的路由自动绑定到该队列。举个例子，有一个队列声明为：”search-indexing-online”，那么使用路由关键字”search-indexing-online”发送到默认交换机的消息将会被队列”search-indexing-online”接收。看起来类似于直接将消息发送到队列中。</li>
<li>直接交换。直接交换是基于消息路由关键字将消息传递到队列，原理也比较容易理解：队列使用路由关键字绑定到交换机，收到消息后，如果消息的路由关键字和前面的关键字一致，该消息就会路由到该队列。需要注意的是，如果有多个消费者接收同一个队列，那么将会在消费者层面进行负载均衡，而不是队列。示意图如下：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200923175758411.png" alt="image-20200923175758411"></p>
<ul>
<li>扇形交换。扇形交换将消息路由到与其绑定的所有队列，并且路由关键字将被忽略。如果将N个队列绑定到扇形交换的交换机，则将新消息发布到该交换机时，会将消息的副本传递到所有N个队列。扇出交换机非常适合消息的广播路由。示意图如下：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200923180111463.png" alt="image-20200923180111463"></p>
<ul>
<li>主题交换。主题交换根据消息的路由关键字和一个匹配规则将消息路由到一个或多个队列。主题交换类型通常用于实现各种发布/订阅模式变体。类似于MQTT中主题的概念，订阅了这个主题的客户端都可以接收到此类消息。没有示意图。</li>
<li>标头交换。标头交换旨在用于在多个属性上进行路由，这些属性比路由键更容易表示为消息标头。标头交换忽略路由键属性。相反，用于路由的属性取自headers属性。如果标头的值等于绑定时指定的值，则认为消息匹配。</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>​    AMQP中队列的概念和其他协议中队列的概念一致，存储由应用程序使用的消息。队列的属性有一些不同于其他的，如下：</p>
<ul>
<li><p>名称</p>
</li>
<li><p>持久（队列将在代理重新启动后幸存）</p>
</li>
<li><p>独占（仅由一个连接使用，并且该连接关闭时队列将被删除）</p>
</li>
<li><p>自动删除（至少有一个使用方的队列在最后一个使用方退订时被删除）</p>
</li>
<li><p>参数（可选；由插件和特定于代理的功能使用，例如消息TTL，队列长度限制等）</p>
<p> 需要注意的是，队列必须要先声明再使用，声明这个工作没有定必须由谁做，消费者或者生产者都可以，最好是由谁最先使用谁创建。如果声明已经创建的队列，属性一致的话，声明无效；属性不一致的话，会报一个406的通道异常。</p>
</li>
</ul>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>​    绑定是交换机使用的规则之一，这个规则的作用就是将消息路由联系到队列。为了指示交换机E将消息路由到队列Q，必须将Q 绑定到E。绑定可能具有某些交换机类型使用的可选 路由键属性。路由键的目的是选择发布到交换机的某些消息以路由到绑定队列。换句话说，路由键就像一个过滤器。</p>
<h3 id="消息的相关知识"><a href="#消息的相关知识" class="headerlink" title="消息的相关知识"></a>消息的相关知识</h3><p>​    broker(代理)将消息发送到应用程序之后（使用<code>basic.deliver</code>或<code>basic.get-ok</code>方法）。应用程序发送回确认之后（使用<code>basic.ack</code>方法）。前者称为自动确认模型，而后者称为显式确认模型。</p>
<p>​    关于RabbitMQ或者AMQP的基础知识了解到这里就暂时差不多了，后续的学习需要更加深入。就这样吧，结束。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="RabbtiMQ相关知识点"><a href="#RabbtiMQ相关知识点" class="headerlink" title="RabbtiMQ相关知识点"></a>RabbtiMQ相关知识点</h2><h3 id="RabbitMQ中的一些基础概念"><a href="#RabbitMQ中的一些基础概念" class="headerlink" title="RabbitMQ中的一些基础概念"></a>RabbitMQ中的一些基础概念</h3><h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><p>​    AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>
<p>​    过程：发布者（Publisher）发布消息（Message），经由交换机（Exchange）。交换机根据路由规则将收到的消息分发给与该交换机绑定的队列（Queue）。最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210629175842275.png" alt="image-20210629175842275"></p>
<h5 id="Exchange交换机"><a href="#Exchange交换机" class="headerlink" title="Exchange交换机"></a>Exchange交换机</h5><p>​    交换机是用来发送消息的 AMQP 实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。有四种类型的交换机。</p>
<ul>
<li>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</li>
<li>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应绑定键的队列。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</li>
<li>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果 N 个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的 N 个队列。</li>
<li>主题交换机（Topic exchange）Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。</li>
<li>头交换机（headers exchange）headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</li>
</ul>
<h5 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h5><p>​    AMQP 中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。</p>
<p>​    队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为 406 的通道级异常就会被抛出。</p>
<p>​    持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。（持久化的队列并不会使得路由到它的消息也具有持久性。）</p>
<h6 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h6><p>​    当一条消息在队列中出现以下三种情况的时候，该消息就会变成一条死信。</p>
<ul>
<li>消息被拒绝(basic.reject / basic.nack)，并且requeue = false</li>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
</ul>
<p>​    “死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</p>
<h5 id="消息的机制"><a href="#消息的机制" class="headerlink" title="消息的机制"></a>消息的机制</h5><h6 id="RabbitMQ确认消息收到的机制"><a href="#RabbitMQ确认消息收到的机制" class="headerlink" title="RabbitMQ确认消息收到的机制"></a>RabbitMQ确认消息收到的机制</h6><p>​    生产者发送消息到 RabbitMQ Server 后，RabbitMQ Server 需要对生产者进行消息 Confirm 确认。</p>
<p>​    消费者确认指的就是 RabbitMQ 需要确认消息到底有没有被收到，来确定要不要将该条消息从队列中删除掉。这就需要消费者来告诉 RabbitMQ，有以下两种方式。</p>
<ul>
<li>消费者在消费消息的时候，如果设定应答模式为自动，则消费者收到消息后，消息就会立即被 RabbitMQ 从 队列中删除掉。 </li>
<li>手动应答模式：可以在既定的正常情况下进行确认（告诉 RabbitMQ，我已经消费过该消息了，你可以删除该条数据了）；可以在既定的异常情况下不进行确认（RabbitMQ 会继续保留该条数据），这样下一次可以继续消费该条数据。    </li>
</ul>
<h6 id="RabbitMQ消息的持久化"><a href="#RabbitMQ消息的持久化" class="headerlink" title="RabbitMQ消息的持久化"></a>RabbitMQ消息的持久化</h6><p>持久化可以提高 RabbitMQ 的可靠性，以防止在异常情况（比如：重启、关机、宕机等）下的数据丢失。</p>
<p>RabbitMQ 持久化分为三部分：交换机的持久化、队列的持久化、消息的持久化。</p>
<ul>
<li>交换机持久化是指将交换机的属性数据存储在磁盘上，当 MQ 的服务器发生意外或关闭之后，在重启 RabbitMQ 时不需要重新手动或执行代码去创建交换机了，交换机会自动被创建，相当于一直存在。</li>
<li>如果不将队列设置为持久化，那么在 RabbitMQ 服务重启之后，相关队列的元数据会丢失，数据也会丢失。队列都没有了，消息也找不到地方存储了。队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失；</li>
<li>RabbitMQ 的消息是依附于队列存在的，所以要想消息持久化，那么前提是队列也必须设置持久化。</li>
</ul>
<h6 id="RabbitMQ消息的唯一性"><a href="#RabbitMQ消息的唯一性" class="headerlink" title="RabbitMQ消息的唯一性"></a>RabbitMQ消息的唯一性</h6><p>对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是：</p>
<p>（1）全局唯一</p>
<p>（2）MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽</p>
<p>有了这个inner-msg-id，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。</p>
<h4 id="RabbitMQ中一些详细的概念"><a href="#RabbitMQ中一些详细的概念" class="headerlink" title="RabbitMQ中一些详细的概念"></a>RabbitMQ中一些详细的概念</h4><ul>
<li>Connection（连接）：Producer 和 Consumer 通过 TCP 连接到 RabbitMQ Server。一个连接就代表了一个TCP连接。</li>
<li>Channel（信道）：基于 Connection 创建，数据流动都是在 Channel 中进行。一个连接可以有多个信道，因为TCP的创建和删除非常消耗资源。信道是双向数据流通道，是一个建立在TCP连接内的虚拟连接，每个信道有一个ID。</li>
<li>Vhost（虚拟主机） ： 虚拟主机，一个消息代理（Broker）里可以开设多个虚拟主机（Vhost），用作不同用户的权限分离。</li>
<li>Broker（消息代理）：实际上就是消息服务器实体。</li>
</ul>
<h3 id="RabbitMQ使用的场景"><a href="#RabbitMQ使用的场景" class="headerlink" title="RabbitMQ使用的场景"></a>RabbitMQ使用的场景</h3><ul>
<li>异步处理：比如用户注册后，需要写入数据库并且发送邮件和短信，这里可以通过RabbitMQ将发送邮件和短信异步化，因为这些操作对于目前的流程没有影响。</li>
<li>应用解耦：两个系统之间的应用解耦，A系统发送消息队列通知B系统，B系统完成数据持久化后，发送消息队列返回告知A系统。</li>
<li>流量削峰：用户发起请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,超过一定阈值后则直接抛弃用户请求或跳转到错误页面。可以缓解短时间的高流量压垮应用。</li>
</ul>
<h3 id="RabbitMQ和Mosquitto的区别"><a href="#RabbitMQ和Mosquitto的区别" class="headerlink" title="RabbitMQ和Mosquitto的区别"></a>RabbitMQ和Mosquitto的区别</h3><p>​    MQTT一般是物联网首选的协议，基于发布订阅的轻量级协议。一字节报头，两字节心跳报文。开销比较小，能够减少网络流量。</p>
<p>​    AMQP高级消息队列协议，是面向消息中间件提供的开放的应用层协议，其设计目标是对于消息的排序、路由（包括点对点和订阅-发布）、保持可靠性、保证安全性。AMQP规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像SMTP，HTTP，FTP等协议可以创建交互系统一样。</p>
<p>​    RabbitMQ和Mosquitto分别是这两种协议的broker。Mosquitto比较轻量级。</p>
<h3 id="RabbitMQ使用中遇到的一些问题"><a href="#RabbitMQ使用中遇到的一些问题" class="headerlink" title="RabbitMQ使用中遇到的一些问题"></a>RabbitMQ使用中遇到的一些问题</h3><ul>
<li>RabbitMQ如何保证消息顺序性</li>
</ul>
<p>​    通过添加一个属性，上一条消息的ID，生产者顺序发送。消费者拿到消息后，如何没有上一条消息的ID，就进行正常消费，同时在缓存中存储一下这条消息的ID。如果有上一条id的属性，但是不对或者缓存中没有，把消息重新放到队列里面，或者睡眠一段时间，等待其他消费者消费完上一条消息。</p>
<p>​    也可以将生产者和消费者绑定，就是一个生产者对应一个消费者。将业务分离，本身RabbitMQ到消息就有顺序性，这样就能保证整体的顺序性。</p>
<p>​    也可以将生产者的消息都发到一个队列里面，消费者这对应一个队列。生产者轮流发送消息。</p>
<ul>
<li>RabbitMQ如何保证消息的幂等性</li>
</ul>
<p>​    生产者在发送消息时，可以添加一个业务ID，例如SessionID，消费者收到消息后，在redis中进行设置，如果redis中存在，认为消息已经消费了，丢弃当前消息，如果没有key，认为消息没有被消费。执行业务逻辑。</p>
<p>​    还有一种就是将id当作数据库主键，如果该数据存在了，就update一下，不再新增数据。</p>
<ul>
<li>RabbitMQ如何保证消息可靠性？</li>
</ul>
<p>​    首先有三个地方需要保证。1）生产者发送消息到交换机，这里可以通过confirmCallBack来实现，还有消息投递队列失败后会调用一个ReturnCallback，不过这个消耗比较高。2）MQ里面如果宕机了，可以通过队列持久化和消息持久化解决这个问题，可能会影响吞吐量。3）消费者这边取消自动ack，手动确认收到消息。业务处理完成之后ack。</p>
<ul>
<li>RabbitMQ消费者如果长时间不ack会怎么样？</li>
</ul>
<p>猜想：消费者连接时通过心跳机制可以检测消费者是否在线，如果一条消息没有ack，并且消费者心跳不在线，认为消费者挂了，将消息重新放到队列里面。</p>
<ul>
<li>RabbitMQ如何实现延时发送</li>
</ul>
<p>​    因为我们的系统里面很少遇到这样的需求，所以后续的说法可能不太准确。1）可以利用死信队列来达到这样的效果，生产者生产消息，到一个普通交换机中，绑定这个交换机的队列就是延时队列，设置过期时间ttl，然后等待过期时间，消息过期后回转到指定的死信交换机的死信队列里面，再让消费者去消费死信队列里面的消息即可。达到延时的效果。但是这种存在一些缺点，因为延时时间是不固定的，所以队列的设置也比较多，给代码开发带来很多繁琐。2）利用rabbitMQ插件来实现延时队列，安装插件、创建指定的队列和交换机发送的时候指定延时时间就可以了。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>//Rabbbit使用场景</p>
<p>//RabbitMQ确认消息收到的机制</p>
<p>//RabbitMQ确认消息唯一的机制</p>
<p>//RabbitMQ消息的持久化</p>
<p>//RabbitMQ的死信队列</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>一般编写了config类，直接使用即可，因为springboot对当前包的bean都扫描了</p>
<p>启用对@ConfigurationProperties注释 bean 的支持。 @ConfigurationProperties bean 可以以标准方式注册（例如使用@Bean方法），或者为了方便，可以直接在此注释上指定。</p>
<p>@SpringBootApplicationh注解是三个注解的集合体@Configuration,@EnableAutoConfiguration,@ComponentScan，会自动扫描当前包及子包的所有注入bean吗，会自动根据xml文件配置相关bean</p>
<p>导入相关依赖</p>
<p>创建bean，指定创建的交换机和队列的属性，是否持久化</p>
<p>使用rabbitTemplate发送消息即可，发送消息时需要指定交换机、绑定key、发送的对象</p>
<p>持久化需要交换机持久化、队列持久化。消息持久化</p>
<p>交换机和队列可以在创建bean的时候指定是否持久化</p>
<p>消息持久化需要在发送的时候确定，默认是自动持久化的。不过需要队列先持久化</p>
<p>message 从 producer 到 rabbitmq broker cluster 则会返回一个 confirmCallback 。</p>
<p>重点是 CorrelationData 对象，每个发送的消息都需要配备一个 CorrelationData 相关数据对象，CorrelationData 对象内部只有一个 id 属性，用来表示当前消息唯一性。</p>
<p>发送的时候创建一个 CorrelationData 对象。</p>
<p>message 从 exchange-&gt;queue 投递失败则会返回一个 returnCallback 。我们将利用这两个 callback 控制消息的最终一致性和部分纠错能力。</p>
<p>必须 rabbitTemplate.setMandatory(true)，不然当 发送到交换器成功，但是没有匹配的队列，不会触发 ReturnCallback 回调。而且 ReturnCallback 比 ConfirmCallback 先回调。</p>
<p>后一个callback会导致性能下降，尽量少用</p>
<p>接收：</p>
<p>接收需要手动确认，需要在配置文件中开启一项设置</p>
<p>编写方法即可，填写相关的入参，然后判断ID，就是deliverTag，deliverTag是递增的，然后ack即可。处理完毕或者先ACK都可以。</p>
<p>练习</p>
<p>//练习RabbitMQ中的一些基础概念</p>
<p>//练习发送的确认</p>
<p>//练习消费的确认</p>
<p>controller发送指定交换机的消息</p>
<p>消费者消费，并且返回ack</p>
<p>打印这条消息</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="Redis基础概念"><a href="#Redis基础概念" class="headerlink" title="Redis基础概念"></a>Redis基础概念</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>​    Redis是一个高性能的key-value数据库。支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候再次加载使用。读的速度为110000次/s写的速度为81000次/s。操作都是原子操作。redis支持的类型：String、list、set、Zsetsorted set、Hash等。redis是单进程，单线程单，通过队列技术将并发访问变为串行访问。</p>
<ul>
<li>当Redis内存满了后，写命令会返回错误信息，读命令还是可以正常返回。</li>
</ul>
<h3 id="持久化机制和原理"><a href="#持久化机制和原理" class="headerlink" title="持久化机制和原理"></a>持久化机制和原理</h3><p>Redis有两个持久化策略：RDB和AOF</p>
<h4 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h4><p>​    Redis支持将当前数据的快照存成一个数据文件的持久化机制。而一个持续写入的数据库如何生成快照呢。Redis借助了fork命令的copy on write机制。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写如一个临时文件，持久化结束后，用这个临时文件代替上一个持久化文件，也就是rename。由于os的写时复制机制（copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是fork时刻整个数据库的一个快照。即持久化后的数据库的修改不会记录到持久化文件中，这个也是它的一个缺点之一，因为有可能从持久化后到服务器断电之前到数据都会丢失，主要是看项目的取舍。而且RDB快照是全量持久化，并不是增量持久化。</p>
<p>​    在redis客户端中执行<code>save 60 1000</code>(60秒内，如果有1000个键被修改就执行RDB)命令即可调用RDB快照的备份。</p>
<h4 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h4><p>​    AOF日志的全称是Append Only File，是一个追加写入的日志。但是AOF日志文件里面存储的是redis的标准命令，有些命令经过转化，例如删除一个不存在的键，redis认为不会对数据库造成造成修改，所以不会记录在AOF日志文件中，有些命令因为操作系统的不同可能会导致执行结果不同，所以都转换为统一的命令。</p>
<ul>
<li>AOF rewrite：功能就是重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件那样，可能记录了对同一个值的多次操作。其生成过程和RDB类似，也是fork一个进程，直接遍历数据，写入新的AOF临时文件。在写入新文件的过程中，所有的写操作日志还是会写到原来老的 AOF文件中，同时还会记录在内存缓冲区中。当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的 AOF文件取代老的AOF文件。 </li>
</ul>
<p>​    在Redis中对AOF调用write写入后，何时再调用fsync将其写到磁盘上，通过appendfsync选项来控制，下面appendfsync的三个设置项，安全强度逐渐变强。 通过设置配置项来实现AOF备份：<code>appendonly yes</code>,通过配置<code>appendfsync</code>来设置何时写到磁盘上。</p>
<ul>
<li>appendfsync no ：当设置appendfsync为no的时候，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。 </li>
<li>appendfsync everysec：当设置appendfsync为everysec的时候，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一 次的fsync调用时长超过1秒时。Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。 </li>
<li>appednfsync always：当设置appendfsync为always时，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响。 </li>
</ul>
<h3 id="Redis的内存回收策略"><a href="#Redis的内存回收策略" class="headerlink" title="Redis的内存回收策略"></a>Redis的内存回收策略</h3><p>​    如果redis占用的内存满了，可以通过设置内存回收策略来进行键值淘汰，配置项为：<code>maxmemory-policy</code>。主动清除策略主要有八种：</p>
<blockquote>
<ul>
<li><p>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</p>
</li>
<li><p>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</p>
</li>
<li><p>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。（LRU：最近最少使用）</p>
</li>
<li><p>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除（LFU：最不经常使用）</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>allkeys-random：从所有键值对中随机选择并删除数据。</p>
</li>
<li><p>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</p>
</li>
<li><p>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ul>
</blockquote>
<p>LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!</p>
<p>LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!</p>
<h3 id="Redis的键删除策略"><a href="#Redis的键删除策略" class="headerlink" title="Redis的键删除策略"></a>Redis的键删除策略</h3><p>​    Redis过期key的删除方式有三种：</p>
<ul>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key。返回nil。</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key。<ul>
<li>随机测试100个设置了过期时间的key</li>
<li>删除所有发现的已过期的key</li>
<li>若删除的key超过25个则重复步骤1</li>
</ul>
</li>
<li>当前已用内存超过maxmemory限定时，触发主动清理策略。</li>
</ul>
<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>​    Redis有三种集群模式：主从模式、Sentinel模式（哨兵模式）、Cluster模式（集群模式）。</p>
<h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p>​    主从模式将数据库分为两种，主库和从库。主数据库可以进行读和写，从数据库只能进行读。多个从数据库对应一个主数据库，从数据库挂了重启后会向主数据库请求同步数据。主数据库挂掉后，不影响从数据库的读，但是不能提供写服务了。</p>
<p>​    机制：当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。</p>
<p>​    缺点就是主数据挂掉后，redis无法提供写服务。</p>
<p>​    搭建方式：通过下载redis安装包，安装后，通过启动不同的配置文件来达到多个redis服务的目的。在配置文件中配置主数据库和从数据库即可。</p>
<h5 id="流程和细节"><a href="#流程和细节" class="headerlink" title="流程和细节"></a>流程和细节</h5><p>建立连接阶段（即准备阶段）</p>
<ol>
<li>设置master的地址和端口，保存master信息</li>
<li>建立socket链接</li>
<li>发送ping命令（定时器任务）</li>
<li>身份验证</li>
<li>发送slave端口信息<br>至此，主从链接成功！</li>
</ol>
<p>数据同步阶段（注意从机命令为psync，主机命令为bgsave）</p>
<p>步骤1：请求同步<br>步骤2：创建RDB同步数据<br>步骤3：恢复RDB同步数据<br>步骤4：请求部分同步数据<br>步骤5：恢复部分同步数据<br>至此，数据同步工作完成</p>
<p>命令传播阶段</p>
<p>通过ping命令，从机通知主机发送缓冲区内的命令</p>
<h4 id="Sentinel模式（哨兵模式）"><a href="#Sentinel模式（哨兵模式）" class="headerlink" title="Sentinel模式（哨兵模式）"></a>Sentinel模式（哨兵模式）</h4><p>​    主从模式的弊端就是主数据库挂掉后，从数据库无法提供写的服务，所以产生了哨兵模式。</p>
<p>​    Sentinel是一个进程，用来监控redis进程的状态，Sentinel也可以启动多个形成一个集群。当Sentinel检测到主节点挂掉后，会将从节点升级为主节点，并修改其他所有节点的配置文件。当主节点再次启动后，会变为从节点。从节点故障后，哨兵不会进行故障转移。</p>
<p>​    机制：每个Sentinel会每秒钟一次的频率向所有的主从节点发送PING命令，如果实例的回复超过了指定的值（通过配置down-after-milliseconds,默认是30秒），则会被Sentinel标记为主观下线。如果主节点标记主观下线，其他Sentinel都要确认这个主节点下线，。当Sentinel的确认数量超过了配置值后，认为主节点客观下线。将每10一次发送的INFO命令变为1秒发送一次。</p>
<h5 id="具体的流程和细节"><a href="#具体的流程和细节" class="headerlink" title="具体的流程和细节"></a>具体的流程和细节</h5><p>​    哨兵在进行主从切换过程中经历三个阶段</p>
<p>1.监控阶段</p>
<p>​    单个哨兵通过和主节点建立cmd链接，发送info命令，得到主节点的信息和各个从节点的信息，同时在主节点内存储哨兵实例的信息。主节点信息同步完毕后，向从节点建立链接，发送info命令，完善从节点的信息。</p>
<p>​    当其他哨兵加入进来时，链接到主节点后，发现主节点内有哨兵实例，通过发布订阅的形式，将两个哨兵实例的信息进行同步，后续的哨兵都是这样。</p>
<p>2.通知阶段</p>
<p>​    哨兵通过建立的cmd链接，发送相应的命令给节点，节点将状态信息返回，然后该哨兵通过发布订阅将信息同步给其他哨兵。</p>
<p>3.故障转移</p>
<p>​        一个哨兵发现主节点发送info命令没有回复，通知其他哨兵，并且将主节点状态修改为主观下线。其他哨兵也发送命令给主节点，如果确认的哨兵数超过了设定的值，就认为该主节点客观下线。然后哨兵之间需要选举出一个哨兵执行节点切换的任务。</p>
<p>​    每个哨兵都有一票，这票投给自己最先收到竞选通知的哨兵，直到某个哨兵票数超过一半以上，就认为该哨兵负责本次的切换。</p>
<p>​    哨兵从剩下的从节点中选出最优的主节点。先筛选出在线的，再筛选出响应快的，再筛选出和原先主节点同步时间最近的，最后还有多个的话，就按照优先原则，偏移量和uuid都会有影响。最后选出一个从节点，然后将这个从节点升级为主节点，将其他从节点的主节点的信息修改为新的主节点。后面如果掉线的主节点上线的话，也会修改为从节点。</p>
<h4 id="Cluster模式（集群模式）"><a href="#Cluster模式（集群模式）" class="headerlink" title="Cluster模式（集群模式）"></a>Cluster模式（集群模式）</h4><p>​    哨兵模式基本可以满足生产的需要，但是当数据量过大，导致一台机器无法满足时，这个时候就需要将数据进行分片存储，这就是集群模式。</p>
<p>​    Redis集群是一个由多个节点组成的分布式服务器群，它具有复制、高可用和分片特性；Redis集群没有中心节点，并且带有复制和故障转移特性，这可以避免单个节点成为性能瓶颈，或者因为某个节点下线而导致整个集群下线；</p>
<p>​    我们有3个主节点，3个从节点，每个主节点处理各自的数据，提供读写能力，从节点异步复制主节点的数据。一般读请求分配给从节点，写请求分配给主节点。</p>
<h5 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h5><p>​    一个 Redis 集群包含 16384 个哈希槽（hash slot）， 它们的编号为0、1、2、3……16382、16383，这个槽是一个逻辑意义上的槽，实际上并不存在。redis中的每个key都属于这 16384 个哈希槽的其中一个，存取key时都要进行key-&gt;slot的映射计算。Redis Cluster中的每个Master节点都会负责一部分的槽，当有某个key被映射到某个Master负责的槽，那么这个Master负责为这个key提供服务。在Redis Cluster中，只有Master才拥有槽的所有权，如果是某个Master的slave，这个slave只负责槽的使用，但是没有所有权。</p>
<h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>​    在cluster中，节点之间通过gossip协议进行通信。A节点会发送PING消息给B节点，若是在cluster_node_timeout时长内没有收到B节点的回复消息，则A节点会判定B节点已经下线了。这时候，A节点判定完后，会想集群广播B节点下线的消息。如果集群中的超过半数以上的节点都认为B节点下线后，B节点就会真正的下线。</p>
<p>​    当问题节点下线后，如果该下线节点是带有槽的主节点，则需要从它的从节点选出一个替换它，当问题节点的从节点发现其主节点下线时，将会触发故障恢复流程。但是并不是所有的从节点都能参与到故障恢复的流程中，若从节点与问题主节点的断线时间超过cluster_node_timeout * cluster-slave-validity-factor时，该从节点不能参与到后续恢复流程。</p>
<p>​    主要是通过对多个从节点使用不同的延迟选举时间来支持优先级问题。复制偏移量越大说明从节点延迟越低，那么它应该具有更高的优先级来替换故障主节点。</p>
<h4 id="Redis中的脑裂现象"><a href="#Redis中的脑裂现象" class="headerlink" title="Redis中的脑裂现象"></a>Redis中的脑裂现象</h4><p>​    redis中的脑裂现象：哨兵将发现主节点下线后，将一个从节点升级为主节点，但是仍然有客户端连接旧的主节点，两个主节点造成数据没有同步，后续主节点恢复后，数据仍然丢失。可以通过设置第一个参数表示连接到master的最少slave数量，第二个参数表示slave连接到master的最大延迟时间这两个参数。如果两个条件都不满足，主节点就会拒绝同步数据。防止脑裂现象的产生。</p>
<h3 id="Redis中的发布订阅"><a href="#Redis中的发布订阅" class="headerlink" title="Redis中的发布订阅"></a>Redis中的发布订阅</h3><p>​    Redis中的发布订阅可以使用匹配符，需要注意当没有消费者时，生产者发布的消息可能会丢失。</p>
<h3 id="Redis中的事务"><a href="#Redis中的事务" class="headerlink" title="Redis中的事务"></a>Redis中的事务</h3><p>​    Redis中的事务比较独特。事务开启后，会将命令都放入队列缓存中，其他客户端的命令不会放入。事务执行后，如果遇到命令格式错误，事务中所有的操作都不会被执行。但是如果命令格式正确，使用方式不对，例如对String执行hash方法，该命令不会被执行，其他正确命令仍然会被执行。</p>
<p>​    watch是为了完善redis事务的特点，在事务开始前监听某个key，如果事务中间key发生了变化，事务就会中断，不再执行。unwatch是为了取消监听，防止本次的监听对下次的事务产生影响。exec和discard也有同样的效果。</p>
<p>​    如果客户端发送的命令为 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令的其中一个， 那么服务器立即执行这个命令。如果不是这四个命令，服务器并不立即执行这个命令， 而是将这个命令放入一个事务队列里面， 然后向客户端返回 QUEUED。某些命令执行出错也不会影响整个事务。</p>
<h3 id="Redis中的管道"><a href="#Redis中的管道" class="headerlink" title="Redis中的管道"></a>Redis中的管道</h3><p>​    Redis默认每次执行请求都会创建和断开一次连接池的操作，因此我们可以使用Redis的管道来一次性发送多条命令并返回多个结果，节约发送命令和创建连接的时间提升效率。</p>
<p>​    Redis中管道的实现是根据队列，可以保证数据的顺序性。</p>
<h2 id="Redis数据结构相关知识点"><a href="#Redis数据结构相关知识点" class="headerlink" title="Redis数据结构相关知识点"></a>Redis数据结构相关知识点</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>一个键最大能存储 512MB，暂时没有找到原因</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</li>
<li>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><ul>
<li>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</li>
<li>hash的原理也是数组加链表，扩容机制不太一样，是双table扩容，新的table要扩容时，是在执行完原油命令后，将就table上的元素慢慢复制到新table。这就是渐进式扩容。但是还是存在一些问题的，就是极端情况下，如果键一直在增加，新table也会很快触发扩容，这种情况下如何处理，这里其实估计只有后续看源码能够想清楚了。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</li>
<li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li>
<li>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</li>
</ul>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><ul>
<li>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</li>
<li>Zset就是排序集合，在插入时需要制定元素的权，redis也是根据权来进行排序的。权相同时，则是根据字典排序。</li>
</ul>
<h3 id="跳跃表（skiplist）"><a href="#跳跃表（skiplist）" class="headerlink" title="跳跃表（skiplist）"></a>跳跃表（skiplist）</h3><p>​    跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</p>
<p>​    跳表相当于是在链表的形式上添加层级来达到快速查询的目的。</p>
<h2 id="Redis相关命令"><a href="#Redis相关命令" class="headerlink" title="Redis相关命令"></a>Redis相关命令</h2><h3 id="Redis常用的基础命令"><a href="#Redis常用的基础命令" class="headerlink" title="Redis常用的基础命令"></a>Redis常用的基础命令</h3><ul>
<li>启动：<code>redis-server redis.conf</code></li>
<li>连接：<code>redis-cli -h host -p port -a password</code></li>
<li>获取配置：<code>CONFIG GET *</code></li>
<li>设置配置：<code>ONFIG SET loglevel &quot;notice&quot;</code></li>
<li>删除key：<code>del tset</code></li>
<li>序列化给定 key ，并返回被序列化的值:<code>dump test</code></li>
<li>检查给定 key 是否存在:<code>EXISTS test</code></li>
<li>为给定 key 设置过期时间，以秒计:<code>EXPIRE test 120</code></li>
<li>为给定 key 设置过期时间,接受的时间参数是 UNIX 时间戳: <code>EXPIREAT test 1623297047</code></li>
<li>设置 key 的过期时间以毫秒计:<code>PEXPIRE test 120000</code></li>
<li>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计:<code>PEXPIREAT test 1623297047000</code></li>
<li>查找所有符合给定模式( pattern)的 key :<code>keys tes*</code></li>
<li>将当前数据库的 key 移动到给定的数据库 db 当中:<code>move test 1</code></li>
<li>移除 key 的过期时间，key 将持久保持:<code>PERSIST test</code></li>
<li>以毫秒为单位返回 key 的剩余的过期时间:<code>PTTL test</code></li>
<li>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live):<code>TTL test</code></li>
<li>从当前数据库中随机返回一个 key :<code>RANDOMKEY</code></li>
<li>修改 key 的名称:<code>RENAME test test1</code></li>
<li>仅当 newkey 不存在时，将 key 改名为 newkey:<code>RENAMENX test1 test</code></li>
<li>迭代数据库中的数据库键:<code>SCAN cursor [MATCH pattern] [COUNT count]</code></li>
<li>返回 key 所储存的值的类型:<code>type test</code></li>
<li>验证密码是否正确：<code>AUTH qhlk@2017</code></li>
<li>打印字符串：<code>ECHO &quot;this is test&quot;</code>(当你的字符串中间带特殊字符时，需要你带上双引号)</li>
<li>查看服务是否运行：<code>PING</code></li>
<li>关闭当前连接：<code>QUIT</code></li>
<li>切换到指定的数据库：<code>SELECT 0</code>(总共十六个库，0-15)</li>
<li>创建当前数据库的备份：<code>SAVE</code></li>
<li>根据备份文件恢复redis数据库：<code>BGSAVE</code></li>
</ul>
<h3 id="字符串相关命令"><a href="#字符串相关命令" class="headerlink" title="字符串相关命令"></a>字符串相关命令</h3><ul>
<li>设置指定 key 的值：<code>set tset &quot;hello&quot;</code>也可以对存在的key执行就是修改</li>
<li>获取指定 key 的值：<code>GET test1</code></li>
<li>返回 key 中字符串值的子字符：<code>GETRANGE test1 0 5</code></li>
<li>将给定 key 的值设为 value ，并返回 key 的旧值(old value)：<code>GETSET test1 &quot;this is test1.&quot;</code></li>
<li>对 key 所储存的字符串值，获取指定偏移量上的位(bit)：<code>GETBIT test1 10</code></li>
<li>获取所有(一个或多个)给定 key 的值：<code>MGET test test1</code></li>
<li>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)：<code>SETBIT test1 10 1</code></li>
<li>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)：<code>SETEX test1 120 &quot;this is test1&quot;</code></li>
<li>只有在 key 不存在时设置 key 的值：<code>SETNX test1 &quot;hello&quot;</code></li>
<li>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始：<code>SETRANGE test2 1 &quot;hahaha&quot;</code></li>
<li>返回 key 所储存的字符串值的长度：<code>STRLEN test2</code></li>
<li>同时设置一个或多个 key-value 对：<code>mset key &quot;2&quot; key2 &quot;this is &quot;</code></li>
<li>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在：<code>MSETNX ke2 &quot;test&quot; key &quot;haha&quot;</code></li>
<li>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间：<code>PSETEX key 120000 &quot;this &quot;</code></li>
<li>将 key 中储存的数字值增一：<code>INCR key</code></li>
<li>将 key 所储存的值加上给定的增量值（increment）：<code>INCRBY ke2 34</code></li>
<li>将 key 中储存的数字值减一：<code>DECR ke2</code></li>
<li>key 所储存的值减去给定的减量值（decrement） ：<code>DECRBY ke2 3</code></li>
<li>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾：<code>APPEND key &quot;end&quot;</code></li>
</ul>
<h3 id="HASH相关命令"><a href="#HASH相关命令" class="headerlink" title="HASH相关命令"></a>HASH相关命令</h3><ul>
<li>删除一个或多个哈希表字段：<code>HDEL testhash object</code></li>
<li>查看哈希表 key 中，指定的字段是否存在：<code>HEXISTS testhash2 bug</code></li>
<li>获取存储在哈希表中指定字段的值：<code>HGET testhash2 age</code></li>
<li>获取在哈希表中指定 key 的所有字段和值：<code>HGETALL testhash2</code></li>
<li>为哈希表 key 中的指定字段的整数值加上增量 increment ：<code>HINCRBY testhash2 age 1</code></li>
<li>为哈希表 key 中的指定字段的浮点数值加上增量 increment ：<code>HINCRBYFLOAT testhash2 money 3.4</code></li>
<li>获取所有哈希表中的字段：<code>HKEYS testhash2</code></li>
<li>获取哈希表中字段的数量：<code>HLEN testhash2</code></li>
<li>获取所有给定字段的值：<code>HMGET testhash2 redis mysql age</code></li>
<li>同时将多个 field-value (域-值)对设置到哈希表 key 中：<code>HMSET testhash2 age 13 money 13.4 name lihua</code></li>
<li>将哈希表 key 中的字段 field 的值设为 value ：<code>HSET testhash2 redis good mysql bad rabbitmq bad</code>(也可以设置多个字段)</li>
<li>只有在字段 field 不存在时，设置哈希表字段的值:<code>HSETNX testhash2 tag &quot;null&quot;</code></li>
<li>获取哈希表中所有值:<code>HVALS testhash2</code></li>
<li>迭代哈希表中的键值对:<code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
</ul>
<h3 id="LIST相关命令"><a href="#LIST相关命令" class="headerlink" title="LIST相关命令"></a>LIST相关命令</h3><ul>
<li>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止：<code>BLPOP testlist2 10</code></li>
<li>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止：<code>BRPOP testlist2 10</code></li>
<li>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止：<code>BRPOPLPUSH testlist testlist5 10</code>（从尾部取出，插入到另一个列表的头部）</li>
<li>通过索引获取列表中的元素：<code>LINDEX testlist 3</code></li>
<li>在列表的元素前或者后插入元素：<code>LINSERT testlist AFTER test &quot;after&quot;</code></li>
<li>获取列表长度：<code>LLEN testlist</code></li>
<li>移出并获取列表的第一个元素：<code>LPOP testlist</code></li>
<li>将一个或多个值插入到列表头部：<code>LPUSH testlist &quot;hehe&quot; &quot;test222&quot;</code></li>
<li>将一个值插入到已存在的列表头部：<code>LPUSHX testlist1 &quot;hehe&quot; &quot;test222&quot;</code></li>
<li>获取列表指定范围内的元素：<code>LRANGE testlist 0 2</code></li>
<li>移除列表元素：<code>LREM testlist 0 &quot;haha&quot;</code></li>
<li>通过索引设置列表元素的值：<code>LSET testlist 0 &quot;this is test&quot;</code></li>
<li>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除：<code>LTRIM testlist 0 4</code></li>
<li>移除列表的最后一个元素，返回值为移除的元素：<code>RPOP testlist</code></li>
<li>移除列表的最后一个元素，并将该元素添加到另一个列表并返回：<code>RPOPLPUSH testlist testlist2</code>(头部插入)</li>
<li>在列表中添加一个或多个值：<code>RPUSH testlist &quot;test&quot; &quot;test2&quot;</code>(添加到尾部)</li>
<li>为已存在的列表添加值：<code>RPUSHX mylist &quot;test&quot;</code></li>
</ul>
<h3 id="SET相关命令"><a href="#SET相关命令" class="headerlink" title="SET相关命令"></a>SET相关命令</h3><ul>
<li>向集合添加一个或多个成员：<code>SADD myset &quot;123&quot; 3</code>（这里是多个成员，分别为字符串123和int 3）</li>
<li>获取集合的成员数：SCARD myset</li>
<li>返回第一个集合与其他集合之间的差异：<code>SDIFF myset myset1</code>(主要返回前面集合中的差异，后面集合元素不会返回)</li>
<li>返回给定所有集合的差集并存储在 destination 中：<code>SDIFFSTORE myset2 myset myset1</code></li>
<li>返回给定所有集合的交集：<code>SINTER myset myset2</code></li>
<li>返回给定所有集合的交集并存储在 destination 中：<code>SINTERSTORE myset3 myset myset2</code></li>
<li>判断 member 元素是否是集合 key 的成员：<code>SISMEMBER myset &quot;123&quot;</code></li>
<li>返回集合中的所有成员：<code>SMEMBERS myset1</code></li>
<li>将 member 元素从 source 集合移动到 destination 集合：<code>SMOVE myset2 myset1 &quot;3&quot;</code></li>
<li>移除并返回集合中的一个随机元素：<code>spop myset1</code></li>
<li>返回集合中一个或多个随机数：<code>SRANDMEMBER myset1 2</code></li>
<li>移除集合中一个或多个成员：<code>SREM myset1 &quot;haha&quot;</code></li>
<li>返回所有给定集合的并集：<code>SUNION myset myset1</code></li>
<li>所有给定集合的并集存储在 destination 集合中：<code>SUNIONSTORE myset4 myset myset1</code></li>
<li>迭代集合中的元素：<code>SSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
</ul>
<h3 id="有序集合相关命令"><a href="#有序集合相关命令" class="headerlink" title="有序集合相关命令"></a>有序集合相关命令</h3><ul>
<li>向有序集合添加一个或多个成员，或者更新已存在成员的分数：<code>ZADD myzset 1 &quot;test1&quot; 2 &quot;test2&quot;</code></li>
<li>获取有序集合的成员数：<code>ZCARD myzset</code></li>
<li>计算在有序集合中指定区间分数的成员数：<code>ZCOUNT myzset 0 2</code></li>
<li>有序集合中对指定成员的分数加上增量 increment：<code>ZINCRBY myzset 2 &quot;test2&quot;</code></li>
<li>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中：<code>ZINTERSTORE summyzset 2 myzset myzset2</code>(中间的数字2代表有两个set合并)</li>
<li>在有序集合中计算指定字典区间内成员数量：<code>ZLEXCOUNT myzset - +</code>(不清楚为啥)</li>
<li>通过索引区间返回有序集合指定区间内的成员：<code>ZRANGE myzset 0 -1 withscores</code>(withscores是表示将权一块显示出来，0代表排序的第一位，2代表排序集合的第三个元素)</li>
<li>通过字典区间返回有序集合的成员：<code>ZRANGEBYLEX myzset - +</code>(-号代表底，+号代表最高)</li>
<li>通过分数返回有序集合指定区间内的成员：<code>ZRANGEBYSCORE myzset (0 (2 withscores</code>(（代表不包含0，[代表包含,这里的分数就带代表权)</li>
<li>返回有序集合中指定成员的索引：<code>ZRANK myzset &quot;test1&quot;</code>(索引即时该元素在排序集合中的位置)</li>
<li>移除有序集合中的一个或多个成员：<code>ZREM myzset &quot;test1&quot;</code></li>
<li>移除有序集合中给定的字典区间的所有成员：<code>ZREMRANGEBYLEX myzset2 - +</code></li>
<li>移除有序集合中给定的排名区间的所有成员：<code>ZREMRANGEBYRANK myzset 0 0</code></li>
<li>移除有序集合中给定的分数区间的所有成员：<code>ZREMRANGEBYSCORE myzset 0 5</code> </li>
<li>返回有序集中指定区间内的成员，通过索引，分数从高到低：<code>ZREVRANGE myzset 0 -1 withscores</code></li>
<li>返回有序集中指定分数区间内的成员，分数从高到低排序：<code>ZREVRANGEBYSCORE myzset 100 0</code>(也存在根据字典区间的命令)</li>
<li>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序：<code>ZRANK myzset lisi</code>(查询lisi在有序集合中的排名)</li>
<li>返回有序集中，成员的分数值：<code>ZSCORE myzset lisi</code></li>
<li>计算给定的一个或多个有序集的并集，并存储在新的 key 中：<code>ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3</code>(看不懂)</li>
<li>迭代有序集合中的元素（包括元素成员和元素分值）：<code>ZSCAN site 0 match &quot;R*&quot;</code></li>
</ul>
<h3 id="HyperLogLog相关命令"><a href="#HyperLogLog相关命令" class="headerlink" title="HyperLogLog相关命令"></a>HyperLogLog相关命令</h3><p>​    redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在Redis里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。但是HyperLogLog 只会计算基数，不会存储元素本身。</p>
<ul>
<li>添加指定元素到 HyperLogLog 中：<code>PFADD mypf &quot;redis&quot;</code>(后面可以跟多个元素，元素可以不带引号，存储的都是字符串类型)</li>
<li>返回给定 HyperLogLog 的基数估算值：<code>PFCOUNT mypf</code></li>
<li>将多个 HyperLogLog 合并为一个 HyperLogLog：<code>PFMERGE mypf3 mypf mypf2</code></li>
</ul>
<h3 id="发布订阅相关命令"><a href="#发布订阅相关命令" class="headerlink" title="发布订阅相关命令"></a>发布订阅相关命令</h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道。</p>
<ul>
<li>订阅一个或多个符合给定模式的频道：<code>PSUBSCRIBE testchannel</code>(后面参数类似于正则表达式)</li>
<li>查看订阅与发布系统状态：<code>PUBSUB channels</code>(目前不清楚用法，现在参数固定)</li>
<li>将信息发送到指定的频道：PUBLISH testchannel “this is test”</li>
<li>退订所有给定模式的频道：PUNSUBSCRIBE mychannel </li>
<li>订阅给定的一个或多个频道的信息：SUBSCRIBE testchannel</li>
<li>指退订给定的频道：UNSUBSCRIBE mychannel</li>
</ul>
<h3 id="Redis中的事务-1"><a href="#Redis中的事务-1" class="headerlink" title="Redis中的事务"></a>Redis中的事务</h3><ul>
<li>取消事务，放弃执行事务块内的所有命令:<code>DISCARD</code></li>
<li>执行所有事务块内的命令:<code>EXEC</code></li>
<li>标记一个事务块的开始:<code>MULTI</code>（连续执行两次multi不会导致事务回滚）</li>
<li>取消 WATCH 命令对所有 key 的监视:UNWATCH（使用方法是在watch前面，并不是在事务中取消监视，而是在监视前取消所有的其他监视，所以只要调用了watch，key被修改，就会出错。只是为了完善redis事务的一个点）</li>
<li>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断:<code>WATCH lock</code>（在multi里面执行watch不会导致事务回滚。）</li>
</ul>
<h2 id="Redis在SpringBoot中的应用"><a href="#Redis在SpringBoot中的应用" class="headerlink" title="Redis在SpringBoot中的应用"></a>Redis在SpringBoot中的应用</h2><h2 id="Redis实际中的应用和解决方案"><a href="#Redis实际中的应用和解决方案" class="headerlink" title="Redis实际中的应用和解决方案"></a>Redis实际中的应用和解决方案</h2><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>​    对于一些设置了过期时间的key，如果这个key可能会在某些时间点被超高并发地访问，是一个热点数据，当这个key过期后，这个时间点有大量并发去请求这个key，该key没有命中，大量的请求穿透到数据库服务器。</p>
<p>​    解决方案：有两种方案，1）将热点数据设置永不过期。2）使用互斥锁：先从redis获取数据，如果redis中数据没有，去争夺锁，拿到锁的线程去查询数据库，然后见过结果放入redis中。其他没抢到的，等一段时间，再执行查询等方法，重新从redis中获取数据。锁是需要按照key 维度去加锁。例如akey的锁不能影响其他key的查询。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>​    大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<p>​    解决方案：1）可以给缓存时间加上一个随机偏移量，例如一个小时的缓存时间，可以将这个时间再10分钟内随机，将失效时间平均到10分钟内。2）和上面的缓存击穿一样，加一个互斥锁，减少数据库的访问次数。3）设置热点数据永不过期，需要考虑数据的同步时间间隔和数据异常的处理情况。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>​    访问一个一定不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。因为查不到数据，所以后续的查询仍然会请求数据库。</p>
<p>​    解决方案有以下：1）如果是大量的不存在的key，可以认为是受到的攻击，可以在最外层做一层过滤。2）当数据库查询的结果为空时，可以将这个null结果做个缓存，设置一个较短的过期时间。当查询的key都是不存在的时候且不重复，这个作用也是比较小的。3）布隆过滤器。</p>
<h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>​    有一个bitset集合，还有一组hash算法，将一个key通过这组hash算法计算得到一组下标。将bitset中这组下标的位置设置为true，如果一个key通过这样的计算，得到的一组下标的位置不全为true，则这个key一定不存在，当都是true时，这个key可能存在。降低误判率也有方法：增大bitset集合的长度，增多hash算法，得到更多的下标。一般是增加长度，因为长度如果过短的话，增加hash算法其实意义不大。</p>
<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>​    当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。</p>
<p>​    解决方法：更新数据库后，直接让缓存失效。</p>
<h3 id="面试中遇到的问题"><a href="#面试中遇到的问题" class="headerlink" title="面试中遇到的问题"></a>面试中遇到的问题</h3><ul>
<li>项目中什么地方用到redis，为什么使用redis？</li>
</ul>
<p>我们项目中redis的主要作用就是存储设备点位的信息，主要是存储设备当前状态的值，还有就是用户的token信息也是存储在redis中。当然，项目中还有一些其他的地方我没有涉及，可能这部分的信息也有存储在redis中的需求。因为项目是在我来公司之前成立的，所以技术的选型我并没有参与，对于选用redis并不知道当时出于什么考虑。我们redis使用的是单机服务，对于我们的项目来说可能够用了，但是并没有考虑到高可用，小公司对于技术的优化可能没有强烈的需求，我也是在私下会对这部分有个了解。我对于公司的redis优化的思路是采用哨兵模式进行高可用的优化。因为单机模式会存在宕机的可能，集群模式主要是为了应对单个服务器无法存储全部的数据的情况，所以我认为哨兵模式对于我们的项目来说比较适合。后面就介绍一下哨兵模式的一些特点和搭建中遇到的问题。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E5%8D%8F%E8%AE%AE/HTTP/HTTP%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<p>最近工作中用到了HTTP，想了解一下，所以看了《图解HTTP》，下面的内容相当于读书笔记。作为记录，省的后面又忘记，先后顺序按照阅读顺序。</p>
<ul>
<li><p>1.三项构建WWW的技术。</p>
<ul>
<li>“把SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；</li>
<li>作为文档传递协议的 HTTP ；</li>
<li>指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）”</li>
</ul>
</li>
<li><p>2.“TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。” </p>
<ul>
<li>“应用层决定了向用户提供应用服务时通信的活动。”  </li>
<li>“传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。”  </li>
<li>“网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。”    </li>
<li>“链路层用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。”</li>
</ul>
</li>
<li><p>3.三次握手<br>  “发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。”</p>
</li>
<li><p>4.DNS服务<br>“DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。”</p>
</li>
<li><p>5.URI和URL的区别<br>  “URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。”</p>
</li>
<li><p>6.HTTP/1.1中的方法</p>
<ul>
<li>“GET ：获取资源” “GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。”</li>
<li>“POST：传输实体主体” “POST 方法用来传输实体的主体。”</li>
<li>PUT：传输文件 “PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。”</li>
<li>“HEAD：获得报文首部” “HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。”</li>
<li>DELETE：删除文件 “DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。”</li>
<li>“OPTIONS：询问支持的方法”  “OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。”</li>
<li>TRACE：追踪路径 “TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。”</li>
<li> “CONNECT：要求用隧道协议连接代理” “CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。”</li>
</ul>
</li>
<li><p>7.“持久连接节省通信量”</p>
<ul>
<li>持久连接 “为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。”</li>
<li>管线化 “持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。”</li>
</ul>
</li>
<li><p>8.cookie<br>  “HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。”<br>  “Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。”</p>
</li>
<li><p>9.报文首部结构</p>
<ul>
<li>“请求行 包含用于请求的方法，请求 URI 和 HTTP 版本。</li>
<li>状态行 包含表明响应结果的状态码，原因短语和 HTTP 版本。    </li>
<li>首部字段 包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li>
<li>其他 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。”</li>
</ul>
</li>
<li><p>10.报文主体和实体主体的区别</p>
<ul>
<li>“报文（message）是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。</li>
<li>实体（entity）作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。”</li>
<li>“HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。”</li>
<li>报文主体相当于实际内容，实体主体相当于01数据，实体主体因为传输问题有可能被压缩，所以当编码操作后，实体主体可能会和报文主体不一致。</li>
</ul>
</li>
<li><p>11.“多部分对象集合包含的对象”</p>
<ul>
<li>multipart/form-data 在 Web 表单文件上传时使用。</li>
<li>multipart/byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。</li>
</ul>
</li>
<li><p>12.常用的14种状态码</p>
<ul>
<li>200 OK “表示从客户端发来的请求在服务器端被正常处理了。”</li>
<li>204 No Content “该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。”</li>
<li>206 Partial Content “该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。”</li>
<li>301 Moved Permanently “永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。”</li>
<li>302 Found “临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。”</li>
<li>303 See Other “该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。”</li>
<li>304 Not Modified “该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。”</li>
<li>307 Temporary Redirect “临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。”</li>
<li>400 Bad Request “该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。”</li>
<li>401 Unauthorized “该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。”</li>
<li>403 Forbidden “该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。”</li>
<li>404 Not Found “该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。” </li>
<li>500 Internal Server Error “该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。”</li>
<li>503 Service Unavailable “该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。”</li>
</ul>
</li>
<li><p>13.通信数据转发程序</p>
<ul>
<li>“代理。代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。”</li>
<li>“网关。网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。”</li>
<li>“隧道。隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。”</li>
</ul>
</li>
<li><p>14.“4 种 HTTP 首部字段类型”</p>
<ul>
<li>“通用首部字段（General Header Fields）请求报文和响应报文两方都会使用的首部。”</li>
<li>“请求首部字段（Request Header Fields）从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。”</li>
<li>“响应首部字段（Response Header Fields）从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。”</li>
<li>“实体首部字段（Entity Header Fields）针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。”</li>
</ul>
</li>
<li><p>15.HTTP/1.1 首部字段</p>
<ul>
<li>通用首部字段<ul>
<li>“Cache-Control通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。”<ul>
<li> “public 指令。当指定使用 public 指令时，则明确表明其他用户也可利用缓存。”</li>
<li> “private指令。当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。”</li>
<li> “no-cache指令。使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。”</li>
<li> “no-store 指令。当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。”</li>
<li> “s-maxage 指令。s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。”</li>
<li> “max-age指令。当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。”</li>
<li> “min-fresh指令。min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。”</li>
<li> “max-stale 指令。使用 max-stale 可指示缓存资源，即使过期也照常接收。”</li>
<li> “only-if-cached 指令。使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。”</li>
<li> “must-revalidate 指令。使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。”</li>
<li> “proxy-revalidate 指令。proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。”</li>
<li> no-transform 指令。“使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。”</li>
</ul>
</li>
<li>Connection 首部字段具备如下两个作用。<ul>
<li>控制不再转发给代理的首部字段。“在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。”</li>
<li>管理持久连接。“HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。”</li>
</ul>
</li>
<li>“Datte首部字段,Date表明创建HTTP报文的日期和时间。”</li>
<li>“Pragma首部字段。Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。”</li>
<li>“Trailer首部字段。Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。”</li>
<li>“Transfer-Encoding首部字段 。Transfer-Encoding 规定了传输报文主体时采用的编码方式。”</li>
<li>“Upgrade首部字段。Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。”</li>
<li>“Via首部字段。Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。”</li>
<li>“Warning首部字段。HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。”<ul>
<li>“110    Response is stale（响应已过期）代理返回已过期的资源</li>
<li>111    Revalidation failed（再验证失败）代理再验证资源有效性时失败（服务器无法到达等原因）</li>
<li>112    Disconnection operation（断开连接操作）代理与互联网连接被故意切断</li>
<li>113    Heuristic expiration（试探性过期）响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</li>
<li>199    Miscellaneous warning（杂项警告）任意的警告内容</li>
<li>214    Transformation applied（使用了转换）代理对内容编码或媒体类型等执行了某些处理时</li>
<li>299    Miscellaneous persistent warning（持久杂项警告）任意的警告内容”</li>
</ul>
</li>
</ul>
</li>
<li><pre><code>请求首部字段      * Accept首部字段。“Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。”      * Accept-Charset首部字段。“Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。”      * Accept-Encoding首部字段。“Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。”      * Accept-Language首部字段。“首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。”      * Authorization首部字段。“首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。”      * Expect首部字段。“客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。”      * From首部字段。“首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。”      * Host首部字段。“首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。”      * If-Match首部字段。“形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。”      * If-Modified-Since首部字段。“首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。”      * If-None-Match首部字段。“首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。”      * If-Range首部字段。“首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。”      * If-Unmodified-Since首部字段。“首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。”      * Max-Forwards首部字段。“通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。”      * Proxy-Authorization首部字段。“接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。”      * “Range首部字段。对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。”      * Referer首部字段。“首部字段 Referer 会告知服务器请求的原始资源的 URI。”      * “TE首部字段。首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。”      * User-Agent首部字段。“首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。”
</code></pre>
</li>
<li>响应首部字段<ul>
<li>Accept-Ranges首部字段。“首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。”</li>
<li>Age首部字段。“首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。”</li>
<li>ETag首部字段。“首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。”</li>
<li>Location首部字段。“使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。”</li>
<li>“Proxy-Authenticate首部字段。首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。”</li>
<li>Retry-After首部字段。“首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。”</li>
<li>Server首部字段。“首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。”</li>
<li>Vary首部字段。“首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。”</li>
<li>WWW-Authenticate首部字段。“首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。”</li>
</ul>
</li>
<li>实体首部字段<ul>
<li>Allow首部字段。“首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。”</li>
<li>Content-Encoding首部字段。“首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。”</li>
<li>Content-Language首部字段。“首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。”</li>
<li>Content-Length首部字段。“首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。”</li>
<li>Content-Location首部字段。“首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。”</li>
<li>Content-MD5首部字段。“首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。”</li>
<li>Content-Range首部字段。“针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。”</li>
<li>Content-Type首部字段。“首部字段 Content-Type 说明了实体主体内对象的媒体类型。”</li>
<li>Expires首部字段。“首部字段 Expires 会将资源失效的日期告知客户端。”</li>
<li>Last-Modified首部字段。“首部字段 Last-Modified 指明资源最终修改的时间。”</li>
</ul>
</li>
<li>为 Cookie 服务的首部字段<ul>
<li>Set-Cookie首部字段。“开始状态管理所使用的Cookie信息”，属于响应首部字段。<ul>
<li>“expires 属性。Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。”</li>
<li>“path 属性。Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。”</li>
<li>“domain 属性。通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。”</li>
<li>“secure 属性。Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。”</li>
<li>“HttpOnly 属性。Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。”</li>
</ul>
</li>
<li>Cookie首部字段。“服务器接收到的Cookie信息”，属于请求首部字段。<ul>
<li>Cookie首部字段。“首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。”</li>
</ul>
</li>
</ul>
</li>
<li>其他首部字段<ul>
<li>X-Frame-Options首部字段。“首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。”<ul>
<li>“DENY ：拒绝</li>
<li>SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。”</li>
</ul>
</li>
<li>“X-XSS-Protection首部字段。首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。”<ul>
<li>0 ：将 XSS 过滤设置成无效状态</li>
<li>1 ：将 XSS 过滤设置成有效状态</li>
</ul>
</li>
<li>“DNT首部字段。首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。”<ul>
<li>0 ：同意被追踪</li>
<li>1 ：拒绝被追踪</li>
</ul>
</li>
<li>“P3P首部字段。首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。”</li>
</ul>
</li>
</ul>
</li>
<li><p>16.HTTPS</p>
<ul>
<li>“HTTP+ 加密 + 认证 + 完整性保护 =HTTPS”</li>
<li>“HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。”</li>
<li>“使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。”（公钥进行加密，收到数据的一方使用自己的私钥将加密的数据解密。客户端使用公钥加密数据，服务器使用私钥解密。）</li>
<li>“HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。”</li>
</ul>
</li>
<li><p>17.HTTPS通信步骤  </p>
<ul>
<li>“步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li>
<li>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li>
<li>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li>
<li>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</li>
<li>“步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li>
<li>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</li>
<li>步骤 7：客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li>
<li>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</li>
<li>步骤 9： 服务器同样发送 Finished 报文。</li>
<li>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</li>
<li>步骤 11： 应用层协议通信，即发送 HTTP 响应。</li>
<li>“步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。”</li>
</ul>
</li>
<li><p>18.“Cookie 来管理 Session”</p>
<ul>
<li>步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li>
<li>步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。</li>
<li>“步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。”</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>协议</category>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Dubbo%E6%A1%86%E6%9E%B6/Dubbo%E7%AE%80%E5%8D%95Demo%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="Dubbo简单Demo搭建"><a href="#Dubbo简单Demo搭建" class="headerlink" title="Dubbo简单Demo搭建"></a>Dubbo简单Demo搭建</h2><p>​    上一篇博客简单介绍了一下Dubbo的一些背景，这一篇博客就开始上手一个简单Demo，只有成功的跑起来，才有继续学下去的动力，一直看资料多乏味啊。</p>
<h3 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h3><p>​    Dubbo是使用注册中心来注册服务和发现服务的。上一篇博客里面也有一个Dubbo结构图。挺形象的。Dubbo支持很多种注册中心，Nacos、Zookeeper、Multicast、Redis、Simple。官方推荐Zookeeper注册中心，我们这里也是搭建一个Zookeeper集群。其他的注册中心大家可以去官网了解一下。</p>
<p>​    Zookeeper的搭建因为之前学习过Docker，我这里直接就看了官方的文档，参考写了一个Compose文件，直接启动，下载镜像就可以了，很简单，也不需要很复杂的安装很多东西。这里贴上Compose文件，大家直接运行<code>docker-compose -f dubbo-compose.yml up -d</code>即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo1:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-net</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo2:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-net</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo3:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-net</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-net</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://zoo1:2181?backup=zoo2:2181,zoo3:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://zoo1:2181?backup=zoo2:2181,zoo3:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://zoo1:2181?backup=zoo2:2181,zoo3:2181</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zoo1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zoo2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zoo3</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-net</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>​    关于Zookeeper的一些知识后面有机会再学习吧，这一块感觉还挺有意思的。</p>
<h3 id="搭建监控中心"><a href="#搭建监控中心" class="headerlink" title="搭建监控中心"></a>搭建监控中心</h3><p>​    可以看到上面不止启动了一个容器，还有一个dubbo-admin的镜像，这个镜像就是dubbo的管理平台，但是它的界面是这个样子。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210824224955559.png" alt="image-20210824224955559"></p>
<p>​    和我最开始接触老版的管理界面不一样，老版的页面看GitHub上已经不再更新了，界面如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210824225323418.png" alt="image-20210824225323418"></p>
<p>​    这个监控平台也很好弄，从官网下载老版代码，修改对应的配置，然后直接<code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar </code>即可。地址如下：<a href="https://github.com/apache/dubbo-admin/tree/master-0.2.0">老版监控平台代码仓库</a>。</p>
<p>​    需要注意，配置文件修改Zookeeper地址时，修改为如下形式。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">dubbo.registry.address=zookeeper://127.0.0.1:2181?backup=127.0.0.1:2181,127.0.0.1:2181</span></span><br></pre></td></tr></table></figure>

<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>​    先说一下项目的构成。是一个maven项目，里面有三个子模块，分别是API、生产者和消费者。结构图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210824230320055.png" alt="image-20210824230320055"></p>
<ul>
<li>API模块：如果生产者需要被多个消费者调用，接口在这些项目中粘贴也不太好，这里将接口定义在API模块中，这样，其他项目直接倒入依赖就可以了，你还可以将这个API打包到你的本地maven仓库。</li>
<li>consumer模块：就是消费者模块，和前端交互的模块。</li>
<li>provider模块：生产者模块，业务的主要实现的地方，例如数据库的查询就是在这个模块。</li>
</ul>
<p>​    父pom文件如下：因为用到的东西比较少，所以依赖不是很多。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.psq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-exercise<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-exercise<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-service-provider<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-service-consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-service-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  个人写代码方便，实际开发不推荐      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   SpringBoot依赖  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者代码编写"><a href="#生产者代码编写" class="headerlink" title="生产者代码编写"></a>生产者代码编写</h3><p>​    生产者先说pom依赖，如果你导入的是阿里的Dubbo依赖，不需要再导入其他依赖了，但是如果你导入的是apache的Dubbo依赖，你需要再根据你使用的注册中心再导入一个依赖，我这里需要再导入一个zookeeper的依赖，pom文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-exercise<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.psq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  API依赖      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.psq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-service-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 导入这个依赖就不需要再导入其他依赖了 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;0.2.0&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  下面是导入apacheDubbo的方式     --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    生产者还需要再配置一些Dubbo的配置，配置文件代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-service-provider</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-service-provider</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">20880</span></span><br><span class="line">  <span class="attr">scan:</span></span><br><span class="line">    <span class="attr">base-packages:</span> <span class="string">com.psq.dubbboserviceprovider.server</span></span><br></pre></td></tr></table></figure>

<p>​    需要注意你的applicationname不能和消费者一样，最好这个服务唯一，多个相同生产者相同。zookeeper需要注意集群的配置形式，其他的配置也可以看看官方的文档。如下：<a href="https://dubbo.apache.org/zh/docs/references/xml/dubbo-registry/">Dubbo官方配置文档</a>。</p>
<p>​    这里只是简单demo，就打印一个hello world吧，一个接口，只是返回一个字符串。API的接口代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.dubboserviceapi.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * com.psq.dubboserviceapi.service.SayHelloService.java</span></span><br><span class="line"><span class="comment"> * Description: 示例接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SayHelloService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description:示例方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2021-08-15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.dubbboserviceprovider.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.dubboserviceapi.service.SayHelloService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * com.psq.dubbboserviceprovider.server.SayHelloServiceImpl.java</span></span><br><span class="line"><span class="comment"> * Description: SayHelloServiceImpl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">SayHelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This dubbo test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    需要注意这里的service注解不是spring的注解。是Dubbo的注解。</p>
<h3 id="消费者代码编写"><a href="#消费者代码编写" class="headerlink" title="消费者代码编写"></a>消费者代码编写</h3><p>​    消费者代码相差不多，pom文件和生产者类似，除了多了一个webstarter，这里就不再贴上代码了。</p>
<p>​    配置文件代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-service-consumer</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-service-consumer</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">20881</span></span><br></pre></td></tr></table></figure>

<p>​    需要注意不要和你的监控中心端口冲突。其他就没有需要注意的了。</p>
<p>​    这里就简单写一个http请求接口，直接访问生产者的代码，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.dubboserviceconsumer.controlle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.dubboserviceapi.service.SayHelloService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SayHelloController.java</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> SayHelloService sayHelloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sayHello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = sayHelloService.sayHello();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    启动两个服务后，访问地址：<a href="http://localhost:8081/sayHello%E5%87%BA%E7%8E%B0%E4%BB%A5%E4%B8%8B%E7%94%BB%E9%9D%A2%E5%8D%B3%E4%BB%A3%E8%A1%A8%E8%B0%83%E7%94%A8%E6%88%90%E5%8A%9F%EF%BC%8C%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E4%B9%9F%E4%BC%9A%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84%E8%AE%B0%E5%BD%95%E3%80%82">http://localhost:8081/sayHello出现以下画面即代表调用成功，监控中心也会有对应的记录。</a></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210824232818441.png" alt="image-20210824232818441"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210824232906127.png" alt="image-20210824232906127"></p>
<p>​    至此，Dubbo的简单Demo就完成了，后续会慢慢补充一下配置的相关信息和对于Dubbo底层的学习。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Dubbo框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Dubbo%E6%A1%86%E6%9E%B6/Dubbo%E8%83%8C%E6%99%AF%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Dubbbo背景了解"><a href="#Dubbbo背景了解" class="headerlink" title="Dubbbo背景了解"></a>Dubbbo背景了解</h2><p>​    最近有时间了，同时工作中用到了Dubbo，所以后面慢慢会写一些相关的博客。</p>
<p>​    作为一个技术，我认为最开始的学习要先了解其背景，知道这项技术为什么产生，我们项目中为什么使用这项技术，以及这项技术的优点在什么地方。其实这个在面试中也会经常问到。知道这些后，才能在项目技术选择中更加游刃有余。不多说了，直接开始吧。</p>
<p>​    这一部分知识其实来源于Dubbo的官网，大家也可以在官网上直接查看，我一直认为官方文档应该是第一手参考资料。</p>
<p>​    官网地址：<a href="https://dubbo.apache.org/zh/">dubbo官网</a></p>
<h3 id="网站应用演进"><a href="#网站应用演进" class="headerlink" title="网站应用演进"></a>网站应用演进</h3><p>​        网站其实是按照用户量来慢慢演进的。最开始用户少，只有几百个用户，所以简单的单体应用就能满足需求，这里和我们平时编写的练手项目相差不多。</p>
<p>​    但是随着用户慢慢增多，单体应用不再满足我们的需求，需要将应用按照业务拆分开来，即将不相关的业务拆分成不同的项目，部署在不同的机器上。</p>
<p>​    但是这种情况比较特殊，只适合特定的几个情况，大多数的业务都是有一定依赖条件的。这个时候就产生了远程过程调用（RPC），Dubbo就是一种RPC框架。这种框架能够自动注册到中心，发现需要的服务并且调用。这样，我们就能够在不同的机器上跑业务相关的代码了。</p>
<p>​    其实这一阶段基本在用户层面就已经满足了，随着用户的增多，只需要增加服务基本就能满足需求了。但是在我们的角度来看，仍然不是很好，因为不同的业务访问量是不一样的，所以如何让资源随着访问量动态的变化就显得极为重要。这个也是网站演进的下一步：流动计算架构。这里了解不多，不再现眼了。</p>
<p>​    以上都是个人的理解，可能部分地方有出入，还希望大佬们指正。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210823231313441.png" alt="image-20210823231313441"></p>
<h3 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h3><p>​    看完了上面关于网站架构的演进，下面我们就来说一下Dubbo是什么。</p>
<pre><code> Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。

 这个是百度百科上面找到的解释。可以看到Dubbo是一个能够无缝整合到spring中的rpc框架。它能够提供服务的发现，服务的调用和服务的负载均衡。

 说白了，就相当于一个中间件，能够让我们的消费者（相当于业务调用方，有点类似于mvc中controller）调用消费者（业务实现方，有点类似于controller调用的service）。当然消费者可以和生产者不在同一台机器上，这就要做到服务的发现。最后的负载均衡就是服务调用的优化，让每一个消费者的调用频率相差不多（消费者权值相同的情况下）。
</code></pre>
<h3 id="Dubbo解决了什么问题"><a href="#Dubbo解决了什么问题" class="headerlink" title="Dubbo解决了什么问题"></a>Dubbo解决了什么问题</h3><p> Dubbo解决了什么问题呢？对于不同服务的调用，我编写http服务，传json也可以达到类似的效果。这就要说到Dubbo的优点了。</p>
<ul>
<li>Dubbo是面向代理的高性能RPC调用。我们自己编写的http调用能够满足一些对性能要求不高的接口，但是如果某个接口对性能要求比较高，我们编写的代码就显得很吃力了。Dubbo毕竟是阿里出的，性能这一块肯定要比我们自己的强（大佬除外）。所以我认为Dubbo基本满足了大部分项目的需求。</li>
<li>服务的自动注册发现。我们服务少还好说，我们甚至可以将服务的地址写到代码中或者做成配置文件，但是服务多了后，这个代码或者配置文件就显得臃肿，而且有些服务挂掉后，及时的更新配置文件也是我们要考虑的问题。Dubbo也是能够自动的注册服务，并且发现自己需要的服务，在某些服务挂掉后，也能够及时的更新。</li>
<li>我们自己编写的服务调用对于每次的调用很难监控起来，多数情况下，我们自己的监控系统考虑的情况都是比较少的。但是随着业务的增长，这一部分无法监控的地方也是格外重要，例如：什么时间段访问量增多，哪个服务的调用最多，哪个服务调用的最少。我们根据这些监控信息来达到对不同服务的定制化维护，减少资源的消耗和对系统峰值的把控。</li>
<li>扩展能力。Dubbo里面有很多的扩展点，所有核心能力如Protocol、Transport、Serialization都被设计为扩展点，可以达到自己系统独特的定制效果。（目前这一块了解较少）</li>
</ul>
<h3 id="Dubbo的一些基础结构"><a href="#Dubbo的一些基础结构" class="headerlink" title="Dubbo的一些基础结构"></a>Dubbo的一些基础结构</h3><p> 看了Dubbo的背景，了解了Dubbo是什么东西，并且知道了Dubbo解决了什么问题后，我们就可以看看Dubbo的基础结构。我一直认为学技术要总体的看一遍这个技术，知道各个部分大概是什么东西，代表了什么意思，再去扣细节比较容易理解。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210823231413386.png" alt="image-20210823231413386"></p>
<p> Dubbo分为五个大块，生产者、消费者、注册中心、监控中心、运行容器。</p>
<ul>
<li><p>Provider：服务的提供方。一般是我们代码的实现部分，例如查询数据库的操作。</p>
</li>
<li><p> Consumer：服务的消费方，消费生产者提供的服务。一般和web层交互的一方。</p>
</li>
<li><p>Registry：注册中心，一般是zookeeper，只提供服务的注册和发现，不对请求做转发。</p>
</li>
<li><p>Monitor：监控中心，独立的服务或者应用，是否启动和是否正常不对系统整体有影响，只是对每次的调用做记录和统计。</p>
</li>
<li><p>Container：运行容器，负责启动、加载、运行生产者的服务。</p>
</li>
</ul>
<p>​    概念其实不难理解，后面上手代码的时候也会发现这些东西很容易就明白了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    这片博客简单的介绍了Dubbo的历史背景，解决了什么问题，以及Dubbo的一些基础的结构。没有经历过网站用户量的增长过程，所以对于这些背景都是看过，没有实际接触过。也算是一个遗憾吧，不知道自己经历了这些场景，会不会有一些不一样的想法。</p>
<p>​    下一篇博客会简单的写一个Dubbo的例子，从搭建注册中心和监控中心开始，一直到写一个Hello world的例子为止。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Dubbo框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/SpringBoot%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="SpringBoot使用事务"><a href="#SpringBoot使用事务" class="headerlink" title="SpringBoot使用事务"></a>SpringBoot使用事务</h2><p>​    上次了解了MySQL的事务概念，下面就开始编写代码来实际理解一下概念。</p>
<p>​    配置上面没有什么新加的配置，使用的数据库是MySQL，集成的Mybatis。按照之前的博客配置就可以了，这里不再累述。下面就直接上代码。然后说一下遇到的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.mysql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.support.SqlSessionDaoSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransactionalTrain.java</span></span><br><span class="line"><span class="comment"> * Description: SpringBoot数据库事务练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalTrain</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mybatisTransactionalTrain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">false</span>);</span><br><span class="line">        TestUser testUser = <span class="keyword">new</span> TestUser();</span><br><span class="line">        testUser.setId(<span class="number">3</span>);</span><br><span class="line">        testUser.setName(<span class="string">&quot;qsp&quot;</span>);</span><br><span class="line">        testUser.setPassword(<span class="string">&quot;87654321&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer saveResult = sqlSession.insert(<span class="string">&quot;com.psq.train.dao.UserMapper.insertUser&quot;</span>, testUser);</span><br><span class="line">            <span class="comment">//重复插入，id相同一定回产生异常</span></span><br><span class="line">            Integer saveResult2 = sqlSession.insert(<span class="string">&quot;com.psq.train.dao.UserMapper.insertUser&quot;</span>, testUser);</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;事务开始回滚&quot;</span>);</span><br><span class="line">            sqlSession.rollback();</span><br><span class="line">            System.err.println(<span class="string">&quot;事务回滚成功&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    首先是<code>SqlSessionFactory</code>的注入，因为Mybatis取消了<code>SqlSessionFactory</code>的自动注入，所以这里需要继承一下<code>SqlSessionDaoSupport</code>，再重写一下<code>setSqlSessionFactory</code>方法。后面其他方法就可以使用一下代码正常注入了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br></pre></td></tr></table></figure>

<p>​    下面就是逻辑代码的堆叠了，需要注意的就是<code>sqlSessionFactory.openSession(false);</code>的意思是关闭自动提交，这样就可以测试事务了。然后就是插入两个主键相同的列，第一个可以正常插入，第二个因为逐渐相同会插入失败，导致异常，捕获异常后执行<code>sqlSession.rollback();</code>就可以回滚了。这里也有一个地方，执行<code>sqlSession.close();</code>的时候也会执行回滚，通过看源码的时候可以发现最后是执行了回滚操作的。</p>
<p>​    然后问题就来了，这里我尝试了很多次，事务回滚一直没有执行成功，数据库中最后仍然是一条数据。排查了很多的地方还是不行，这里也希望大神能够指导一下。</p>
<p>​    最后没有办法，只能通过Spring来实现事务。</p>
<p>​    Spring中的事务管理分为编程式事务管理和声明式事务管理。编程式事务管理现在使用的已经很少了，现在大部分都是声明式事务管理。我这里也是通过注解的形式来实现事务的管理。上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.mysql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.train.dao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringTransactionalTrain.java</span></span><br><span class="line"><span class="comment"> * Description:  使用Spring来管理事务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransactionalTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mybatisTransactionalTrain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestUser testUser = <span class="keyword">new</span> TestUser();</span><br><span class="line">        testUser.setId(<span class="number">3</span>);</span><br><span class="line">        testUser.setName(<span class="string">&quot;psq&quot;</span>);</span><br><span class="line">        testUser.setPassword(<span class="string">&quot;9876&quot;</span>);</span><br><span class="line">        System.err.println(testUser.toString());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer saveResult = userMapper.insertUser(testUser);</span><br><span class="line">            System.err.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">            <span class="comment">//一定会报异常</span></span><br><span class="line">            Integer saveResult2 = userMapper.insertUser(testUser);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">            System.err.println(<span class="string">&quot;开始回滚&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过controller层的调用，controller层代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.train.dao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.psq.train.mysql.SpringTransactionalTrain;</span><br><span class="line"><span class="keyword">import</span> com.psq.train.mysql.TestUser;</span><br><span class="line"><span class="keyword">import</span> com.psq.train.mysql.TransactionalTrain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransactionalController.java</span></span><br><span class="line"><span class="comment"> * Description:  controller类，用于测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SpringTransactionalTrain springTransactionalTrain;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saveTestUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        springTransactionalTrain.mybatisTransactionalTrain();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    按照上面的代码，事务就可以正常回滚。数据库中就没有新插入的记录。    </p>
<p>​    下面就简单说一下spring中的事务的一些信息。</p>
<ul>
<li>事务的传播行为<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是Spring默认的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。</li>
</ul>
</li>
<li>事务的实现方式<ul>
<li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li>
<li>基于 TransactionProxyFactoryBean的声明式事务管理。</li>
<li>基于 @Transactional 的声明式事务管理。</li>
<li>基于Aspectj AOP配置事务。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88Elasticsearch/</url>
    <content><![CDATA[<h2 id="SpringBoot整合Elasticsearch"><a href="#SpringBoot整合Elasticsearch" class="headerlink" title="SpringBoot整合Elasticsearch"></a>SpringBoot整合Elasticsearch</h2><p>​    又是项目优化，之前的ES整合的版本因为太老了，所以想换成新的，顺带看看有没有什么新的写法。直接开整吧。</p>
<p>​    最开始其实需要先介绍一下Spring Data，Spring Data的任务是为数据访问提供一个熟悉且一致的，基于Spring的编程模型，同时仍保留基础数据存储的特殊特征。它使使用数据访问技术，关系和非关系数据库，map-reduce框架以及基于云的数据服务变得容易。这是一个总括项目，其中包含许多特定于给定数据库的子项目。这些项目是与这些令人兴奋的技术背后的许多公司和开发人员共同开发的。</p>
<p>​    上面的介绍来自于官网，官网地址如下：<a href="https://spring.io/projects/spring-data">https://spring.io/projects/spring-data</a></p>
<p>​    其实说白了，Spring Data就是Spring官方将各个中间件整合，对中间件的操作进行了二次封装，让使用者可以更快的使用这些中间件。这样做有好有坏，好处是使用者不用关心底层的实现逻辑，甚至不用关心中间件的特点，可以快速上手。坏处也是这点，因为封装太多，一旦底层暴露出一些BUG，使用者完全不知道如何处理。这不仅仅是Spring Data的痛点，感觉是Spring全家桶的通病。感觉有点扯远了，开始整合Elasticsearch。</p>
<p>​    Spring Data中的Elasticsearch模块有着一下特点：</p>
<ul>
<li>Spring配置支持使用基于Java的<code>@Configuration</code>类或ES客户端实例的XML名称空间。</li>
<li><code>ElasticsearchTemplate</code>帮助程序类，可提高执行常规ES操作的效率。包括文档和POJO之间的集成对象映射。</li>
<li>与Spring的转换服务集成的功能丰富的对象映射。</li>
<li>基于注释的映射元数据，但可扩展以支持其他元数据格式。</li>
<li><code>Repository</code>接口的自动实现，包括对自定义查找器方法的支持。</li>
<li>CDI对存储库的支持。</li>
</ul>
<p>​    可以看到还是有很多比较好的点，也是方便上手和开发。下面就开始编写代码，这里使用的都是最新的版本（注意）。</p>
<p>​    同时，这些代码都是看了一些其他博客和官网的例子。</p>
<p>​    官网文档地址：<a href="https://docs.spring.io/spring-data/elasticsearch/docs/4.0.1.RELEASE/reference/html/#elasticsearch.clients">https://docs.spring.io/spring-data/elasticsearch/docs/4.0.1.RELEASE/reference/html/#elasticsearch.clients</a></p>
<p>​    需要先将项目导入Spring Data Elasticsearch的依赖，这里SpringBoot的版本是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    导入的依赖让SpringBoot自动选择，依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  ES依赖      --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    需要添加一个配置类，用来配置ES的基础信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.client.ClientConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.client.RestClients;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.config.AbstractElasticsearchConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.config.EnableElasticsearchRepositories;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RestClientConfig.java</span></span><br><span class="line"><span class="comment"> * Description:  ESclient的配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableElasticsearchRepositories(basePackages = &quot;com.psq.train.repository&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientConfig</span> <span class="keyword">extends</span> <span class="title">AbstractElasticsearchConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用构造器来提供集群地址，设置默认值或者启用SSL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> ClientConfiguration clientConfiguration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(<span class="string">&quot;111.229.157.173:9200&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建RestHighLevelClient</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> RestClients.create(clientConfiguration).rest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    剩下就是需要创建一个实体类和一个存储库。代码分别如下：</p>
<p>​    实体类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TestPerson.java</span></span><br><span class="line"><span class="comment"> * Description:  ES测试实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;test_person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPerson</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TestPerson&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, firstName=&#x27;&quot;</span> + firstName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, lastName=&#x27;&quot;</span> + lastName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    存储库代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TestPersonRepository.java</span></span><br><span class="line"><span class="comment"> * Description:  TestPerson实体类的Repository</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestPersonRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">TestPerson</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller层调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/elasticsearch&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testES</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TestPerson testPerson = <span class="keyword">new</span> TestPerson();</span><br><span class="line">    testPerson.setFirstName(<span class="string">&quot;psq&quot;</span>);</span><br><span class="line">    testPerson.setLastName(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    TestPerson saveResult = testPersonRepository.save(testPerson);</span><br><span class="line">    PageRequest pageRequest = PageRequest.of(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    Page&lt;TestPerson&gt; testPersonPage = testPersonRepository.findAll(pageRequest);</span><br><span class="line">    <span class="keyword">return</span> testPersonPage.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码都上完了，下面就说说要注意的点。</p>
<ul>
<li><p>因为这里只是简单使用，所以最开始的ES配置类添加的东西很少，只是创建了一个<code>RestHighLevelClient</code>，剩下的就不是很了解了，所以也没有去编写代码。有大佬知道的也可以告知，非常欢迎补足。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200722102642051.png" alt="image-20200722102642051"></p>
</li>
<li><p>代码的这个地方使用的9200端口，并且没有设置集群名称。是因为9200端口是作为Http协议，主要用于外部通讯。9300端口作为Tcp协议，jar之间就是bai通过tcp协议通讯。所以使用9300是需要指定集群名称的，使用9200则不需要指定名称的。</p>
</li>
<li><p><code>RestHighLevelClient</code>是直接使用http协议来操作ES的，所以官方会推荐这个客户端，不再推荐使用<code>TransportClient</code>。</p>
</li>
<li><p>本次代码使用的ES服务库是7.8版本的，因为低版本的ES会报一些错误，不识别部分参数。如果遇到低版本的ES，切换依赖版本就可以了。</p>
</li>
<li><p>Spring Data Elasticsearch其实还有一个优点，不过代码中没有体现出来。官网文档说的挺明白了，就是根据方法名自动生成执行方法，不需要再写实现类。同时，这里估计也可以添加分页的参数。不过官网对于分页说的比较少，需要大家到博客上找一找。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200722103750821.png" alt="image-20200722103750821"></p>
</li>
<li><p>这里直接指定了index，但是type没有指定，后续Elasticsearch会去掉这个属性。项目启动的时候，如果没有这个index，插入的时候会自动创建。</p>
</li>
</ul>
<p>​    剩下就没有什么可以说的，还是那句话，后续再写的时候再去学习和深入。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88MQTT/</url>
    <content><![CDATA[<h2 id="SpringBoot整合MQTT"><a href="#SpringBoot整合MQTT" class="headerlink" title="SpringBoot整合MQTT"></a>SpringBoot整合MQTT</h2><p>​    公司的项目重新进行了优化，换成了SpringBoot的架构。之前写的一个SSM整合MQTT的demo不能使用了，其实之前的代码写的也是有点烂，所以就来了解一下SpringBoot整合MQTT，顺便写一个比较好的代码。下面直接开始。</p>
<p>​    关于MQTT协议的一些介绍之前已经讲过了，之前对于协议的记录博客还是可以的。博客地址：<code>https://blog.csdn.net/qq_38533859/article/details/81872622</code>。所以这里不再介绍，直接开整。</p>
<p>​    需要添加pom依赖，这个是官方整合的依赖，官方也有例子（虽然不怎么样）。依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  MQTT依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.integration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-integration-mqtt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    剩下就是配置入站适配器和出站适配器了。这个是借鉴了一下官方的文档，文档地址在这里：<code>https://docs.spring.io/spring-integration/reference/html/mqtt.html#mqtt</code></p>
<p>​    因为之前是使用xml文件对mqtt适配器进行配置，所以这个新项目非常不想这样做，最后采用JavaConfig的形式配置。官方的例子写的很清楚了。我的入站适配器和出站适配器写在一起了。MQTT的配置文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttConnectOptions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.annotation.MessagingGateway;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.annotation.ServiceActivator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.channel.DirectChannel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.core.MessageProducer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.mqtt.core.DefaultMqttPahoClientFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.mqtt.core.MqttPahoClientFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.mqtt.inbound.MqttPahoMessageDrivenChannelAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.mqtt.outbound.MqttPahoMessageHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.mqtt.support.DefaultPahoMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.mqtt.support.MqttHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageChannel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessagingException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Header;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQTTConfig.java</span></span><br><span class="line"><span class="comment"> * Description:  MQTT的配置类，主要配置出入站适配器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQTTConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * =====================================入站适配器1=====================================</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageChannel <span class="title">mqttInputChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProducer <span class="title">inbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MqttPahoMessageDrivenChannelAdapter adapter =</span><br><span class="line">                <span class="keyword">new</span> MqttPahoMessageDrivenChannelAdapter(<span class="string">&quot;tcp://127.0.0.1:1883&quot;</span>, <span class="string">&quot;testClient1&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;testTopic2&quot;</span>);</span><br><span class="line">        adapter.setCompletionTimeout(<span class="number">5000</span>);</span><br><span class="line">        adapter.setConverter(<span class="keyword">new</span> DefaultPahoMessageConverter());</span><br><span class="line">        adapter.setQos(<span class="number">1</span>);</span><br><span class="line">        adapter.setOutputChannel(mqttInputChannel());</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;mqttInputChannel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message&lt;?&gt; message)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">                System.out.println(message.getPayload() + <span class="string">&quot;=====&quot;</span> + message.getHeaders().get(<span class="string">&quot;mqtt_receivedTopic&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * =====================================入站适配器2=====================================</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageChannel <span class="title">mqttInputChannelTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProducer <span class="title">inboundTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MqttPahoMessageDrivenChannelAdapter adapter =</span><br><span class="line">                <span class="keyword">new</span> MqttPahoMessageDrivenChannelAdapter(<span class="string">&quot;tcp://127.0.0.1:1883&quot;</span>, <span class="string">&quot;testClient3&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;testTopic2&quot;</span>);</span><br><span class="line">        adapter.setCompletionTimeout(<span class="number">5000</span>);</span><br><span class="line">        adapter.setConverter(<span class="keyword">new</span> DefaultPahoMessageConverter());</span><br><span class="line">        adapter.setQos(<span class="number">1</span>);</span><br><span class="line">        adapter.setOutputChannel(mqttInputChannelTwo());</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;mqttInputChannelTwo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageHandler <span class="title">handlerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message&lt;?&gt; message)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">                System.out.println(message.getPayload() + <span class="string">&quot;=====&quot;</span> + message.getHeaders().get(<span class="string">&quot;mqtt_receivedTopic&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * =====================================出站适配器=====================================</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MqttPahoClientFactory <span class="title">mqttClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMqttPahoClientFactory factory = <span class="keyword">new</span> DefaultMqttPahoClientFactory();</span><br><span class="line">        MqttConnectOptions options = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">        options.setServerURIs(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;tcp://127.0.0.1:1883&quot;</span>&#125;);</span><br><span class="line">        options.setUserName(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        options.setPassword(<span class="string">&quot;password&quot;</span>.toCharArray());</span><br><span class="line">        factory.setConnectionOptions(options);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;mqttOutboundChannel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageHandler <span class="title">mqttOutbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MqttPahoMessageHandler messageHandler =</span><br><span class="line">                <span class="keyword">new</span> MqttPahoMessageHandler(<span class="string">&quot;testClient2&quot;</span>, mqttClientFactory());</span><br><span class="line">        messageHandler.setAsync(<span class="keyword">true</span>);</span><br><span class="line">        messageHandler.setDefaultTopic(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> messageHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageChannel <span class="title">mqttOutboundChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * =====================================发送的接口=====================================</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="meta">@MessagingGateway(defaultRequestChannel = &quot;mqttOutboundChannel&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGateway</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendToMqtt</span><span class="params">(<span class="meta">@Header(MqttHeaders.TOPIC)</span> String topic, String data)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面就是代码，解释都在官方文档里面了，大家搞个翻译，翻译一下官方文档就大致明白了。这里说一些注意的点。</p>
<ul>
<li><p>代码中配置了两个入站适配器，一个出站适配器，这三个适配器的ClientID最好不要一样，要不然会一直出现断连重连现象。</p>
</li>
<li><p>发送的接口最好分离出去一个单独的类，我写在一起，但是实际使用的时候一直出问题，因为时间问题也没有去找原因。</p>
</li>
<li><p>代码的这种写法不是MQTT的单独的写法，我了解到这个好像是Spring的一种模式吧，没有来得及了解，后续肯定会去了解一下。</p>
</li>
<li><p>SpringBoot的这种整合有一些BUG，好像是MQTT官方解决了，但是SpringBoot官方还存在这个问题。具体没有遇到这个问题，所以不清楚现象，留个坑。</p>
</li>
<li><p>官方还可以写一个监听函数，用来监听连接成功和断连的时候，这里没有上代码，没有啥可以讲的。在官方文档的最后面有提到。</p>
</li>
</ul>
<p>​    下面就是上调用的代码，这里直接使用controller调用了，没有啥复杂的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/mqtt&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendMQTTMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myGateway.sendToMqtt(<span class="string">&quot;testTopic1&quot;</span>, <span class="string">&quot;hello1&quot;</span>);</span><br><span class="line">    myGateway.sendToMqtt(<span class="string">&quot;testTopic2&quot;</span>, <span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    剩下就没有啥可以讲的了，时间赶的急，后面遇到再说吧，再次留个坑。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/SpringBoot%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="SpringBoot知识点"><a href="#SpringBoot知识点" class="headerlink" title="SpringBoot知识点"></a>SpringBoot知识点</h2><p>​    Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<h3 id="SpringBoot的启动流程"><a href="#SpringBoot的启动流程" class="headerlink" title="SpringBoot的启动流程"></a>SpringBoot的启动流程</h3><p>​    流程图如下：</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210623161300236.png" alt="image-20210623161300236"></p>
<p>​    流程暂时还不是很清楚，可以后续完善</p>
<h3 id="SpringBoot中的自动配置原理"><a href="#SpringBoot中的自动配置原理" class="headerlink" title="SpringBoot中的自动配置原理"></a>SpringBoot中的自动配置原理</h3><p>​    项目中只要配置了redis的信息，在代码中直接注入redis模版bean，就可以直接使用了，这个就是自动配置。将配置文件中的信息配置到bean上，自动配置分为bean的自动配置和属性的自动配置。</p>
<p>​    其中<code>@EnableAutoConfiguration</code>是关键(启用自动配置)，内部实际上就去加载<code>META-INF/spring.factories</code>文件的信息，然后筛选出以<code>EnableAutoConfiguration</code>为key的数据，加载到IOC容器中，实现自动配置功能！</p>
<h3 id="Spring-JavaConfig"><a href="#Spring-JavaConfig" class="headerlink" title="Spring JavaConfig"></a>Spring JavaConfig</h3><p>​    因为xml配置bean的方式比较复杂，并且不符合面向对象的逻辑。所以就有了Spring JavaConfig，它允许开发者将bean定义和在Spring配置XML文件到Java类中。这两者是可以混用的。</p>
<h3 id="SpringBoot中配置文件加载顺序"><a href="#SpringBoot中配置文件加载顺序" class="headerlink" title="SpringBoot中配置文件加载顺序"></a>SpringBoot中配置文件加载顺序</h3><p>​    spring boot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件。properties优先级会高一些，相同名称的配置，会将 yml内的配置覆盖掉。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">–file:./config/</span><br><span class="line">–file:./</span><br><span class="line">–classpath:/config/</span><br><span class="line">–classpath:/</span><br></pre></td></tr></table></figure>

<p>​    顺序如下，由一到四：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210623170034583.png" alt="image-20210623170034583"></p>
<p>注意：bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstarp是spring cloud中使用的配置文件。</p>
<h3 id="YAML文件"><a href="#YAML文件" class="headerlink" title="YAML文件"></a>YAML文件</h3><p>​    YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。</p>
<p>​    YAML 的配置文件后缀为 <strong>.yml</strong>，如：<strong>runoob.yml</strong> 。</p>
<h3 id="SpringBoot中的监听器"><a href="#SpringBoot中的监听器" class="headerlink" title="SpringBoot中的监听器"></a>SpringBoot中的监听器</h3><p>​    监听器模式是由观察者模式发展而来，有一下几个重要部分。</p>
<ul>
<li>事件：步骤1和步骤2，通过对天气进行抽象，并实现下雨和下雪的天气状态</li>
<li>监听器：步骤3和步骤4，规范对天气监听的模式，并且规范对应天气下，需要如何处理</li>
<li>广播器：步骤5、步骤6和步骤7，当有事件发生的时候，广播器发出信号，告知所有的监听器，监听器根据事件作出相应的处理。触发下雨事件的时候，下雨监听器收到消息，它抬头一看乌云密布电闪雷鸣，微微一愣，大喊一句：“打雷下雨收衣服啊！！”，广播器继续通知下一个监听器下雪监听器，下雪监听器看看天空，摆摆手，说：“这事与我无关去找别人”</li>
<li>触发机制：步骤8，demo中采用的硬编码的形式触发的，在实际运用中，可能是湿度仪检测到湿度暴涨开始下雨了，触发广播。</li>
</ul>
<p>​    具体的流程就是：监听器中编写对某些事件发生的处理情况，然后监听器注册到广播器中，当有时间触发时，广播器告知所有的监听器，监听器在做相应的处理。</p>
<p>​    ApplicationListener是Spring事件机制的一部分，与抽象类ApplicationEvent类配合来完成ApplicationContext的事件机制，实现ApplicationListener接口的类，会在SpringBoot加入到广播器中，当ApplicationContext触发了一个事件，就用广播器通知所有实现ApplicationListener接口的类。</p>
<p>​    SpringBoot中九大事件：</p>
<ul>
<li>EventObject：事件顶级对象，所有事件对象的根对象</li>
<li>ApplicationEvent：应用事件</li>
<li>SpringApplicationEvent：Spring自己的事件，Spring框架自身的事件都会实现这个接口</li>
<li>ApplicationStartingEvent：启动事件，框架刚刚启动就会发出这个事件</li>
<li>ApplicationEnvironmentPreparedEvent：环境在变完成，系统属性和用户指定已经加载完成</li>
<li>ApplicationContextInitializedEvent：已经创建好了上下文，并且还没有加载任何bean之前发出这个事件</li>
<li>ApplicationPreparedEvent：在Bean定义开始加载之后，尚未完全加载之前，刷新上下文之前触发</li>
<li>ApplicationStartedEvent：bean已经创建完成，上下文已经刷新完成，但是ApplicationRunner和CommandLineRunne两个扩展接口并未执行</li>
<li>ApplicationReadyEvent：ApplicationRunner和CommandLineRunne两个扩展接口执行完成之后触发</li>
<li>ApplicationFailedEvent：在启动发生异常时触发</li>
</ul>
<p>​    启动 —》ApplicationStartingEvent —》ApplicationEnvironmentPreparedEvent —》ApplicationContextInitializedEvent —》 ApplicationPreparedEvent —》ApplicationStartedEvent —》 ApplicationReadyEvent —》启动完毕</p>
<h3 id="Spring-Boot-中的-starter"><a href="#Spring-Boot-中的-starter" class="headerlink" title="Spring Boot 中的 starter"></a>Spring Boot 中的 starter</h3><p>​    在spring中引入一个中间件或者JPA，需要先在pom文件中导入需要的依赖，再添加相应的配置。然后再调试完毕，直到项目正常启动。多个项目也是这样的配置，只不过多个项目可能配置直接复制即可，本质还是复杂的。</p>
<p>​    starter的主要目的就是为了解决上面的这些问题。</p>
<p>　　starter的理念：starter会把所有用到的依赖都给包含进来，避免了开发者自己去引入依赖所带来的麻烦。需要注意的是不同的starter是为了解决不同的依赖，所以它们内部的实现可能会有很大的差异，例如jpa的starter和Redis的starter可能实现就不一样，这是因为starter的本质在于synthesize，这是一层在逻辑层面的抽象，也许这种理念有点类似于Docker，因为它们都是在做一个“包装”的操作，如果你知道Docker是为了解决什么问题的，也许你可以用Docker和starter做一个类比。</p>
<p>　　starter的实现：虽然不同的starter实现起来各有差异，但是他们基本上都会使用到两个相同的内容：ConfigurationProperties和AutoConfiguration。因为Spring Boot坚信“约定大于配置”这一理念，所以我们使用ConfigurationProperties来保存我们的配置，并且这些配置都可以有一个默认值，即在我们没有主动覆写原始配置的情况下，默认值就会生效，这在很多情况下是非常有用的。除此之外，starter的ConfigurationProperties还使得所有的配置属性被聚集到一个文件中（一般在resources目录下的application.properties），这样我们就告别了Spring项目中XML地狱。</p>
<p>​    对于starter中的配置，用户仍然可以再application配置文件中进行覆盖掉，达到自己的定制化。没有覆盖的就使用starter中的默认值。</p>
<h3 id="Spring-Security-和-Shiro"><a href="#Spring-Security-和-Shiro" class="headerlink" title="Spring Security 和 Shiro"></a>Spring Security 和 Shiro</h3><p>​    Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p>
<p>​    Apache Shiro 是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro 框架具有直观、易用等特性，同时也能提供健壮的安全性，虽然它的功能不如 Spring Security 那么强大，但是在常规的企业级应用中，其实也够用了。</p>
<p>​    两者都是权限框架，用来做安全验证的，考点估计也比较少。后续遇到再注意。</p>
<h3 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3><p>​    WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p>
<p>​    后续如果有人问的话，可以看看这篇文章：<a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">https://www.cnblogs.com/chyingp/p/websocket-deep-in.html</a></p>
<h3 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h3><p>​    在Java开发中，常用的日志记录框架有JDKLog、Log4J、LogBack、SLF4J、SLF4J。这些日志记录框架各有各的特点，各有各的应用场景。</p>
<p>​    日志框架使用的是门面模式，分为门面和实现。JCL、SLF4J是日志门面。JUL、LOG4J1、LOG4J2、LOGBACK是日志实现框架。</p>
<p>​    common-logging 与 slf4j 都是日志实现门面，它们本身都不具体实现写日记操作，只是提供统一的接口。</p>
<p>​    common-logging 是最早的日志门面实现，而 SLF4J 是较新的日志门面实现。因此 SLF4J 在性能以及兼容性处理会比 common-logging要好。</p>
<ul>
<li>JDKLog：jdk自带的日志，直接就可以使用。但 JDKLog 功能比较太过于简单，不支持占位符显示，拓展性比较差，所以现在用的人也很少。</li>
<li>Log4J： 是 Apache 的一个日志开源框架，有多个分级（DEBUG/INFO/WARN/ERROR）记录级别，可以很好地将不同日志级别的日志分开记录，极大地方便了日志的查看。</li>
<li>LogBack ：其实可以说是 Log4J 的进化版，因为它们两个都是同一个人（Ceki Gülcü）设计的开源日志组件。LogBack 除了具备 Log4j 的所有优点之外，还解决了 Log4J 不能使用占位符的问题。</li>
</ul>
<h3 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h3><h4 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h4><p>​    SPI的全名为Service Provider Interface.我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<br>​    java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p>
<p>​    在Spring中也有一种类似与Java SPI的加载机制。它在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。 这种自定义的SPI机制是Spring Boot Starter实现的基础。 </p>
<h3 id="SpringBoot中常用的注解"><a href="#SpringBoot中常用的注解" class="headerlink" title="SpringBoot中常用的注解"></a>SpringBoot中常用的注解</h3><ul>
<li>@ComponentScan主要就是定义扫描的路径从中找出标识了需要装配的类自动装配到spring的bean容器中。常和@Component搭配使用。</li>
<li>@Component：表示带注释的类是“组件”。 在使用基于注释的配置和类路径扫描时，此类类被视为自动检测的候选对象。</li>
<li>@Autowired:默认按类型匹配注入Bean.如果找到两个，就会报异常，因为没法判断到底使用哪个</li>
<li>@Resource:默认按名称匹配注入Bean，先是按照名称查询bean，如果没有找到按照类型，多个也会报错。</li>
<li>@Qualifier:指定注入bean的名称，需要搭配@Autowired一起使用。</li>
</ul>
<h3 id="SpringBoot面试问题"><a href="#SpringBoot面试问题" class="headerlink" title="SpringBoot面试问题"></a>SpringBoot面试问题</h3><ul>
<li>SpringBoot启动流程</li>
</ul>
<p>​    第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，第三部分是自动化配置模块。背不住</p>
<p>​    </p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>//springboot自动配置原理</p>
<p>//javaconfig</p>
<p>//@ComponentScan扫描</p>
<p>//springboot配置加载顺序</p>
<p>//springboot监听器</p>
<p>//Spring Boot 中的 starter </p>
<p>//yaml文件</p>
<p>//Spring Security 和 Shiro的区别和作用</p>
<p>//websockets</p>
<p>//日志框架</p>
<p>//spring.factories</p>
<p>需要练习的有：</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/SpringBoot%E8%BF%9E%E6%8E%A5Mysql/</url>
    <content><![CDATA[<h2 id="SpringBoot连接Mysql"><a href="#SpringBoot连接Mysql" class="headerlink" title="SpringBoot连接Mysql"></a>SpringBoot连接Mysql</h2><p>​    第一个SpringBoot的练习就是连接数据库，使用的是就是基础的组件，没有使用web和mybatis。也是作为一个基础的demo。开始。</p>
<p>​    因为之前的java项目是通过导入jar包来实现，非常的繁琐并且jar包不容易管理。后来产生了maven，通过maven来管理jar包。本次项目也是通过pom文件来管理依赖，同时，因为SpringBoot设置了默认的依赖版本，这里也不再叙述导入依赖的版本。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200530152138145.png" alt="image-20200530152138145"></p>
<p>​    导入的依赖如下：下面的代码就是全部的依赖，有些最开始创建项目的时候已经导入了，这里仍然放在下面了。记得添加依赖后要更新一下，要不然很多东西IDE无法做配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot基础依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JDBC依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 测试依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    maven更新的图片如下，这样更新后就可以使用依赖中的类。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200531130454654.png" alt="image-20200531130454654">    </p>
<p>​    导入依赖后，需要在SpringBoot配置文件中进行数据库的基础配置。这里配置文件是application.properties。不是现在常见的yml格式，这里是spring默认的格式。其他格式的数据库配置需要查询一下，后面也会换成其他格式，这种格式不好区分各个中间件配置，但是现在暂时使用这个格式。配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">12345678</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>​    创建测试类就可以了，下面就可以写代码了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.mysql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConnectMySQLTrain.java</span></span><br><span class="line"><span class="comment"> * Description: 使用基础的组件连接MySQL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/30345</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectMySQLTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 测试MySQL数据读取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMySQL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT id,name,password FROM `user`&quot;</span>;</span><br><span class="line">        List&lt;TestUser&gt; testUserList = jdbcTemplate.query(sql, <span class="keyword">new</span> RowMapper&lt;TestUser&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> TestUser <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                TestUser testUser = <span class="keyword">new</span> TestUser();</span><br><span class="line">                testUser.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                testUser.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                testUser.setPassword(resultSet.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> testUser;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.err.println(<span class="string">&quot;查询成功，查询结果如下：&quot;</span> + testUserList.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    需要注意的是：这里没有使用SPringBoot的web模块，只是简单的一个demo，所以就单独写了一个类，在项目启动的时候运行一下就可以了<code>@Component</code>注解是为了把普通pojo实例化到spring容器中，相当于配置文件中的<code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code>，<code>@PostConstruct</code>注解的意思是：被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。实体类的代码因为没有什么可以讲的，这里就不再占面积了。</p>
<p>​    运行项目这里也没有什么可以讲的地方。就是SpringBoot内置了Tomcat，但是因为我这个项目没有web模块，所以没有内嵌tomcat，关于这些可以放到后面来说。本次就是打成了jar包，通过jvm运行。结果如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200531132745688.png" alt="image-20200531132745688"></p>
<p>​    上面说的可能有些地方不对，大家可以指导一下。就这样吧，结束。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/SpringBoot%E8%BF%9E%E6%8E%A5Redis/</url>
    <content><![CDATA[<h2 id="SpringBoot连接Redis"><a href="#SpringBoot连接Redis" class="headerlink" title="SpringBoot连接Redis"></a>SpringBoot连接Redis</h2><p>​    下面就开始练习连接Redis，这里也是没有集成web模块。web模块感觉这些东西也没有必要。连接池这里可以讲一下，上一篇MySQL的连接池放在Mybatis那里再讲，估计也快了，如果不出意外的话。。。</p>
<p>​    首先安装Redis和配置Redis的信息，这里不再累述，我之前的博客也有。刚才看了一下，我之前的博客讲的还挺详细的，我这次有可能重复了，尽量讲讲之前没有讲到的。</p>
<p>​    仍然是添加依赖，因为Redis官方开发了一个连接工具Jedis，这个工具挺好用的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  Redis依赖      --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  不添加这个依赖会导致RedisTemplate无法注入      --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    下面就是配置Redis连接和连接池信息。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis依赖</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">自己的密码</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment">## 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">200</span></span><br><span class="line"><span class="comment">## 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">## 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">## 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<p>​    下面就开始编写代码，需要注意的是代码中引用的类是StringRedisTemplate，有一些不同的地方。</p>
<ul>
<li><p>RedisTemplate，RedisTemplate是最基本的操作类，它默认的序列化方式是JdkSerializationRedisSerializer，在存值时，键值会被序列化为字节数组，可读性差，取值时也是一样，如果redis中存的值正常的字符串形式，取值时将返回null。</p>
</li>
<li><p>StringRedisTemplateStringRedisTemplate继承于 RedisTemplate&lt;String, String&gt;，默认的序列化方式是StringRedisSerializer，存值取值都是按照字符串的形式。</p>
<p>代码如下，但是中间遇到了一些问题，解决起来很蛋疼。下面说说，最开始使用的是上面的依赖，但是启动一直报错，一开始怀疑注入的方式不对，把<code>@Resource</code>换成<code>@Autowired</code>，结果还是不行，又怀疑方法不能正常调用（菜鸟的智障怀疑），后来又排除了。在网上找了一圈，怀疑redis版本的问题，换成了jedis，结果就可以了。然后就认为是依赖的版本问题，生菜（最新redis使用的）和目前的SpringBoot融合的不是很好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.train.mysql.TestUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RedisTrain.java</span></span><br><span class="line"><span class="comment"> * Description: Redis练习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用StringRedisTemplate，类似于RedisTemplate&lt;String,String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: Redis练习的主方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/5/31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redisTrainmain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestUser testUser = <span class="keyword">new</span> TestUser();</span><br><span class="line">        testUser.setId(<span class="number">3</span>);</span><br><span class="line">        testUser.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        testUser.setPassword(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;下面开始Redis插入&quot;</span>);</span><br><span class="line">        redisTrainInsert(testUser);</span><br><span class="line">        System.err.println(<span class="string">&quot;下面开始查询&quot;</span>);</span><br><span class="line">        redisTrainSelect(testUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: redis插入方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> testUser</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redisTrainInsert</span><span class="params">(TestUser testUser)</span> </span>&#123;</span><br><span class="line">        String key = testUser.getName();</span><br><span class="line">        String value = testUser.toString();</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value);</span><br><span class="line">        System.err.println(<span class="string">&quot;存储成功，存储对象为:key:&quot;</span> + key + <span class="string">&quot;,value:&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: redis查询方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redisTrainSelect</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;需要查询的name为:&quot;</span> + name);</span><br><span class="line">        System.err.println(name);</span><br><span class="line">        String value = stringRedisTemplate.opsForValue().get(name);</span><br><span class="line">        System.err.println(<span class="string">&quot;查询到到结果为:&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Lettuce</code>和<code>Jedis</code>的都是连接<code>Redis Server</code>的客户端程序。<code>Jedis</code>在<strong>实现上是直连<code>redis server</code>，多线程环境下非线程安全，除非使用连接池，为每个Jedis实例增加物理连接</strong>。<code>Lettuce</code>基于Netty的连接实例（StatefulRedisConnection），<strong>可以在多个线程间并发访问，且线程安全，满足多线程环境下的并发访问，同时它是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例</strong>。</p>
<p>我也这样认为，直到我再次启动的时候，发现下面一个问题。  <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200601090901717.png" alt="image-20200601090901717"></p>
<p>如上图，最后显示的是一个密码的问题，是客户端配置了密码，但是服务端没有配置密码，我又查看了redis启动的时候，没有使用正确的配置文件。</p>
</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200601092939704.png" alt="image-20200601092939704"></p>
<p>​    配置了密码后，一切都解决了。真是一个SB问题，果然是老了。。。</p>
<p>​    剩下就遗留了一个问题，我看别人的demo都写了一个redis配置类，估计是为了定制自己的<code>RedisTemplate</code>，我这里没有什么定制的，就是简单的用了一下，所以没有写redis配置类。如果我说错了，大家也指点一下。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/SpringBoot%E9%9B%86%E5%90%88Mybatis%E8%BF%9E%E6%8E%A5PostgreSQL/</url>
    <content><![CDATA[<h2 id="SpringBoot集合MyBatis连接PostgreSQL"><a href="#SpringBoot集合MyBatis连接PostgreSQL" class="headerlink" title="SpringBoot集合MyBatis连接PostgreSQL"></a>SpringBoot集合MyBatis连接PostgreSQL</h2><p>​    正好最近需要使用PostgreSQL，蹭着这个机会把MyBatis练习一下。下面就直接开始。    </p>
<p>​    本次也顺带把配置文件修改为yml文件，方便后面的修改和配置。改文件很简单，只需要修改配置文件后缀名为yml即可。Spring可以直接识别，不需要修改其他的配置文件内容。将<code>application.properties</code>修改为<code>application.yml</code>。同时需要注意两个文件的格式是不一样的。需要注意的就是<code>:</code>后面有一个空格。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################### common config : ####################################</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8080</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">train</span></span><br><span class="line"><span class="comment">  #Redis依赖</span></span><br><span class="line"><span class="comment">  # Redis服务器地址</span></span><br><span class="line">  <span class="attr">redis</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">    # Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">database</span>: <span class="string">0</span></span><br><span class="line"><span class="comment">    # Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">6379</span></span><br><span class="line"><span class="comment">    # Redis服务器连接密码（默认为空）</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">mima</span></span><br><span class="line"><span class="comment">    # 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="string">1000</span></span><br><span class="line">    <span class="attr">lettuce</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">pool</span>:<span class="string"></span></span><br><span class="line"><span class="comment">        ## 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="meta">max-active</span>: <span class="string">200</span></span><br><span class="line"><span class="comment">        ## 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="meta">max-wait</span>: <span class="string">-1</span></span><br><span class="line"><span class="comment">        ## 连接池中的最大空闲连接</span></span><br><span class="line">        <span class="meta">max-idle</span>: <span class="string">10</span></span><br><span class="line"><span class="comment">        ## 连接池中的最小空闲连接</span></span><br><span class="line">        <span class="meta">min-idle</span>: <span class="string">0</span></span><br><span class="line">  <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    #PostgreSQL配置</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">jdbc:postgresql://127.0.0.1:5432/postgres</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">postgres</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">mima</span></span><br><span class="line">    <span class="meta">driver-class-name</span>: <span class="string">org.postgresql.Driver</span></span><br><span class="line"><span class="comment">    #druid连接池配置</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="comment">    # 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</span></span><br><span class="line">    <span class="attr">initialSize</span>: <span class="string">5</span></span><br><span class="line">    <span class="attr">minIdle</span>: <span class="string">5</span></span><br><span class="line"><span class="comment">    # 最大连接池数量</span></span><br><span class="line">    <span class="attr">maxActive</span>: <span class="string">20</span></span><br><span class="line">    <span class="attr">maxWait</span>: <span class="string">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis</span>: <span class="string">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis</span>: <span class="string">300000</span></span><br><span class="line">    <span class="attr">validationQuery</span>: <span class="string">SELECT 1</span></span><br><span class="line">    <span class="attr">testWhileIdle</span>: <span class="string">true</span></span><br><span class="line">    <span class="attr">testOnBorrow</span>: <span class="string">false</span></span><br><span class="line">    <span class="attr">testOnReturn</span>: <span class="string">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">    #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span></span><br><span class="line">    <span class="attr">filters</span>: <span class="string">stat,wall</span></span><br><span class="line">    <span class="attr">maxPoolPreparedStatementPerConnectionSize</span>: <span class="string">20</span></span><br><span class="line">    <span class="attr">useGlobalDataSourceStat</span>: <span class="string">true</span></span><br><span class="line">    <span class="attr">connectionProperties</span>: <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis</span>:<span class="string"></span></span><br><span class="line"><span class="comment">	# 加载配置文件</span></span><br><span class="line">  <span class="meta">mapper-locations</span>: <span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="comment">  # 实体类所在路径，填写改路径mapper文件中可以不写全路径</span></span><br><span class="line">  <span class="meta">type-aliases-package</span>: <span class="string">com.psq.train.mysql</span></span><br></pre></td></tr></table></figure>

<p>​    另外，这次也使用了连接池Druid，这个是阿里开发的一个工具，挺好用（大家都这样说）。这次也顺带整合进去。下面就一步一步来吧。</p>
<p>​    首先整合PostgreSQL，添加PostgreSQL依赖即可。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- postgresql依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    顺带添加Mybatis和Druid的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- druid连接池依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MyBatis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    要记得删除之前使用的MySQL的依赖，因为我之前的项目使用了MySQL，所以删除了MySQL和JDBC的依赖。另外这里也遇到一个坑。不知道IDE抽什么风，项目启动的时候一直报错，显示Redis和Mybatis没有配置，但是我依赖都已经删除了。我找了三个小时，最后才发现项目的库不对，仍然存在已经删除的jar包。所以再删除依赖后更新pom文件后，需要查看下面两个地方是不是正常。如下图：</p>
<p>​    <img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612161516325.png" alt="image-20200612161516325"></p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612161543564.png" alt="image-20200612161543564"></p>
<p>​    更新完毕依赖后，下面就可以编写配置文件了。配置文件如上面所示，PostgreSQL需要注意<code>url</code>和<code>driver-class-name</code>。从<code>type</code>往下都是Druid的配置。Mybatis也是最下面的配置。</p>
<p>​    Druid的配置详细解读这个链接比较详细。<a href="https://www.cnblogs.com/lzhya/p/12493974.html">https://www.cnblogs.com/lzhya/p/12493974.html</a></p>
<p>​    同时，因为spring中的Druid配置文件不能读取，所以要写一个配置类，让参数正常加载。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.train.mysql.TestUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserMapper.java</span></span><br><span class="line"><span class="comment"> * Description: user表的mapper映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 查询所有用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.util.List&lt;com.psq.train.mysql.TestUser&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;TestUser&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    Mybatis的配置这里不是很了解，不再解释，后面慢慢补上。</p>
<p>​    为了让dao层的mapper映射文件能够注入，启动类添加了下面的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: SpringBoot启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.psq.train.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TrainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    项目结构图如下：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612163659925.png" alt="image-20200612163659714"></p>
<p>​    下面就是具体的业务代码实现，上面都是基础的配置。</p>
<ul>
<li><p>首先需要先创建表，这里不再叙述，后面需要补充，我就是简单的创建了一个user表，和MySQL的类似。</p>
</li>
<li><p>再就是创建mapper文件，相当于把数据库中的表和java代码联系起来。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.psq.train.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;TestUser&quot;</span>&gt;</span></span><br><span class="line">        SELECT id,name,password FROM test_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个mapper类，方法名要和mapper文件中的id保持一致。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.train.mysql.TestUser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserMapper.java</span></span><br><span class="line"><span class="comment"> * Description: user表的mapper映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 查询所有用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.util.List&lt;com.psq.train.mysql.TestUser&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;TestUser&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建测试类，调用一下mapper类查询一下数据，这里最简单就可以了，所以没有按照web开发的模版写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.psq.train.postgresql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.psq.train.dao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.psq.train.mysql.TestUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PostgreSQLTest.javaa</span></span><br><span class="line"><span class="comment"> * Description:  PostgreSQL的测试demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Peng Shiquan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostgreSQLTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: PostgreSQL的测试方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Peng Shiquan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/6/12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAllUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;TestUser&gt; testUserList = userMapper.getAllUser();</span><br><span class="line">        <span class="keyword">for</span> (TestUser testUser : testUserList) &#123;</span><br><span class="line">            System.err.println(testUser.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    这里有一个地方需要注意，编写Drudi配置类的时候，发现无法启动，报错信息是注入了相同name的bean，最后排查到是Druid配置类名字和其中一个方法名字相同，导致无法注入。后面查询到这俩注解的作用如下：</p>
<ul>
<li><p>@Configuration</p>
<ul>
<li><p>@Configuration注解底层是含有@Component ，所以@Configuration 具有和 @Component 的作用。</p>
</li>
<li><p>@Configuration注解相当于spring的xml配置文件中<beans>标签，里面可以配置bean。</p>
</li>
</ul>
</li>
<li><p>@Bean</p>
<ul>
<li><p>@Bean注解相当于spring的xml配置文件<bean>标签，告诉容器注入一个bean。</p>
</li>
<li><p>@Bean注解的方法上如果没通过bean指定实例名，默认实例名与方法名相同。</p>
</li>
<li><p>@Bean注解默认为单例模式，可以通过@Scope(“prototype”)设置为多例。</p>
</li>
</ul>
</li>
</ul>
<p>​    关于PostgreSQL数据库的其他信息，下面一篇博客再说吧，要不然博客就太多了。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/SpringBoot%E9%9B%86%E6%88%90Log4j2%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="SpringBoot集成Log4j2日志框架"><a href="#SpringBoot集成Log4j2日志框架" class="headerlink" title="SpringBoot集成Log4j2日志框架"></a>SpringBoot集成Log4j2日志框架</h2><p>​    今天写代码的时候遇到了日志的问题，于是顺带学习一下日志框架和如何使用。以SpringBoot集成作为练习。</p>
<p>​    说到日志框架不得不提SLF4J，SLF4J使用门面模式定义了日志操作的相关接口。就是说SLF4J只是定义了日志操作的相关接口，而不是具体的日志实现方案。SLF4J提供了操作日志的通用接口规范，只要你实现了这些规范接口，那么你就制作了一个符合SLF4J约定的日志框架。而比较出名的开源日志框架有：java.util.logging, logback and log4j。</p>
<p>​    本次整合的就是log4j日志框架。还是和以前一样，直接上官网地址，上面讲解的很详细。<a href="https://logging.apache.org/log4j/2.x/index.html">https://logging.apache.org/log4j/2.x/index.html</a></p>
<p>​    因为是一个日志框架，和本身开发没有太多的关系，所以这里不再详细描述原理和基础概念。只是把练习demo列出来。</p>
<p>​    先试pom文件引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  lof4j2日志框架      --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    因为引入的日志框架会和SpringBoot基础依赖冲突，这里将SpringBoot的基础依赖去除。去除代码后如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基础依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringBoot基础依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span><span class="comment">&lt;!-- 去掉springboot默认配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  添加web依赖，这样项目就可以一直启动      --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span><span class="comment">&lt;!-- 去掉springboot默认配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    下面就是在<code>resources</code>目录下创建一个文件，文件名为<code>log4j2.xml</code>。内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    下面就完成了，启动项目出现如下截图：</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200708170508353.png" alt="image-20200708170508353"></p>
<p>​    完成。</p>
<p>​    因为是初步的使用，所以配置文件中有些不是很明白，解释如下：顺带给自己一个记录。</p>
<p>​    下面给出一个xml的模版，大家可以按照这个配置。模版来自于:<a href="https://www.cnblogs.com/keeya/p/10101547.html">https://www.cnblogs.com/keeya/p/10101547.html</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--变量配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志存储的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的日志路径&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的项目名&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">&quot;Filelog&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/test.log&quot;</span> <span class="attr">append</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileInfo&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/info.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileWarn&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/warn.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileError&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/error.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--监控系统信息--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--若是additivity设为false，则 子Logger 只会在自己的appender里输出，而不会在 父Logger 的appender里输出。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Filelog&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileInfo&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileWarn&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileError&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    上面的网页讲的挺清楚，我再写一遍有点浪费。这样大家看看，记不住再到我这里看看就可以了。</p>
<p>​    就这样吧，结束。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="Spring内部知识点"><a href="#Spring内部知识点" class="headerlink" title="Spring内部知识点"></a>Spring内部知识点</h2><h3 id="IOC相关知识点"><a href="#IOC相关知识点" class="headerlink" title="IOC相关知识点"></a>IOC相关知识点</h3><h4 id="IOC基础概念"><a href="#IOC基础概念" class="headerlink" title="IOC基础概念"></a>IOC基础概念</h4><p>​    所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。之前传统的是由对象内部直接生成，这样耦合度太高。通过控制反转，只需要告知IOC容器你需要什么样的实例，IOC容器就会自动将实例注入到你的实例里面。控制反转需要依赖注入的支持，即依赖注入是控制反转的实现。依赖注入就是由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</p>
<p>​    <a href="https://juejin.cn/post/6857406008877121550">详细的解释</a></p>
<h4 id="依赖注入的类型和方式"><a href="#依赖注入的类型和方式" class="headerlink" title="依赖注入的类型和方式"></a>依赖注入的类型和方式</h4><p>​    依赖注入的类型有：</p>
<ul>
<li>值类型注入 ：就是基础的数据类型，如字符串和Integer</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 普通数据类型注入，通过构造器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;po.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 普通数据类型注入，通过setter方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;po.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用类型注入：需要依赖的是一个实例，需要现在xml文件中创建这个实例的bean，再去引用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用数据类型注入，通过构造器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用数据类型注入，通过setter方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂的集合形式：将多个实例放入到集合中，本质和引用类型相差不多，但是需要注意标签。（集合类型的注入只能通过XML来实现）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 集合数据类型注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;po.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;po.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 另一种方法，需要添加第三方约束 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- xmlns:util=&quot;http://www.springframework.org/schema/util&quot; --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- http://www.springframework.org/schema/util --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- http://www.springframework.org/schema/util/spring-util.xsd --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;util:list list-class=&quot;java.util.ArrayList&quot;&gt;</span></span><br><span class="line"><span class="comment">                &lt;value&gt;aaa&lt;/value&gt;</span></span><br><span class="line"><span class="comment">                &lt;value&gt;bbb&lt;/value&gt;</span></span><br><span class="line"><span class="comment">                &lt;value&gt;ccc&lt;/value&gt;</span></span><br><span class="line"><span class="comment">            &lt;/util:list&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>eee<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>fff<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;user1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;user2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;k_user1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;k_user2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;properties_name&quot;</span>&gt;</span>wangwu<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;properties_age&quot;</span>&gt;</span>25<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    依赖注入的方式有：</p>
<ul>
<li>第一种：使用构造函数提供。</li>
<li>第二种：使用set方法提供(常用)。</li>
<li>第三种：使用注解提供。首先按照类型去Spring容器中圈定出来匹配的对象，接下来使用变量名作为bean的id在圈定出来的内容里继续查找，如果有一样的也可以注入成功，如果都不一样报错。</li>
</ul>
<p>​    需要注意的点：</p>
<ul>
<li>一个bean代表一个实例，一个实例只能调用一个构造方法。</li>
<li>一个bean里面可以进行组合，可以使用构造方法注入，也可以使用set方法注入。</li>
<li>当bean里面有多个注入时，构造方法在前，set在后，会造成覆盖。构造器方法注入-&gt;字段注入-&gt;属性或普通方法注入.</li>
<li>如何想要使用set方法注入，必须实现默认无参构造方法。如果实现了其他的构造方法，则无参构造方法不会自动生成。（Spring需要先利用无参的构造方法反射创建一个对象，再使用set方法给属性赋值）</li>
</ul>
<h4 id="依赖注入常用的注解"><a href="#依赖注入常用的注解" class="headerlink" title="依赖注入常用的注解"></a>依赖注入常用的注解</h4><ul>
<li>@Qualifier：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以。需要搭配@Autowired</li>
<li>@Autowired默认按类型装配。</li>
<li>@Resource（常用）：直接按照bean的id注入。它可以独立使用。</li>
<li>@Value：用于注入基本类型和String类型的数据。</li>
</ul>
<h4 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h4><p>​    IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p>
<p>​    常用的两个容器：</p>
<ul>
<li>BeanFactory 容器：最简单的容器，只提供基础的依赖注入的功能。</li>
<li>ApplicationContext 容器：Spring上下文，比较复杂的容器。提供了其他的功能。</li>
</ul>
<h5 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h5><table>
<thead>
<tr>
<th align="center">作用域</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">singleton</td>
<td align="center">在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值。（不是线程安全的）</td>
</tr>
<tr>
<td align="center">prototype</td>
<td align="center">每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td>
</tr>
<tr>
<td align="center">global-session</td>
<td align="center">一般用于Portlet应用环境，该作用域仅适用于WebApplicationContext环境</td>
</tr>
</tbody></table>
<h5 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h5><p>全套初始化方法及其标准顺序是：</p>
<ul>
<li>BeanNameAware 的setBeanName：在创建此 bean 的 bean 工厂中设置 bean 的名称。</li>
<li>BeanClassLoaderAware 的setBeanClassLoader：将 bean class loader提供给 bean 实例的回调。</li>
<li>BeanFactoryAware 的setBeanFactory：将拥有工厂提供给 bean 实例的回调。</li>
<li>EnvironmentAware 的setEnvironment：设置该组件运行的Environment 。</li>
<li>EmbeddedValueResolverAware 的setEmbeddedValueResolver：设置 StringValueResolver 以用于解析嵌入的定义值。<br>ResourceLoaderAware 的setResourceLoader （仅在应用程序上下文中运行时适用）：设置运行此对象的 ResourceLoader。</li>
<li>ApplicationEventPublisherAware 的setApplicationEventPublisher （仅在应用程序上下文中运行时适用）：设置运行此对象的 ApplicationEventPublisher。</li>
<li>MessageSourceAware 的setMessageSource （仅在应用程序上下文中运行时适用）：设置此对象运行所在的 MessageSource。</li>
<li>ApplicationContextAware 的setApplicationContext （仅在应用程序上下文中运行时适用）：设置此对象运行所在的 ApplicationContext。通常此调用将用于初始化对象。</li>
<li>ServletContextAware 的setServletContext （仅在 web 应用上下文中运行时适用）：设置该对象运行所在的ServletContext 。</li>
<li>BeanPostProcessors 的postProcessBeforeInitialization方法：在任何 bean 初始化回调（如 InitializingBean 的afterPropertiesSet或自定义初始化方法）之前，将此BeanPostProcessor应用于给定的新 bean 实例。bean 已经被填充了属性值。 返回的 bean 实例可能是原始实例的包装器。默认实现按原样返回给定的bean 。</li>
<li>InitializingBean 的afterPropertiesSet：在设置所有 bean 属性并满足BeanFactoryAware ， ApplicationContextAware等之后，由包含BeanFactory调用。</li>
<li>自定义初始化方法定义：</li>
<li>BeanPostProcessors 的postProcessAfterInitialization方法：在任何 bean 初始化回调（如 InitializingBean 的afterPropertiesSet或自定义初始化方法）之后，将此BeanPostProcessor应用于给定的新 bean 实例。bean 已经被填充了属性值。 返回的 bean 实例可能是原始实例的包装器。</li>
</ul>
<p>​    在关闭 bean 工厂时，以下生命周期方法适用：</p>
<ul>
<li>DestructionAwareBeanPostProcessors 的postProcessBeforeDestruction方法：在销毁之前将此 BeanPostProcessor 应用于给定的 bean 实例，例如调用自定义销毁回调。</li>
<li>DisposableBean 的destroy：在销毁 bean 时由包含BeanFactory调用。</li>
<li>自定义销毁方法定义：</li>
</ul>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210618220738157.png" alt="image-20210618220738157"></p>
<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><p>​    上面的方式都是通过xml配置bean，非常的复杂和繁琐。自动装配就是解决这个问题，但是自动装配不能装配所谓的简单类型包括基本类型，字符串和类。</p>
<p>​    自动装配的模式：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">no</td>
<td align="center">这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。在依赖注入章节你已经看到这个了。</td>
</tr>
<tr>
<td align="center">byName</td>
<td align="center">由属性名自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的 beans 的属性进行连接。</td>
</tr>
<tr>
<td align="center">byType</td>
<td align="center">由属性数据类型自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的<strong>类型</strong>匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。</td>
</tr>
<tr>
<td align="center">constructor</td>
<td align="center">类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。</td>
</tr>
<tr>
<td align="center">autodetect（3.0版本不支持）</td>
<td align="center">Spring首先尝试通过 constructor 使用自动装配来连接，如果它不执行，Spring 尝试通过 byType 来自动装配。</td>
</tr>
</tbody></table>
<h3 id="AOP相关知识点"><a href="#AOP相关知识点" class="headerlink" title="AOP相关知识点"></a>AOP相关知识点</h3><p>​    面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。跨一个应用程序的多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。</p>
<p>​    当出现多个对象需要一个公共行为时，在每个对象里面编写也是不太现实的，所以引入了AOP。AOP有两种实现方式：基于JDK和CGLIB。</p>
<p>​    AOP中的几个概念：</p>
<table>
<thead>
<tr>
<th align="center">项</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Aspect</td>
<td align="center">一个模块具有一组提供横切需求的 APIs。例如，一个日志模块为了记录日志将被 AOP 方面调用。应用程序可以拥有任意数量的方面，这取决于需求。</td>
</tr>
<tr>
<td align="center">Join point</td>
<td align="center">在你的应用程序中它代表一个点，你可以在插件 AOP 方面。你也能说，它是在实际的应用程序中，其中一个操作将使用 Spring AOP 框架。</td>
</tr>
<tr>
<td align="center">Advice</td>
<td align="center">这是实际行动之前或之后执行的方法。这是在程序执行期间通过 Spring AOP 框架实际被调用的代码。</td>
</tr>
<tr>
<td align="center">Pointcut</td>
<td align="center">这是一组一个或多个连接点，通知应该被执行。你可以使用表达式或模式指定切入点正如我们将在 AOP 的例子中看到的。</td>
</tr>
<tr>
<td align="center">Introduction</td>
<td align="center">引用允许你添加新方法或属性到现有的类中。</td>
</tr>
<tr>
<td align="center">Target object</td>
<td align="center">被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。</td>
</tr>
<tr>
<td align="center">Weaving</td>
<td align="center">Weaving 把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。</td>
</tr>
</tbody></table>
<p>​    关于通知的几个概念：</p>
<table>
<thead>
<tr>
<th align="center">通知</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">前置通知</td>
<td align="center">在一个方法执行之前，执行通知。</td>
</tr>
<tr>
<td align="center">后置通知</td>
<td align="center">在一个方法执行之后，不考虑其结果，执行通知。</td>
</tr>
<tr>
<td align="center">返回后通知</td>
<td align="center">在一个方法执行之后，只有在方法成功完成时，才能执行通知。</td>
</tr>
<tr>
<td align="center">抛出异常后通知</td>
<td align="center">在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</td>
</tr>
<tr>
<td align="center">环绕通知</td>
<td align="center">在建议方法调用之前和之后，执行通知。</td>
</tr>
</tbody></table>
<h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><p>​    Spring 框架在不同的底层事务管理 APIs 的顶部提供了一个抽象层。Spring 的事务支持旨在通过添加事务能力到 POJOs 来提供给 EJB 事务一个选择方案。Spring 支持编程式和声明式事务管理。EJBs 需要一个应用程序服务器，但 Spring 事务管理可以在不需要应用程序服务器的情况下实现。同时，Spring直接抛出Exception就不会回滚，而抛出RuntimeException或其子类才会回滚</p>
<p>​    Spring事务管理的五大属性：隔离级别、传播行为、是否只读、事务超时、回滚规则。</p>
<p>​    隔离级别：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ISOLATION_DEFAULT</td>
<td align="center">使用底层数据存储的默认隔离级别。 所有其他级别对应于 JDBC 隔离级别。</td>
</tr>
<tr>
<td align="center">ISOLATION_READ_UNCOMMITTED</td>
<td align="center">表示可能发生脏读、不可重复读和幻读。<br/>此级别允许由一个事务更改的行在提交该行中的任何更改之前被另一个事务读取（“脏读”）。 如果任何更改被回滚，则第二个事务将检索到无效行。</td>
</tr>
<tr>
<td align="center">ISOLATION_READ_COMMITTED</td>
<td align="center">表示防止脏读； 可能发生不可重复读和幻读。<br/>此级别仅禁止事务读取其中包含未提交更改的行。</td>
</tr>
<tr>
<td align="center">ISOLATION_REPEATABLE_READ</td>
<td align="center">表示防止脏读和不可重复读； 可能会发生幻读。<br/>此级别禁止事务读取未提交更改的行，也禁止一个事务读取一行，第二个事务更改该行，第一个事务重新读取该行，第二个获取不同值的情况时间（“不可重复读取”）。</td>
</tr>
<tr>
<td align="center">ISOLATION_SERIALIZABLE</td>
<td align="center">表示防止脏读、不可重复读和幻读。<br/>该级别包括ISOLATION_REPEATABLE_READ的禁止，并进一步禁止一个事务读取满足WHERE条件的所有行，第二个事务插入满足WHERE条件的行，第一个事务重新读取相同条件的情况，检索第二次阅读中的附加“幻影”行。</td>
</tr>
</tbody></table>
<p>传播行为：传播行为定义关于客户端和被调用方法的事务边界。Spring定义了7中传播行为。</p>
<table>
<thead>
<tr>
<th align="center">传播行为</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PROPAGATION_REQUIRED</td>
<td align="center">支持当前事务； 如果不存在，则创建一个新的。 类似于同名的 EJB 事务属性。<br>如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</td>
</tr>
<tr>
<td align="center">PROPAGATION_SUPPORTS</td>
<td align="center">支持当前事务； 如果不存在则以非事务方式执行。 类似于同名的 EJB 事务属性。<br/>当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</td>
</tr>
<tr>
<td align="center">PROPAGATION_MANDATORY</td>
<td align="center">支持当前事务； 如果当前事务不存在，则抛出异常。 类似于同名的 EJB 事务属性。<br/>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</td>
</tr>
<tr>
<td align="center">PROPAGATION_REQUIRES_NEW</td>
<td align="center">创建一个新事务，如果存在则暂停当前事务。 类似于同名的 EJB 事务属性。<br/>创建一个新事务，如果存在当前事务，则挂起该事务。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NOT_SUPPORTED</td>
<td align="center">不支持当前事务； 而是始终以非事务方式执行。 类似于同名的 EJB 事务属性。<br/>始终以非事务方式执行,如果当前存在事务，则挂起当前事务</td>
</tr>
<tr>
<td align="center">PROPAGATION_NEVER</td>
<td align="center">不支持当前事务； 如果当前事务存在则抛出异常。 类似于同名的 EJB 事务属性。<br/>不使用事务，如果当前事务存在，则抛出异常</td>
</tr>
<tr>
<td align="center">PROPAGATION_NESTED</td>
<td align="center">如果当前事务存在，则在嵌套事务中执行，否则行为类似于PROPAGATION_REQUIRED 。 EJB 中没有类似的特性。<br/>如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</td>
</tr>
</tbody></table>
<h3 id="Spring面试中问到的问题"><a href="#Spring面试中问到的问题" class="headerlink" title="Spring面试中问到的问题"></a>Spring面试中问到的问题</h3><ul>
<li>Spring启动的流程</li>
</ul>
<p>​    </p>
<ul>
<li>Spring时如何解决循环依赖的</li>
</ul>
<p>​    这里以AB两个bean为例，创建一个bean分为实例化和属性赋值，实例化后的bean还不能使用，属性赋值后才能使用，类似于声明和赋值。实例化A时，发现容器中没有A实例，会创建一个A实例，但是发现A依赖B，再递归去查找B，发现B也没有，于是创建B实例，又发现B依赖A，但这时候A已经有了一个实例化，虽然只是半成品，把A赋值给B里面后，返回递归，最后A的实例化完成。</p>
<ul>
<li>Spring中bean的生命周期</li>
</ul>
<p>​    Spring中bean的生命周期主要包含四个阶段：实例化、属性赋值、初始化、销毁。实例化相当于声明，有三种实例化的方法，普通构造方法创建、静态工厂方法创建、实例化工厂方法创建。实例化和依赖注入的区别：实例化后的bean不是直接能使用的，还需要后续的初始化操作，依赖注入的bean是直接可以使用的。属性赋值阶段：主要是为bean的属性进行赋值，例如A依赖B，需要在这个时候将B注入到A中。然后就是初始化了：有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作。然后初始化的bean就是可以使用的。最后就是销毁bean，通过DisposableBean 和 destory-method 。</p>
<ul>
<li>Spring中的三级缓存和解决循环依赖</li>
</ul>
<p>​    Spring中的三级缓存：singletonObjects：一级缓存，主要存放初始化完成之后的对象。singletonFactories：三级缓存：存放的工厂对象，能够生成的实例化后的对象。earlySingletonObjects：相当于半成品：实例化完成，但是初始化没有完成的对象。这里以AB两个实例举例。A实例化后，发现需要依赖B，在一二级缓存中查找，发现没有找到，在三级缓存中调用工厂方法实例化，实例化B的过程中发现需要注入A，在二级缓存中找到，将其注入。返回到A到初始化，A初始化完成，放入一级缓存。需要注意，Spring中多例的循环依赖无法解决，会报错。</p>
<ul>
<li>Spring容器的启动流程</li>
</ul>
<p>​    这一块的代码主要是在ApplicationContext里面，使用注解的话就是AnnotationConfigApplicationContext，使用xml的话就在ClassPathXmlApplicationContext。主要流程就是1）初始化Spring容器。2）将配置类的BeanDefinition注册到容器中。3）刷新容器。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Spring内部的：</p>
<p>//IOC - 控制反转</p>
<p>//IOC容器</p>
<p>//Spring 负责创建和管理对象 (Bean)的生命周期和配置（比较复杂，可以后期详细看看）</p>
<p>//Spring中bean的声明周期和作用域</p>
<p>//自动装配的原理</p>
<p>//阅读Spring两个容器相关的源码</p>
<p>//AOP - 面向切面编程</p>
<p>//Spring核心容器</p>
<p>//事务管理 - 提供了用于事务管理的通用抽象层</p>
<p>Spring是如何加载xml文件的（可能比较复杂，后续再看源码）</p>
<p>Spring中注解的含义</p>
<p>//Spring的事务</p>
<p>Mybatis相关的</p>
<p>JDBC 异常</p>
<p>JDBC和ORM</p>
<p>Spring如何使用jdbc连接的</p>
<p>Mybatis的原理和使用的逻辑</p>
<p>web</p>
<p>WEB和websocket</p>
<p>Spring中Servlet</p>
<p>SpringBoot和Spring的区别</p>
<p>SpringBoot的启动流程和原理</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/%E6%A1%86%E6%9E%B6/Spring%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6/spring%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<h1 id="SpringBoot学习"><a href="#SpringBoot学习" class="headerlink" title="SpringBoot学习"></a>SpringBoot学习</h1><h2 id="建立一个SpringBoot项目"><a href="#建立一个SpringBoot项目" class="headerlink" title="建立一个SpringBoot项目"></a>建立一个SpringBoot项目</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>新建一个项目，在spring的官网上面，网址如下：<a href="https://start.spring.io/">https://start.spring.io</a></p>
<p>该页面打开如下：选择自己合适的选项，点击下载即可下载一个zip包，解压就是你的项目。比较方便。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/%E5%9B%BE%E5%83%8F2020-5-28%20%E4%B8%8B%E5%8D%887.08.JPG" alt="图像2020-5-28 下午7.08"></p>
<h3 id="导入IDE"><a href="#导入IDE" class="headerlink" title="导入IDE"></a>导入IDE</h3><p>​    这里使用自己的IDE导入刚才解压的目录，这里没有什么可以讲的点，就是IDE的使用方法，不在本次记录范围内。我使用的IDEA，导入后如下图。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200528191523635.png" alt="image-20200528191523635"></p>
<h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>​    找到启动类，右键启动即可，第一个SpringBoot项目就启动成功了。中间没有什么可讲的，都是IDE的使用方法，注意导入时的选项即可。</p>
<p><img src="https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200528191813066.png" alt="image-20200528191813066"></p>
<h3 id="背后的事情"><a href="#背后的事情" class="headerlink" title="背后的事情"></a>背后的事情</h3><p>​    其实背后的事情非常复杂，Spring做了很多我们不了解的事情，因为这些东西比较琐碎，所以后面也是想起来就提提吧，能力有限，欢迎大家补充。今天就记录一下我知道的，大部分都是网上粘贴复制的。</p>
<p>​    SpringBoot是基于Spring开发的一个框架，随着Spring在Java中越来越不可或缺，SpringBoot也就越来越流行。按照我的理解就是简化开发人员的工作量，将一些繁琐的工作省略或者约定好，让资本更好的压榨我们。他的特点有下面的几点。（百度的）</p>
<ul>
<li><p>可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs。</p>
</li>
<li><p>内嵌Tomcat或Jetty等Servlet容器。</p>
</li>
<li><p>提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置。</p>
</li>
<li><p>尽可能自动配置Spring容器。</p>
</li>
<li><p>提供准备好的特性，如指标、健康检查和外部化配置。</p>
</li>
<li><p>绝对没有代码生成，不需要XML配置。      </p>
<p>不难看出这个框架就是为了使的开发人员的代码敲的越来越快（万恶的资本主义）。SpringBoot</p>
</li>
</ul>
<p>的两个策略：开箱即用和约定优于配置（百度）。目的也是让更多的东西成为约定或者减少不必要的配置。  </p>
<p>​        作为开发人员，使用工具固然重要，但是不能一直认为工具就是工具，作为编程人，要了解工具背后的设计思想和原理，这样才能开发出类似于SpringBoot这样的工具（可把我厉害坏了，插会腰）。我一直认为代码谁都可以写，但是思想这种东西抄不来，也模仿不了。但是正是思想这种东西才将程序员分为三六九等，说了半天，没有实质性的东西。。。诸君，努力吧。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring相关框架</category>
      </categories>
  </entry>
</search>
