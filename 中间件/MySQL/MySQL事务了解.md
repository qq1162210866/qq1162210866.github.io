## MySQL事务了解

​	上次使用了最基本的MySQL，只是简单的查询一个表中的数据，这次练习一下事务。开始。

​	MySQL有四层架构，分别为：**连接层**、**服务层**、**引擎层**、**存储层**。这四层的作用如下：

![image-20200608233609217](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200608233609217.png)

​	需要注意的是，事务的执行是在引擎层，并不是服务层。目前使用最广泛的就是InnoDB，其他的引擎很少有支持事务的。

​	事务的特性有四个。**原子性**、**一致性**、**隔离性**、**持久性**。四个特性简称为**ACID**，其含义和解释如下：

* 原子性：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。
* 一致性：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。
* 隔离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
* 持久性：当事务正确完成后，它对于数据的改变是永久性的。

​	MySQL中的事务为了保证原子性，通过undo log日志来进行事务的撤销和数据的回滚。一致性则是MySQL中最终追求的目标，需要其他三个特性的支持。为了保持隔离性，MySQL中使用锁来对数据进行保护和同步。持久性则是使用InnoDB存储引擎中的redo log日志来实现的。下面分别介绍。

* undo log 日志。回滚日志的作用就是对数据进行回滚，属于逻辑日志。它对SQL语句执行相关的信息进行记录。当发生回滚时，InnoDB引擎会根据undo log日志中的记录做与之前相反的工作。比如对于每个数据插入操作（insert），回滚时会执行数据删除操作（delete）。

* 说锁之前先说一下MySQL中的数据存储形式，分为：数据库、数据表、数据页、行。各个形式如下：

  ![image-20200612170140499](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612170140499.png)

  MySQL中的锁有下面几种：行锁、表锁、页锁。粒度分别如下：

  * 行锁：粒度最小的锁，表示只针对当前操作的行进行加锁；

  * 表锁：粒度最大的锁，表示当前的操作对整张表加锁；

  * 页锁：粒度介于行级锁和表级锁中间的一种锁，表示对页进行加锁；

  表锁因为锁定的是整张表，所以并发性比较差，行锁如果过多，占用的资源比较多。
  
  涉及到锁了，就要提及数据的读写问题了，读写问题有三类：脏读、不可重复读、幻读。
  
  * 脏读。当前事务中读到其他事务未提交的数据，也就是脏数据。
  
    ![image-20200612202259136](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202259136.png)
  
  * 不可重复读。在事务A中先后两次读取同一个数据，但是两次读取的结果不一样。
  
    ![image-20200612202326662](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202326662.png)
  
  * 幻读。在事务A中按照某个条件先后两次查询数据库，两次查询结果的行数不同，这种现象称为幻读。
  
    ![image-20200612202505995](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202505995.png)
  
  根据这些问题产生了四种隔离级别，如下图：
  
  ![image-20200612202611299](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612202611299.png)
  
  然后就是MVCC（多版本的并发控制协议）相当于git，这个可以解决脏读和不可重复读读问题。这个放在后面讲吧。
  
* redo log日志。重做日志是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。InnoDB引擎对数据的更新，是先将更新记录写入redo log日志，然后会在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的**预写式技术（Write Ahead logging）**。这种技术可以大大减少IO操作的频率，提升数据刷新的效率。redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑，比如”给ID=2这一行的a字段加1 "。binlog日志中的内容是二进制的，根据日记格式参数的不同，可能基于SQL语句、基于数据本身或者二者的混合。一般常用记录的都是SQL语句。详细执行步骤如下：（在对redo log写入时有两个阶段的提交，一是binlog写入之前`prepare`状态的写入，二是binlog写入之后`commit`状态的写入。）

  ![image-20200612212946695](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20200612212946695.png)

  其实是看了一篇博客，详细了了解了事务的原理和关于MySQL的一些信息。链接如下：[https://mp.weixin.qq.com/s/HQh_HpbtvJv6Y5k3OAlfsQ](https://mp.weixin.qq.com/s/HQh_HpbtvJv6Y5k3OAlfsQ)

  后面也回简单写一个demo，具体把这些概念了解一下。就这样吧，结束。