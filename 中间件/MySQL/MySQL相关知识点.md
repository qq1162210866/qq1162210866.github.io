# MySQL知识点

## MySQL基础知识

### MySQL查询流程

![image-20210719230933044](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210719230933044.png)

​	分为server层和存储层，innodb就是位于存储层，主要负责对于磁盘的读写。server层主要就是mysql的一些基础服务，以查询sql为例，先是连接器管理连接，然后分析器分析语法是否有错误，没有错误查询缓存，缓存不存在将sql优化，最后调用执行器查询结果。

### MySQL中锁的相关知识点

​	数据库中分为三种情况

​	读-读：没有对数据进行影响，不需要操作。

​	写-写：需要对操作加锁。

​	读-写：会出现脏读、幻读。所以要对写操作加锁。

* 表级锁：开销小，加锁快。不会出现死锁，锁颗粒度大，也就导致发生冲突概率最高，并发度最低。
* 行级锁：开销大，加锁慢。会出现死锁，锁颗粒度小，锁的冲突比较低，并发度最高。
* 页面锁（BDB引擎）：开销介于表级锁和行级锁之间，会出现死锁，锁颗粒度一般，并发度一般。
* 共享锁(Shared Locks)：简称S锁，在事务要读取一条记录时，需要先获取该记录的S锁。S锁可以在同一时刻被多个事务同时持有。
* 排他锁(Exclusive Locks)：简称X锁，在事务要改动一条记录时，需要先获取该记录的X锁。X锁在同一时刻最多只能被一个事务持有。

#### 表级锁

* 意向共享锁(IS锁)：当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加一个意向共享锁(IS锁)，主要是快速查询表中记录有没有被上锁，提升效率。

* 意向排他锁(IX锁)：和上面的类似，只不过是排他锁。
* 自增锁(AUTO-INC锁)：在执行插入语句的时先加上表级别的AUTO-INC锁，插入执行完成后立即释放锁。无法确定插入多少记录时使用。
* 轻量级锁：在插入语句生成AUTO_INCREMENT值时先才获取这个轻量级锁，然后在AUTO_INCREMENT值生成之后就释放轻量级锁。确定插入多少列时使用。

#### 行级锁

![image-20210614213241155](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614213241155.png)

* 记录锁(Record Locks) 所谓记录，就是指聚簇索引中真实存放的数据，比如上面的1、4、7、10都是记录。
* 间隙锁(Gap Locks) 间隙指的是两个记录之间逻辑上尚未填入数据的部分，比如上述的(1,4)、(4,7)等。
* 临键锁(Next-Key Locks) 临键指的是间隙加上它右边的记录组成的左开右闭区间。比如上述的(1,4]、(4,7]等。

###  数据库引擎

​	数据引擎常用的四种

* InnoDB：InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。
  * InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。
  * InnoDB是为处理巨大数据量的最大性能设计。
  * InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。
  * InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。
  * InnoDB被用在众多需要高性能的大型数据库站点上。
* MyISAM：MyISAM基于ISAM存储引擎，并对其进行扩展。MyISAM拥有较高的插入、查询速度，但不支持事物。
  * 大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持。
  * 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。
  * 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16
  * 使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）

### MySQL中的事务

​	事务包含四大特性，即**原子性（Atomicity）**、**一致性（Consistency）**、**隔离性（Isolation）**和**持久性（Durability）**(ACID)。

* 原子性（Atomicity） 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的。 
* 一致性（Consistency） 一致性是指数据库的完整性约束没有被破坏，在事务执行前后都是合法的数据状态。这里的一致可以表示数据库自身的约束没有被破坏，比如某些字段的唯一性约束、字段长度约束等等；还可以表示各种实际场景下的业务约束，比如上面转账操作，一个账户减少的金额和另一个账户增加的金额一定是一样的。应用系统从一个正确的状态到另一个正确的状态。
*  隔离性（Isolation） 隔离性指的是多个事务彼此之间是完全隔离、互不干扰的。隔离性的最终目的也是为了保证一致性。
*  持久性（Durability） 持久性是指只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态。

#### 关于事务的其他知识点

- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
- 事务用来管理 insert,update,delete 语句
- 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。

### MySQL中的隔离级别

#### 出现数据错乱的情况

* 脏写：脏写是指一个事务修改了其它事务未提交的数据。

![image-20210614201951702](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614201951702.png)

* 脏读：脏读是指一个事务读到了其它事务未提交的数据。

![image-20210614202018063](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202018063.png)

* 不可重复读：不可重复读指的是在一个事务执行过程中，读取到其它事务已提交的数据，导致两次读取的结果不一致。

![image-20210614202120848](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202120848.png)

* 幻读：幻读是指的是在一个事务执行过程中，读取到了其他事务新插入数据，导致两次读取的结果不一致。

![image-20210614202228292](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210614202228292.png)

#### MySQL中的隔离级别

​	SQL中隔离级别有四种：

* READ UNCOMMITTED：未提交读。 就是一个事务可以读取另一个未提交事务的数据。
* READ COMMITTED：已提交读。 就是事务要等另一个事物提交后才能读取数据
* REPEATABLE READ：可重复读。 就是在开始读取数据（事务开启）时，不再允许修改操作
* SERIALIZABLE：串行化。事务串行化顺序执行，可以避免脏读，不可重复读与幻读。（但是效率低）

|           隔离级别           | 脏读  | 不可重复读 |         幻读          |
| :--------------------------: | :---: | :--------: | :-------------------: |
| 未提交读（READ UNCOMMITTED） | false |   false    |         false         |
|  已提交读（READ COMMITTED）  | true  |   false    |         false         |
| 可重复读（REPEATABLE READ）  | true  |    true    | false（InnoDB为true） |
|    串行化（SERIALIZABLE）    | true  |    true    |         true          |

#### MySQL的处理办法（MVCC）

​	MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。主要实现有两个手段：版本链和ReadView。

##### 版本链

​	对每条记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。修改一行记录时，都会将本次的事务ID和undo日志记录下来。undo日志里面则是存放的旧值。

##### ReadView

​	ReadView包含四个内容：

* m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。
* min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
* max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。
* creator_trx_id：表示生成该ReadView的事务的事务id。

流程：

* 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
* 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
* 如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
* 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

​	READ COMMITTED（读提交）在每次读取数据前都会生成一个ReadView，这样就能保证每次都能读到其它事务已提交的数据。

​	REPEATABLE READ （可重复读）只在第一次读取数据时生成一个ReadView，这样就能保证后续读取的结果完全一致。

### 事务日志

​	MySQL中日志有二进制日志（binlog）、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种日志：redo log（重做日志）和undo log（回滚日志）。

#### redo log（重做日志）

​	重做日志（redo log）是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。

​	InnoDB引擎对数据的更新，是先将更新记录写入redo log日志，然后会在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的预写式技术（Write Ahead logging）。

​	redo log日志的大小是固定的，为了能够持续不断的对更新记录进行写入，在redo log日志中设置了两个标志位置，checkpoint和write_pos，分别表示记录擦除的位置和记录写入的位置。

​	当write_pos标志到了日志结尾时，会从结尾跳至日志头部进行重新循环写入。所以redo log的逻辑结构并不是线性的，而是可看作一个圆周运动。write_pos与checkpoint中间的空间可用于写入新数据，写入和擦除都是往后推移，循环往复的。

​	缓冲池`buffer pool`是在内存中分配的一个区域，包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当数据修改时，除了修改buffer pool中的数据，还会在redo log中记录这次操作；当事务提交时，会根据redo log的记录对数据进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复，从而保证了事务的持久性，使得数据库获得crash-safe能力。

​	redo log日志可分为两个部分，一是存在易失性内存中的缓存日志redo log buff，二是保存在磁盘上的redo log日志文件redo log file。

​	为了确保每次记录都能够写入到磁盘中的日志中，每次将redo log buffer中的日志写入redo log file的过程中都会调用一次操作系统的fsync操作。（和redis中AOF备份类似）

#### binlog（二进制日志）

​	二进制日志binlog是服务层的日志，还被称为归档日志。binlog主要记录数据库的变化情况，内容包括数据库所有的更新操作。所有涉及数据变动的操作，都要记录进二进制日志中。因此有了binlog可以很方便的对数据进行复制和备份，因而也常用作主从库的同步。二进制日志的文件大小不固定，写完会切换下一个文件。

​	和redo log的区别：redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑。redo log是基于crash recovery，保证MySQL宕机后的数据恢复；而binlog是基于point-in-time recovery，保证服务器可以基于时间点对数据进行恢复，或者对数据进行备份。binlog是服务层的日志，因此所有引擎都能够使用。redo log是引擎层的日志，是InnoDB引擎持有。

​	MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。不仅如此，在对redo log写入时有两个阶段的提交，一是binlog写入之前`prepare`状态的写入，二是binlog写入之后`commit`状态的写入。

#### undo log（回滚日志）

​	回滚日志同样也是InnoDB引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。但是undo log不redo log不一样，它属于逻辑日志。它对SQL语句执行相关的信息进行记录。

#### 什么是双阶段提交

​	修改一条数据时，以innodb为例，innodb在内存中修改完毕后，将其写入redolog，状态标记为准备，然后返回结果，服务层将这次的修改写入binlog，标记事务完成，然后redolog将状态标记为提交，等待将其写入磁盘中。双阶段提交是为了保证两个日志中逻辑上的一致，同一条数据不会因为宕机出现混乱。

###  MySQL中数据类型

​	MySQL中数据类型分为三大块，数值类型、日期和时间类型、字符串类型。

​	数值类型：

![image-20210617180123419](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180123419.png)

​	日期和时间类型

![image-20210617180149314](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180149314.png)

​	字符串类型

![image-20210617180214099](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210617180214099.png)

### 索引

#### B+树概念

##### 选择B+实现的原因

​	因为Mysql查询的形式是有以下几种：1）查询特定数据。2）查询范围数据。

* hash表并不支持范围查询，其他平衡树也是对于范围查询很低效。
* B树和B+树的区别就是：B+树的数据存储只在叶子节点。因为系统IO并不是需要什么就读取什么，而是会读取这块空间的周围存储。B树因为非叶子结点也存储数据，所以会造成多次的IO读取。B+树因为叶子结点是链表的形式，所以可以较少次的IO读取。
* 跳表比较适合内存空间存储，对于磁盘空间查询不友好。（也是没有利用磁盘缓存的特点）跳表的查询相对于B+树稍微差些。

##### B+树概念

![image-20210615113558216](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20210615113558216.png)

* B+树非叶子节点上是不存储数据的，仅存储键值。键就是排序的因素，值就是直线下一个节点的地址。
* B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值。
* B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。
* 根节点至少拥有两个子树
* 每个树节点最多拥有M个子树
* 每个树节点(除了根节点)拥有至少M/2个子树

##### B+树的性质

* 索引字段要尽量的小。因为索引字段过大，就会导致数据项变小，即B+树的阶数变小。导致B+树的高度变高，读取IO的次数也变多。
* 索引的最左匹配特性。因为B+树建立复合索引时是根据从左到右的方向来建立搜索树的，查询也是根据第一个字段来决定查询的方向，如果没有带第一个字段，就无法匹配。查到第一个字段后，这段数据的附近则是根据其他索引进行排序的。

#### MySQL中索引的分类

* 按照数据结构可以分为B+tree索引、Hash索引、Full-text索引。

* B+tree索引：上面讲的差不多，有点就是查询快，读取IO磁盘的次数较低

* Hash索引：单个查询可以快速，但是范围查询就很慢了

* Full-text索引：full-text在mysql里仅有myisam支持它，而且支持full-text的字段只有char、varchar、text数据类型。full-text主要是用来代替like "%***%"效率低下的问题。

	按照物理存储可以分为：聚簇索引、二级索引（辅助索引或者非聚簇索引）

* 聚簇索引：聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。

* 非聚簇索引：二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。

	按照字段特性可以分类为：主键索引、普通索引、前缀索引。

* 主键索引：建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。

* 普通索引：建立在普通字段上的索引被称为普通索引。

* 前缀索引：前缀索引是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。

* 唯一索引：建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。

	按照字段个数可以分类为：单列索引、联合索引（复合索引、组合索引）。

* 单列索引：建立在单个列上的索引被称为单列索引。

* 联合索引：建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。

#### 建立索引的几个原则

* 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
* =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
* 尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。
* 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。
* 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
* 在建立联合索引的时候，安排索引内的字段顺序的原则：1.如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。2.在必须维护两个重复索引时，这个时候需要考虑字段大小问题。
* 

#### 其他

* 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。
* 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。

### MySQL中的存储过程

储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。特点有以下几点：

* 存储过程能实现较快的执行速度。
* 存储过程允许标准组件是编程。
* 存储过程可被作为一种安全机制来充分利用。
* 存储过程能过减少网络流量。

### SQL中的范式理解

#### 第一范式（1NF）

​	在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 

​	所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。

​	如：学生表中，有3个字段 学号 姓名 家庭地址(XXX省XXX市）,由于地址字段是可以再拆分的所以不满足第一范式。

​	改造为：学号 姓名 出生省份 出生城市既满足第一范式

#### 第二范式（2NF）

​	第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。
​	第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。

​	如：学生表中 有 学号 姓名 选课号 出生日期 成绩 五个字段， 其中学号为主键，成绩并不依赖与学号，所以不满足第二范式。应该删除选课号，然后构建一张选课表。

#### 第三范式（3NF）

​	满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 

## SQL语法

### WHERE

- 查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。(from后面跟多个表，通过where的形式做限定是内连接，只寻找两个表中都存在的数据)
- 你可以在 WHERE 子句中指定任何条件。
- 你可以使用 AND 或者 OR 指定一个或多个条件。
- WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。
- WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。
- MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。

### UPDATE

​	update 表名称 set 列名称=新值 where 更新条件;

- 你可以同时更新一个或多个字段。
- 你可以在 WHERE 子句中指定任何条件。
- 你可以在一个单独表中同时更新数据。

### DELETE

- 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。
- 你可以在 WHERE 子句中指定任何条件
- 您可以在单个表中一次性删除记录。

### LIKE

- 你可以在 WHERE 子句中指定任何条件。
- 你可以在 WHERE 子句中使用LIKE子句。
- 你可以使用LIKE子句代替等号 **=**。
- LIKE 通常与 **%** 一同使用，类似于一个元字符的搜索。
- 你可以使用 AND 或者 OR 指定一个或多个条件。
- 你可以在 DELETE 或 UPDATE 命令中使用 WHERE...LIKE 子句来指定条件。
- **%**：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。
- **_**：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。
- **[]**：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。
- **[^]** ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。
- 查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。

### UNION

```sql
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions]
UNION [ALL | DISTINCT]
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions];
```

MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。

- **DISTINCT:** 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。
- **ALL:** 可选，返回所有结果集，包含重复数据。
- 要注意UNION的两个查询条件返回结果要一致。
- UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！
- 官网要求两个子查询列的名称和数据类型、和数目必须一致。但是数据类型和名称可以不一致也可以执行，只是后续又可能会出错。
- UNION结果集的列名取自第一个SELECT语句的列名。
- 如果相应的SELECT列的数据类型不匹配，则UNION结果中的列的类型和长度将考虑所有SELECT语句检索的值。

### **ORDER BY** 

- 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。
- 你可以设定多个字段来排序。
- 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。
- 你可以添加 WHERE...LIKE 子句来设置条件。
- 如果字符集采用的是 utf8(万国码)，需要先对字段进行转码然后排序：`ORDER BY CONVERT(runoob_title using gbk);`

### GROUP BY 

GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。(count是统计，sum是求和)

### null值比较

MySQL提供了三大运算符:用来对bull值比较

- **IS NULL:** 当列的值是 NULL,此运算符返回 true。
- **IS NOT NULL:** 当列的值不为 NULL, 运算符返回 true。
- **<=>:** 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。
- 可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：

### 事务

#### 事务的控制语句

- BEGIN 或 START TRANSACTION 显式地开启一个事务；
- COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
- ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
- SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
- RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
- ROLLBACK TO identifier 把事务回滚到标记点；
- SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

### 函数

常用的函数，这个链接：[菜鸟网络](https://www.runoob.com/mysql/mysql-functions.html ) 

```sql
DENSE_RANK() OVER (
    PARTITION BY <expression>[{,<expression>...}]
    ORDER BY <expression> [ASC|DESC], [{,<expression>...}]
) 
```

- 首先，`PARTITION BY`子句将`FROM`子句生成的结果集划分为分区。`DENSE_RANK()`函数应用于每个分区。
- 其次，`ORDER BY` 子句指定`DENSE_RANK()`函数操作的每个分区中的行顺序。
- 与`RANK()`函数不同，`DENSE_RANK()`函数始终返回连续的排名值。

* LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。也可以使用OFFSET设定偏移量，你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。
* GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。显示为一行，所以要对其他列进行聚合显示，求和或者求最大。
* where后面的条件需要带上引号，单引号和双引号都可以。除了int和数字不需要带引号。
* mysql没有full join，可以通过将左连接和右连接组合一起打到full join
* 各个SQL关键字执行的顺序

  1. FROM, including JOINs
  2. WHERE
  3. GROUP BY
  4. HAVING
  5. WINDOW functions
  6. SELECT
  7. DISTINCT
  8. UNION
  9. ORDER BY
  10. LIMIT and OFFSET
* `count(1)和count（*）count（cloum）统计列值的数量时，会忽略空值，当括号内的值不可能为空时，就直接统计行数。count（1）和count（*）都是一样的，都是统计行数，都是根据索引来统计行数。`
* group by后面的having中的字段必须要查询到，如果相对表做个筛选，可以在group by前面添加where语句，having语句是对group by语句到补充。
* in后面可以跟多个字段，和concat函数类似。
* join当两个表中不匹配时，不返回任何行。
* 慢查询日志就是查询超过阈值的语句会被记录下来，一般的默认值就是10秒。这个可以设置。
* CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result ...] [ELSE result] END case的用法，一般用来做判断。
* mod函数用来求余的，mod（3,2）返回1
* COALESCE取值的，COALESCE（1，2）如果1为null，就取2。
* `LEFT(Str,length)`函数是一个字符串函数，它返回具有指定长度的字符串的左边部分。str是字符串，length是要截取的长度。
* ROW_NUMBER()是一个窗口函数或分析函数，它为从1开始应用的每一行分配一个序号。用例：id - row_number() over(order by id) as rk
* with tmp as (select * from table） 可以将查询结果作为临时表，子查询互相之间是不能访问的。
* `CROSS JOIN`子句从连接的表返回行的笛卡儿乘积。

## MySQL语句优化

​	大概30点个点。

* 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
* 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
* 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。
* 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。
* 尽量不要使用like进行匹配，要不然也会导致全表扫描。
* in 和 not in 也要慎用，否则会导致全表扫描。
* 如果在 where 子句中使用参数，也会导致全表扫描。
* 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。
* 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。
* 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
* 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
* 不要写一些没有意义的查询，如需要生成一个空表结构。
* 很多时候用 exists 代替 in 是一个好的选择。
* 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。
* 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
* 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。
* 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。
* 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
* 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。
* 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。
* 避免频繁创建和删除临时表，以减少系统表资源的消耗。
* 临时表并不是不可使用，适当地使用它们可以使某些例程更有效。
* 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
* 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
* 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。
* 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。
* 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。
* 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。
* 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
* 尽量避免大事务操作，提高系统并发能力。
* MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。
* MySQL 序列是一组整数：1, 2, 3, ...，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。
* 你可以在 MySQL 数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。

#### 优化工具

首先是通过慢查询日志来记录数据库中查询比较慢的SQL

然后是用explain来判断语句使用了哪些索引，以及一些基础的信息。看看和自己的预期是否一致

最后做对应的修改，例如增加索引或者修正索引的顺序。



### MySQL中问到的问题

* MySQL中优化的场景和具体的做法。

​	举个例子：我们有一个表，里面存储了点位的一些信息，建立了一个联合索引，点位id和设备id。有一次需要执行一条语句，查询某个设备的所有模拟信号点位信息。where后面的语句就是point_id=1 and mn>0 and equipment_id=2.但是后来发现执行的效率不太对，通过explain查询发现只了一个索引，就是point_id，按理说应该走equipment_id。因为最左匹配原则，遇到范围查询时停止使用索引，所以最后造成这样的结果，可以调整sql的顺序，将范围查询放到后面。这样的例子其实在网上挺多的，这个需要你平时写sql多注意和多总结，遇到不正常的SQL去解析查询的流程。

## 缓存

//MySQL中锁的分类，行级锁、排查锁、共享锁

// MySQL中的隔离级别

//事务

//索引

//数据类型

//B+树和B-树

//范式（了解即可）

//优化MySQL

//存储过程

//慢查询日志

慢SQL优化

//MySQL的事务文件就是redolog和undolog

//Mysql binlog和Relog

其他

分布式事务





需要学习窗口函数

ranking>=countNum/2 and ranking<=countNum/2+1



select Id,Company,Salary
from
(
select Id,Company,Salary, 
row_number()over(partition by Company order by Salary)as ranking,
count(Id) over(partition by Company)as cnt
from Employee
)a
where ranking>=cnt/2 and ranking<=cnt/2+1

