### 并发的基本特性

* 并行指多个cpu同时执行多个任务，并发是指一个cpu按照时间片轮流执行多个任务。
* 进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。例如qq就是操作系统中的一个进程。切换进程的开销比较大。线程是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个进程内部可能存在多个线程。线程的切换开销要比进程小的多。qq上面能够同时听音乐和看视频就是不同的线程。
* 并发的三个特点：原子性、可见性、有序性。原子性是指一个线程内的多个操作要么全部执行，要么都不执行。可见性是指当一个线程修改了一个变量的值时，其他线程要立即看到修改的值。有序性指代码在机器中的执行顺序和代码的编写顺序一致。
* 线程池整体流程：首先设置核心线程数和最大线程数，然后提交任务，任务小于核心线程数时，是慢慢创建线程执行任务的，当执行的任务超过了核心线程数，就将后续的任务放入队列中，当队列满了时，创建非核心线程。当峰值过了后，将非核心线程数超时销毁。如果更多，就直接执行拒绝策略，通知任务提交失败，执行失败后的方法。
* 饿汉单例模式和双检锁单例模式是线程安全的，懒汉式线程模式是线程非安全的。

### 关于锁

* 死锁：两个或两个以上的线程在执行过程中，因为争夺对方手中的资源而导致相互等待的现象。比如AB两个线程，A线程拿到1资源，B线程拿到2资源。互相需要对方的21资源，结果两个线程都在等待，造成死锁。
* 死锁的解决办法。1）让线程步骤一致的获取资源。2）让多个线程尽量不要获取相同的资源。3）如果发现自己需要的资源上锁了，放弃手中的资源，再等待。
* synchronized的实现：每一个对象都有一个锁，并且该锁也只有一个内部条件。如果使用synchronized声明方法，该对象的锁就会保护整个方法。静态方法也可以使用synchronized声明，声明后，其他线程无法使用这个类的全部静态方法。普通方法和其他静态方法仍然可以使用。synchronized无论执行完毕或者抛出异常，都会放弃锁。
* synchronized和Lock的区别：Lock可以设定超时时间、synchronized无法获得锁的状态，Lock获取锁时会给失败还是成功、synchronized锁的条件比较单一。synchronized使用的是非公平锁，Lock支持非公平锁（默认）和公平锁。
* volatile不能保证数据的修改具有原子性。只能保证可见性和有序性。线程1修改一个共享变量时，JVM 会把该线程1对应的本地内存中的共享变量值立即刷新到主内存。当线程2读取时，JMM 会把该线程2对应的本地内存置为无效。线程2接下来将从主内存中读取共享变量。有序性就是代码不会被重新编排。
* Happens-Before原则就是为了解决可见性的问题，制定了8个原则，这8个原则梳理出分割线，给程序的运行制定了指导方向。程序顺序规则、锁定规则、volatile变量规则、线程启动规则、线程结束规则、中断规则、终结器规则、传递性规则。
* synchronized和volatile的区别：voaltile只能用在变量级别，synchronized可以用在方法和类上。volatile只能保证变量的可见性和有序性，不能保证原子性，synchronized可以保证原子性。volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
* 悲观锁就是在修改数据的时候默认其他线程也会修改，所以在修改数据时会上锁，修改完毕后将锁释放。乐观锁就是修改数据时默认其他线程不会修改数据，修改完毕后要更新时，如果发现数据被修改了，丢弃自己的操作，如果没有修改，则执行更新。
* CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。但是CAS存在ABA问题，即线程修改为B后又修改回A。可以通过添加版本号的形式来解决这个问题。
* 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
* 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
* 阻塞队列的流程如下：许多线程向阻塞队列中取出指令并且执行相应命令，如果有生产者插入队列中新的元素但是队列长度已经满了，生产者的插入就会被阻塞。消费者移除一个元素时，阻塞队列如果为空，移除操作也会阻塞。
* 原子操作意为不可中断的一个操作。在Java中通过锁和循环CAS实现原子操作。原子类有很多，例如AtomicInterge、AtomicArray。
* ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。
* CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转，翻译成人话就是循环，一般是用一个无限循环实现。这样一来，一个无限循环中，执行一个 CAS 操作，当操作成功，返回 true 时，循环结束；当返回 false 时，接着执行循环，继续尝试 CAS 操作，直到返回 true。
* AQS是指抽象队列的同步器。定义了一套多线程访问共享资源的同步框架，

### 关于集合中的线程安全问题

* HashMap是线程不安全的，它的不安全主要体现在扩容时，因为多个线程的操作，可能会导致环链，即头尾向连，无限循环。具体的实现原理可以看集合那一篇。

* ConcurrentHashMap是线程安全的。它是通过分段锁的形式来解决并发读写的问题的。多个线程读写不同的Segment，是没有影响的。AB同时读写同一个Segment，也是没有影响的。AB同时写，会导致AB中间一个阻塞。保证可见性则是使用voliate关键字。ConcurrentHashMap是采用CAS+Synchronized来实现锁的。segment的多少也指ConcurrentHashMap的并发度，一般是16.
* String效率较低，StringBuffer和StringBuilder修改频繁时效率较高并且占用内存少，前者线程线程安全，后者多线程状态下可能会出现问题。
* SynchronizedMap是通过锁住一整张表来实现线程安全的，效率相对于ConcurrentHashMap很低。
* CopyOnWriteArrayList，写数组的拷贝，支持高效率并发且是线程安全的,读操作无锁的ArrayList。所有可变操作都是通过对底层数组进行一次新的复制来实现。CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里。

### ThreadLocal

实现原理：每个线程都有一个ThreadLocalMap，这个map的key就是弱引用指向的ThreadLocal对象，value就是你要放入值。每个线程都可以获取自己线程独有的map，从而获取对应ThreadLocal对象的值。也就是value。

可能出现的问题：可能出现的问题就是内存溢出。因为Thrad中map存放的key是弱引用，所以在垃圾回收的时候会将这个弱引用回收，导致key为null。无法获取value，时间长了，慢慢就会导致内存溢出。可以在使用完毕后，调用remove方法解决这个问题，同时在ThreadLocal的get方法也会清楚nullkey。

缓存

当ThreadLocal不用时，将其置为空，因为Thread中的map的key是弱引用，所以在下一次垃圾回收时，会直接将这个对象回收，避免造成内存溢出。如果强引用的话，因为key一直指向ThreadLocal，所以一直不会回收。

当key为null时，这个时候无法访问到value，所以可能会造成内存溢出。可以通过remove方法来避免。本身调用get方法到时候也会将null值回收。

### HashMap中存在的线程安全问题

​	安全问题有几点：扩容时出现链表死循环的现象、扩容的时候出现数据丢失的情况、size在多线程操作的时候也会出现不正确的情况、put方法时，hash冲突会出现数据丢失的情况。

​	负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。

hashmap如何putnull值，会将这个元素放在第0个坐标。