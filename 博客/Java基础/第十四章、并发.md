## Java中并发了解和学习

​	了解Java中的并发需要先清楚进程和线程的区别

​	进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

​	线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。

​	说的更加通俗一点，进程相当于你电脑运行的各个软件，满足的你的不通需求。线程相当于进程中更加小的进程，例如打游戏时，你既可以看到画面，也能听到游戏的声音，这里就是不同的线程。线程和进程的区别本质在于进程之间的变量不通用，但是线程之间时通用的，所以线程之间的通信要比进程有效的多。同时，创建、撤销线程要比进程开销要小得多。下面就来讲讲Java中的线程和并发。

### 线程的状态

​	线程的状态有六种。新创建、可运行、被阻塞、等待、计时等待、被终止。这六种状态的图序如下图。![IMG_CC357226F5D1-1](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/IMG_CC357226F5D1-1.jpeg)

### 线程的属性

​	说完了线程的状态，下面就要说一下线程的属性，线程的属性有线程优先级、守护线程、线程组、未捕获异常的处理器。

*  需要注意的是Java中线程的优先级依赖于底层系统的计算，说到底Java还是属于应用层，系统底层也有着自己的优先级，所以优先级的设置只能使该线程在Java中的优先级较高，在底层的优先级不能够确定。
* 当虚拟机中只剩下守护线程时，虚拟机就退出了，守护线程，字如其意，有其他线程让守护线程守护，守护线程才有意义。

### 同步

​	并发其实要解决的问题就是多个线程共同使用统一资源的问题（可能有误，欢迎指正）。Java为了防止代码块被并发的访问，最后导致数据的不稳定性。Java提供了一个syncchronized关键字，同时也提供了一个ReentrantLock类。下面就举一个简单的例子。银行转账（大家都用这个例子，我也用）。如果让一百个线程，随机往100个用户里面随机转账，转账完毕后就睡眠。最开始还能保持总金额没有变化，但是随着运行时间越来越长，总金额有可能变大也有可能变小，但是很小的可能会仍然保持不变。这种不确定性就是程序员最害怕的。下面也是用ReentrantLock类来改善这个例子，每次转账时对金额上锁，达到总金额不变的目的。代码如下：

```java
package syncTrain;

import java.util.Arrays;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * LockBank.java
 * Description: 带锁的银行类
 *
 * @author Peng Shiquan
 * @date 2020/11/8
 */
public class LockBank {

    private final double[] accounts;
    /**
     * 条件锁
     */
    private Lock banlLock;
    private Condition sufficientFunds;

    /**
     * Description: 初始化
     *
     * @param customerNum
     * @param balance
     * @return
     * @Author: Peng Shiquan
     * @Date: 2020/11/8
     */
    public LockBank(int customerNum, double balance) {

        /**
         * 填充数值
         */
        accounts = new double[customerNum];
        Arrays.fill(accounts, balance);
        banlLock = new ReentrantLock();
        sufficientFunds = banlLock.newCondition();
    }

    /**
     * Description: 转账方法
     *
     * @param from
     * @param to
     * @param money
     * @return void
     * @Author: Peng Shiquan
     * @Date: 2020/11/9
     */
    public void transfer(int from, int to, double money) throws InterruptedException {
        banlLock.lock();
        try {
            while (accounts[from] < money) {
                //等待
                sufficientFunds.await();
            }
            System.err.println(Thread.currentThread());
            accounts[from] -= money;
            System.out.printf(" %10.2f from %d to %d", money, from, to);
            accounts[to] += money;
            System.out.printf("the total balance is %10.2f", getTotalbalance());
            sufficientFunds.signalAll();
        } finally {
            banlLock.unlock();
        }
    }

    /**
     * Description: 获取所有的余额
     *
     * @param
     * @return double
     * @Author: Peng Shiquan
     * @Date: 2020/11/9
     */
    public double getTotalbalance() {
        double sum = 0;
        banlLock.lock();
        try {
            for (double a : accounts) {
                sum += a;
            }
            return sum;

        } finally {
            banlLock.unlock();
        }
    }

    /**
     * Description: 获取当前客户人数
     *
     * @param
     * @return int
     * @Author: Peng Shiquan
     * @Date: 2020/11/9
     */
    public int getCustomerNum() {
        return accounts.length;
    }
}
```

```java
package syncTrain;

/**
 * BankMain.java
 * Description: 银行测试的主方法
 *
 * @author Peng Shiquan
 * @date 2020/11/9
 */
public class BankMain {
    public static final int MACCOUNTS = 100;
    public static final double INITIAL_BALANCE = 1000;
    public static final double MAX_AMOUNT = 100;
    public static final int DELAY = 10;

    public static void main(String[] args) {
        LockBank lockBank = new LockBank(MACCOUNTS, INITIAL_BALANCE);
        for (int i = 0; i < MACCOUNTS; i++) {
            int fromeaccount = i;
            Runnable r = () -> {
                try {
                    while (true) {
                        int toaccount = (int) (lockBank.getCustomerNum() * Math.random());
                        double money = MAX_AMOUNT * Math.random();
                        lockBank.transfer(fromeaccount, toaccount, money);
                        Thread.sleep((int) (DELAY * Math.random()));
                    }
                } catch (InterruptedException e) {

                }
            };
            Thread t = new Thread(r);
            t.start();
        }

    }
}
```

​	不难看到，总金额运行后是一直保持不变的。

![image-20201214212715997](https://1162210866.oss-cn-beijing.aliyuncs.com/uPic/image-20201214212715997.png)

​	但是这个办法只能用于单个机器，多服务器的情况下仍然会出现金额错乱的情况。使用synchronized关键字的代码如下，只是附上了银行类的代码。

```java
package syncTrain;

import java.util.Arrays;

/**
 * SyncBank.java
 * Description:Java关键字synchronized 的使用
 *
 * @author Peng Shiquan
 * @date 2020/12/14
 */
public class SyncBank {
    private final double[] accounts;

    /**
     * Description: 初始化
     *
     * @param customerNum
     * @param balance
     * @return
     * @Author: Peng Shiquan
     * @Date: 2020/11/8
     */
    public SyncBank(int customerNum, double balance) {

        /**
         * 填充数值
         */
        accounts = new double[customerNum];
        Arrays.fill(accounts, balance);
    }

    /**
     * Description: 转账方法
     *
     * @param from
     * @param to
     * @param money
     * @return void
     * @Author: Peng Shiquan
     * @Date: 2020/11/9
     */
    public synchronized void transfer(int from, int to, double money) throws InterruptedException {

        while (accounts[from] < money)
            wait();
        System.err.println(Thread.currentThread());
        accounts[from] -= money;
        System.out.printf(" %10.2f from %d to %d", money, from, to);
        accounts[to] += money;
        System.out.printf("the total balance is %10.2f", getTotalbalance());
        notify();
    }

    /**
     * Description: 获取所有的余额
     *
     * @param
     * @return double
     * @Author: Peng Shiquan
     * @Date: 2020/11/9
     */
    public synchronized double getTotalbalance() {
        double sum = 0;


        for (double a : accounts) {
            sum += a;
        }
        return sum;


    }

    /**
     * Description: 获取当前客户人数
     *
     * @param
     * @return int
     * @Author: Peng Shiquan
     * @Date: 2020/11/9
     */
    public int getCustomerNum() {
        return accounts.length;
    }
}
```

​	如何选择这些？怎么知道自己需要哪个？1.不要使用Lock/Condition或者synchronized,多数情况下可以使用阻塞队列来同步完成一个共同任务的线程。2.如果能使用synchronized，尽量使用，可以减少代码，从而达到减少出错的机会。3.如果需要使用到Lock\Condition的特性，才使用Lock\Condition。(书上抄的，就这样吧)

### 阻塞队列

​	阻塞队列是为了更加优雅的解决上面的问题，如果开发者太多的参与底层的编写，这个是不合理并且不切实际的。所以就有了阻塞队列的产生，用来解决线程之间共享资源的问题。阻塞队列的流程如下：许多线程向阻塞队列中取出指令并且执行相应命令，如果有生产者插入队列中新的元素或者消费者移除一个元素时，阻塞队列会导致线程阻塞。队列会自动的平衡负载。

下面就来简单编写一个阻塞队列的demo。

```java
package syncTrain;

import java.io.File;
import java.io.IOException;
import java.util.Scanner;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/**
 * BlockingQueueTrain.java
 * Description:  阻塞队列的练习
 *
 * @author Peng Shiquan
 * @date 2020/12/26
 */
public class BlockingQueueTrain {

    private static final int FILE_QUEUE_SIZE = 10;
    private static final int SEARCH_THREADS = 100;
    private static final File DUMMY = new File("");
    private static BlockingQueue<File> queue = new ArrayBlockingQueue<>(FILE_QUEUE_SIZE);

    public static void main(String[] args) {
        try (Scanner in = new Scanner(System.in)) {
            System.out.println("Input your directory eg: /Users/pengshiquan/Desktop/Developmentcache/JavaTrain/src/syncTrain");
            String directory = in.nextLine();
            System.out.println("Input your keyword eg volatile");
            String keyword = in.nextLine();
            Runnable enumerator = () -> {
                try {
                    enumrate(new File(directory));
                    //通过添加"包尾"来达到通知的效果
                    queue.put(DUMMY);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            };
            new Thread(enumerator).start();
            for (int i = 1; i < SEARCH_THREADS; i++) {
                Runnable searcher = () -> {
                    try {
                        boolean done = false;
                        while (!done) {
                            File file = queue.take();
                            if (file == DUMMY) {
                                queue.put(file);
                                done = true;
                            } else search(file, keyword);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                };
                new Thread(searcher).start();
            }
        }
    }

    /**
     * Description: 列举目录下所有的文件或者目录，添加到队列中.会循环遍历目录的目录
     *
     * @param directory 需要列举的文件夹或者文件。
     * @return void
     * @Author: Peng Shiquan
     * @Date: 2020/12/26
     */
    public static void enumrate(File directory) throws InterruptedException {
        File[] files = directory.listFiles();
        for (File file : files) {
            if (file.isDirectory()) enumrate(file);
            else queue.put(file);
        }
    }

    /**
     * Description: 搜索文件中是否含有关键字，有就打印出来
     *
     * @param file    需要搜索的文件
     * @param keyword 搜索时的关键字
     * @return void
     * @Author: Peng Shiquan
     * @Date: 2020/12/26
     */
    public static void search(File file, String keyword) throws IOException {
        try (Scanner in = new Scanner(file, "UTF-8")) {
            int lineNumber = 0;
            while (in.hasNextLine()) {
                lineNumber++;
                String line = in.nextLine();
                if (line.contains(keyword)) {
                    System.out.printf("%s:%d:%s%n", file.getPath(), lineNumber, line);
                    //想法是测试队列的公平性，但是测试结果和预想的不太一样
                    //System.err.println(Thread.currentThread().getId());
                }
            }
        }
    }

}
```

​	上面也没有什么难点，说一下大致的思路。这个demo的目的是为了检索用户输入的目录下所有文件含有关键字的行，并且打印该行。demo先是创建一个线程，用来将用户输入的目录下所有的文件或者文件夹放入队列中，另外起大量线程，用来检索文件内是否含有指定关键字。中间一部分代码和预想中的不一致，目前能力有限，也无法验证。就是上面测试队列公平性的代码，发现打印都是用一个线程做的。和我预想中的不太一样。

### Callable与Future

​	在Java中实现多线程有两种方式，一种是继承Thread类，还有一种就是实现Runnable接口。Runnable封装一个异步运行的任务，可以看为一个没有参数和返回值的异步方法。Callable和Runnablee类似，但是有返回值。Callable接口是一个参数化的类型，只有一个方法`call()`。

​	Future能够保存异步计算的结果，流程是这样的：启动一个计算，将Future对象交给某个线程，然后执行其他任务，Future对象的所有者在结果计算好之后就可以获得它。上面的例子也可以修改为使用Future，代码修改为如下代码：

```java
package syncTrain;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;

/**
 * FutureTest.java
 * Description: Future的练习
 *
 * @author Peng Shiquan
 * @date 2021/1/5
 */
public class FutureTest {

    public static void main(String[] args) {
        try (Scanner in = new Scanner(System.in)) {
            System.out.println("Input your directory eg: /Users/pengshiquan/Desktop/Developmentcache/JavaTrain/src/syncTrain");
            String directory = in.nextLine();
            System.out.println("Input your keyword eg volatile");
            String keyword = in.nextLine();
            MathCounter mathCounter = new MathCounter(new File(directory), keyword);
            FutureTask<Integer> task = new FutureTask<Integer>(mathCounter);
            Thread t = new Thread(task);
            t.start();
            try {
                System.err.println(task.get() + "符合的行数");
            } catch (Exception e) {

            }
        }
    }
}

/**
 * FutureTest.java
 * Description:  计数类，实现了Callable接口
 *
 * @author Peng Shiquan
 * @date 2020/12/29
 */
class MathCounter implements Callable<Integer> {
    private File directory;
    private String keyword;

    public MathCounter(File file, String keyword) {
        this.directory = file;
        this.keyword = keyword;
    }

    @Override
    public Integer call() throws Exception {
        int count = 0;
        File[] files = directory.listFiles();
        List<Future<Integer>> result = new ArrayList<>();
        for (File file : files)
            if (file.isDirectory()) {
                MathCounter mathCounter = new MathCounter(file, keyword);
                FutureTask<Integer> task = new FutureTask<Integer>(mathCounter);
                result.add(task);
                Thread t = new Thread(task);
                t.start();
            } else {
                if (search(file)) count++;
            }
        for (Future<Integer> integerFuture : result) {
            count += integerFuture.get();

        }
        return count;
    }

    public boolean search(File file) {
        try {
            try (Scanner in = new Scanner(file, "UTF-8")) {
                boolean found = false;
                while (!found && in.hasNextLine()) {
                    String line = in.nextLine();
                    if (line.contains(keyword)) found = true;
                }
                return found;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
}
```

### 执行器和线程池

​	线程的创建事比较消耗资源的，如果程序中创建了大量的短期线程，可以使用线程池来管理和获取。

​	这篇博客前前后后写了很长时间，最后写了感觉也不是很理想，中间也断断续续了几次，这篇博客的知识点我也忘了几次，都是看前面写的才记起来写到哪里。最后发现不是我想象中的学习方式，也记录下来，引以为戒。如果只是死看书很难学到有用的知识，可能就是写了一篇博客，其中的知识点也很难到自己的脑子里。还是好奇法更加容易学习，通过工作中的一个例子，去编写一个demo，再去了解这个demo后面藏着的知识，这样的方式才能让知识更加深刻的到达自己的脑子里面。引以为戒。

​	就这样吧，结束。