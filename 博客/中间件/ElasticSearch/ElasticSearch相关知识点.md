## ElasticSearch相关知识点

### ES基础知识点

​	ES集群可以包含多个索引（indices）(数据库)，每一个索引可以包含多个类型（types）（表），每一个类型包含多个文档（documents）（行），然后每个文档包含多个字段（fields）（列）。

#### 索引（Index）

​	索引是文档(Document)的容器，是一类文档的集合。在ES中有三种索引的概念，意思分别为：

* 索引(名词)。类比传统的关系型数据库领域来说，索引相当于SQL中的一个数据库(Database)。索引由其名称(必须为全小写字符)进行标识。
* 索引(动词)。保存一个文档到索引(名词)的过程。这非常类似于SQL语句中的 INSERT关键词。如果该文档已存在时那就相当于数据库的UPDATE。
* 倒排索引。关系型数据库通过增加一个B+树索引到指定的列上，以便提升数据检索速度。索引ElasticSearch 使用了一个叫做 倒排索引 的结构来达到相同的目的。

#### 类型（Type）

​	Type 可以理解成关系数据库中Table。

​	之前的版本中，索引和文档中间还有个类型的概念，每个索引下可以建立多个类型，文档存储时需要指定index和type。从6.0.0开始单个索引中只能有一个类型，7.0.0以后将将不建议使用，8.0.0 以后完全不支持。但是后续的版本弃用了，原因如下：

​	我们虽然可以通俗的去理解Index比作 SQL 的 Database，Type比作SQL的Table。但这并不准确，因为如果在SQL中,Table 之前相互独立，同名的字段在两个表中毫无关系。但是在ES中，同一个Index 下不同的 Type 如果有同名的字段，他们会被 Luecence 当作同一个字段 ，并且他们的定义必须相同。所以我觉得Index现在更像一个表，而Type字段并没有多少意义。目前Type已经被Deprecated，在7.0开始，一个索引只能建一个Type为_doc

#### 文档（Document）

​	Document Index 里面单条的记录称为Document（文档）。等同于关系型数据库表中的行。

#### 映射（Mapping）

​	映射(Mapping)相当于数据表的表结构。ElasticSearch中的映射（Mapping）用来定义一个文档，可以定义所包含的字段以及字段的类型、分词器及属性等等。

​	映射定义了类型中的域，每个域的数据类型，以及Elasticsearch如何处理这些域。映射也用于配置与类型有关的元数据。（元数据就是指和文档相关的数据，例如：文档的id、文档的index、文档的版本号）

​	映射创建完毕后就不能修改了，只能后续增加映射，不能修改已经存在的映射。映射也分为动态和静态。动态就是根据传入的json的类型去猜测映射的类型，例如“123”回被当为String。静态映射是在创建index时指定映射。

#### 字段（fields）

​	代表传统DB中的列的概念，例如学生表中的name列，一般映射也是对字段进行限制。

#### 分片（Shard）

​	一个分片是一个底层的工作单元 ，它仅保存了全部数据中的一部分。索引实际上是指向一个或者多个物理分片的逻辑命名空间 。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。分片分为主分片和副本。

* 主分片：主要的数据存储分片，也是和用户打交道的主要分片。
* 副本：主要对主分片的数据做冗余备份。当主分片异常时，副本可以继续提供读访问。

注意：一个index可能存在多个主分片上。主分片数量在创建时指定后就不能修改了，但是副本的数量可以修改。主分片不能和本分片的副本在同一个节点上。

#### 节点（Node）

​	节点是一个ElasticSearch的实例，其本质就是一个Java进程；Node 是组成集群的一个单独的服务器，用于存储数据并提供集群的搜索和索引功能。与集群一样，节点也有一个唯一名字，默认在节点启动时会生成一个uuid作为节点名，该名字也可以手动指定。单个集群可以由任意数量的节点组成。如果只启动了一个节点，则会形成一个单节点的集群。一台机器可以部署多个节点，但是建议一台机器部署一个节点。

#### 倒排索引

​	Elasticsearch 使用一种称为倒排索引的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。文档列表里面存储该词出现的文档和文档中该词出现的频率。

​	倒排索引就是将文档中出现的不重复的词语建立一个列表，然后对于各个文档，标注出该词语在文档中出现的次数。第一列是不重复词语，第一行是各个文档的id或者名称。表格中间填写的就是各个文档中各个词语出现的次数。

​	正排索引就是像MySQL这样类似，根据id查询该行的信息。倒排就是根据信息查询id。

#### 分析器

​	分析器就是从一串文本中切分出一个一个的词条，并対每个词条进行标准化。分析器实际上是将三个功能封装到了一个包里

* 字符过滤器：首先，字符串按顺序通过每个字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 & 转化成 and。
* 分词器：其次，字符串被分词器分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。
* Token 过滤器：最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。

​	内置的分析器有一下几种：

* 标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。
* 简单分析器在任何不是字母的地方分隔文本，将词条小写。
* 空格分析器在空格的地方划分文本。
* 特定语言分析器可用于很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的词干。

### ES中相关原理

#### 如何索引到文档

​	当索引一个文档的时候，文档会被存储到一个主分片中。这个时候是通过计算得到该文档所在的分片的。通过以下公式：

```
shard = hash(routing) % number_of_primary_shards
```

​	routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。这也就是为什么不能修改主分片的数量，如果修改了，后续的索引就无法找到对应的分片，之前的存放的文档也会有影响。

#### 搜索的过程

​	先说普通的CURD操作，因为CURD一般都带有三个属性：_index, _type, 和 routing values ，基本可以确定集群中的那个分片处理这个请求。

​	但是搜索比较复杂一些。主要分为查询阶段和取回阶段。

##### 查询阶段

​	当一个搜索请求被发送到某个节点时，这个节点就变成了协调节点。 这个节点的任务是广播查询请求到所有相关分片并将它们的响应整合成全局排序后的结果集合，这个结果集合会返回给客户端。

​	第一步是广播请求到索引中每一个节点的分片拷贝。就像 document GET requests 所描述的， 查询请求可以被某个主分片或某个副本分片处理， 这就是为什么更多的副本（当结合更多的硬件）能够增加搜索吞吐率。 协调节点将在之后的请求中轮询所有的分片拷贝来分摊负载。

​	每个分片在本地执行查询请求并且创建一个长度为 from + size 的优先队列—也就是说，每个分片创建的结果集足够大，均可以满足全局的搜索请求。 分片返回一个轻量级的结果列表到协调节点，它仅包含文档 ID 集合以及任何排序需要用到的值，例如 _score 。

​	协调节点将这些分片级的结果合并到自己的有序优先队列里，它代表了全局排序结果集合。至此查询过程结束。

##### 取回阶段

​	协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { "from": 90, "size": 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。

​	协调节点给持有相关文档的每个分片创建一个 multi-get request ，并发送请求给同样处理查询阶段的分片副本。

​	分片加载文档体-- _source 字段—如果有需要，用元数据和 search snippet highlighting 丰富结果文档。 一旦协调节点接收到所有的结果文档，它就组装这些结果为单个响应返回给客户端。

* 想象一下有两个文档有同样值的时间戳字段，搜索结果用 timestamp 字段来排序。 由于搜索请求是在所有有效的分片副本间轮询的，那就有可能发生主分片处理请求时，这两个文档是一种顺序， 而副本分片处理请求时又是另一种顺序。

  这就是所谓的结果震荡问题: 每次用户刷新页面，搜索结果表现是不同的顺序。 让同一个用户始终使用同一个分片，这样可以避免这种问题， 可以设置 preference 参数（偏好参数选定对应的节点）为一个特定的任意值比如用户会话ID来解决。

#### 节点故障后选举的流程

​	Elasticsearch在满足如下时间点的时候会触发选举1.集群启动初始化2.集群的Master崩溃的时候3.任何一个节点发现当前集群中的Master节点没有得到n/2 + 1节点认可的时候，触发选举。

​	选举的流程：

![preview](https://pic2.zhimg.com/v2-7c4b590346650f5e32088458da5df48d_r.jpg)

​	详细看文章：https://zhuanlan.zhihu.com/p/110079342

​	https://zhuanlan.zhihu.com/p/281021501

#### 处理冲突的流程

​	每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。

​	我们可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。

也可以通过外部版本号：

如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp — 那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号， 版本号必须是大于零的整数， 且小于 9.2E+18 — 一个 Java 中 long 类型的正值。

外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前 _version 是否 小于 指定的版本号。 如果请求成功，外部的版本号作为文档的新 _version 进行存储。

### 练习

#### POSTMAN练习

* PUT /index/type/id {body} 添加一个文档。

示例：

```shell
curl --location --request PUT 'http://127.0.0.1:9200/megacorp/employee/4' \
--header 'Content-Type: application/json' \
--data-raw '{
    "first_name" : "Li",
    "last_name" :  "Si",
    "age" :        26,
    "about" :      "I love to sleep",
    "interests": [ "bed", "work" ]
}'
```

* GET /megacorp/employee/1 查询一个id为1的文档。

示例：

```shell
curl --location --request GET 'http://127.0.0.1:9200/megacrop/employee/1' \
--header 'Content-Type: application/json' \
--data-raw '{
    "from":2,
    "size":1
} '
```

* GET /megacorp/employee/_search	搜索文档。可以添加相关的json来限制查询条件

示例：

```shell
curl --location --request GET 'http://127.0.0.1:9200/megacrop/employee/_search' \
--header 'Content-Type: application/json' \
--data-raw '{
    "query" : {
        "match" : {
            "last_name" : "Smith"
        }
    }
}'
```

* HEAD /megacorp/employee/123 查询文档是否存在。

示例：

```shell
curl --location --head 'http://127.0.0.1:9200/megacrop/employee/23'
```

* PUT /website/blog/123/_create	如果ID不存在创建新文档

示例：

```shell
curl --location --request PUT 'http://127.0.0.1:9200/website/blog/123/_create' \
--header 'Content-Type: application/json' \
--data-raw '{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}'
```

* DELETE /website/blog/123	删除文档

示例：

```shell
curl --location --request DELETE 'http://127.0.0.1:9200/website/blog/123'
```

* POST /website/blog/1/_update	更新文档，存在的字段就更新，不存在的字段就增加。

示例：

```shell
curl --location --request POST 'http://127.0.0.1:9200/megacorp/employee/4/_update' \
--header 'Content-Type: application/json' \
--data-raw '{
   "doc" : {
      "about" : "l love to sleep and work"
      
   }
}'
```

* [ES常用的查询语句](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_most_important_queries.html)

* 多个查询的组合。比较复杂，后面如果经常使用需要多看

```json
{
    "query": {
        "bool": {
            "must": {
                "match": {
                    "age": 25
                }
            },
            "must_not": {
                "match": {
                    "first_name": "Zhang"
                }
            },
            "should": [
                {
                    "match": {
                        "about": "rock"
                    }
                }
            ],
            "filter": {
                "exists": {
                    "field": "interests"
                }
            }
        }
    }
}
```

后续需要多看官方的文档，多了解了解

#### SpringBoot整合

​	整合依赖，添加esstarter即可，注意这个依赖使用的是elasticsearch-rest-high-level-client

​	添加相关配置，例如集群的url，这里可以添加多个，客户端会轮询

​	添加相关实体类，加上@Document(indexName = "user")注解

​	添加UserRepository接口继承ElasticsearchRepository<User, Integer>，一般的方法默认都实现了，也可以是使用@Query注解修改你方法的Query

​	查询即可，后续高级的用法再说。

### ES的面试问题

* ES集群相关的配置。

我们公司使用的是单节点架构，分片是默认的5分片。索引大概4个索引。主要存储的数据都是设备的历史数据和状态记录。这样是没法达到高可用的，可以设置多节点，保证高可用，因为主分片和他的副本是不会在同一个节点上的。索引的话可以设置多个主分片，但是后续不能修改，这个就需要结合你的业务增长速度，每个分片其实会占用一定的计算机资源。副本的话可以后续修改，如果你某个索引吞吐量达，可以添加副本的数量。

* ES是如何找到一个文档的

​	首先以我们公司使用的单节点架构为例，寻找一个文档很简单，知道文档的id和index，直接就能判断出文档在哪个分片，然后获取数据并且返回即可。这一步骤没有什么可以讲的点。搜索就复杂一点，因为不知道文档属于哪个分片，所以需要将请求发送到这个索引的所有副本分片上，同时后续的请求会轮询其他分片。每个分片建立一个优先队列，长度为from+size。默认的是0和10。然后该分片将符合要求的文档的id和排序值返回给协调节点，协调节点将所有节点的结果排序，取出客户端需要的数据，再次请求对应的分片，将分片返回的文档返回给客户端即可。多节点的话，最先请求的节点会处理客户端的请求，也叫做协调节点，但是我们只有一个节点，所以也就只有一个协调节点。

* 项目中什么地方使用到ES，为什么这样用？

因为我们公司项目本身是用来给政府单位开发的，所以在设计上会存在一些过量的设计，以此凸显自己项目的优势。这个我认为在开发中是没法避免的。后期的话，公司会做一个设备信息状态的判断 ，然后演算某些隧道的设备是否达到替换的标准，以此给业主提供参考意见，我觉这个地方可以展示es的一些优势，将es利用起来，例如：对某条隧道故障设备进行排名，再按照设备的供应商、地理位置等等条件。当然，这只是我的一个想法，目前的使用还是简单的将其作为一个数据库，对设备的历史数据进行维护。

* ES如果某一时刻需要开启大批量的查询，如何做？

可以通过游标查询，游标查询允许我们 先做查询初始化，然后再批量地拉取结果。游标查询是取某个时间点的快照数据，通过请求中设置游标的时间参数，获取到游标的id，后续的请求发送这个id即可。达到大批量的查询。 游标查询的过期时间会在每次做查询的时候刷新，所以你的时间点设置只要本地查询处理就可以了。不需要设置很大。初始搜索请求和每个后续滚动请求返回一个新的 _scroll_id。

* ES如何解决脑裂现象的

脑裂现象是指集群中因为网络分区或者其他原因导致出现两个master的现象，例如123选举3节点为master节点。456选举6节点为master节点。esmaster节点的选举来源分为两个地方，activemaster列表和mastercanditancees列表，前者是通过禁止本地节点入选来解决脑裂现象，后者是通过通过设置最小节点数来解决脑裂现象。当然，在我们项目实际使用过程中没有涉及到集群的这一方面，所以有些实际的问题可能没有涉及到。

* 什么是倒排索引

​	说到倒排索引，其实可以先提一下正排索引，类似MySQL这种，根据某行记录的ID查询该行记录，例如查询id为9的用户的信息，这就是正排索引，倒排索引相反，根据信息查询id，例如，有很多用户的信息，每个用户有一个备注，例如：我喜欢打篮球或者我喜欢打排球。倒排索引就是将这段话分词，分为各个词语，然后将形成一个列表，第一列就是各个词语，第一行就是各个文档id，中间内容就是记录各个词语在各个文档中是否出现或者出现的频率。这样就能达到一个效果，根据词语搜索文档的id，再搜索文档的信息。这样的表格就是倒排索引。

* ES集群是如何处理故障的？

​	其他节点发现master节点故障后，发起选举，选举出新的master节点，然后新的主节点重新分配主分片，为挂掉的主节点创建分片的副本。

* ES集群的选举过程？

​	选举的情况有三种：1）master节点崩溃。2）集群初始化的时候。3）任意节点发现当前master节点没有n/2+1节点支持时。

​	es的节点成员先发送ping请求给其他节点，构建两个列表：当前其他节点认为的存活的master节点列表和master候选节点列表。activeMaster和masterCanditances存在优先级，先从activeMaster中选举，如果该列表为空，在从masterCanditance列表中选举。

activeMaster节点不包含本地节点，这样就可以避免脑裂现象。该列表的选举采用Bully算法，就是每个节点都有一个优先级，从这些节点中选取出优先级最高的节点当作master节点。优先级的判断主要有两点：版本号和id。版本号越大优先级越高、id越小优先级越高。

masterCanditances列表里面先判断是否达到最小节点数，如果达到了就按照优先级进行选举。

选举出来master节点后，还存在两种情况：本地节点是master节点，会等待其他节点投票，如果超时或者设置的最小节点，就重新选举，如果票数大于，就当选为master节点。本地节点不是master时，首先禁止其他节点加入自己，然后监听集群的发布状态。如果新的master和自己的一致，就进行状态更新，否则重新发起选举。

### 缓存

//索引的概念

//文档的概念

//映射的相关概念



//主分片和复制分片的概念

//es如何确保请求被分开（可能是轮询）

//es中的文本分析和

//倒排索引（分词）

//分析器

//结构化查询（通过json体进行查询）

//查询语句和过滤语句

//结果震荡

//字典树





练习

//简单的CURD

//指定映射和分析器

//结构化查询（通过json体进行查询）

//查询语句和过滤语句

