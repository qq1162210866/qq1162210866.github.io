最近工作中用到了HTTP，想了解一下，所以看了《图解HTTP》，下面的内容相当于读书笔记。作为记录，省的后面又忘记，先后顺序按照阅读顺序。
	
* 1.三项构建WWW的技术。
	* “把SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；
	* 作为文档传递协议的 HTTP ；
	* 指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）”
* 2.“TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。” 
	* “应用层决定了向用户提供应用服务时通信的活动。”  
   * “传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。”  
   * “网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。”    
   * “链路层用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。”
* 3.三次握手        
    “发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。”
* 4.DNS服务	
 “DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。”
* 5.URI和URL的区别	
	“URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。”
* 6.HTTP/1.1中的方法
    * “GET ：获取资源” “GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。”
    * “POST：传输实体主体” “POST 方法用来传输实体的主体。”
    * PUT：传输文件 “PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。”
    * “HEAD：获得报文首部” “HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。”
    * DELETE：删除文件 “DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。”
    * “OPTIONS：询问支持的方法”  “OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。”
    * TRACE：追踪路径 “TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。”
   *  “CONNECT：要求用隧道协议连接代理” “CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。”
* 7.“持久连接节省通信量”
    * 持久连接 “为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。”
    * 管线化 “持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。”
* 8.cookie	
    “HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。”
    “Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。”
* 9.报文首部结构
    * “请求行 包含用于请求的方法，请求 URI 和 HTTP 版本。
    * 状态行 包含表明响应结果的状态码，原因短语和 HTTP 版本。    
    * 首部字段 包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。
    * 其他 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。”
* 10.报文主体和实体主体的区别
     * “报文（message）是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。
   * 实体（entity）作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。”
    * “HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。”
    * 报文主体相当于实际内容，实体主体相当于01数据，实体主体因为传输问题有可能被压缩，所以当编码操作后，实体主体可能会和报文主体不一致。

* 11.“多部分对象集合包含的对象”
	* multipart/form-data 在 Web 表单文件上传时使用。
	* multipart/byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。
* 12.常用的14种状态码
	* 200 OK “表示从客户端发来的请求在服务器端被正常处理了。”
	* 204 No Content “该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。”
	* 206 Partial Content “该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。”
	* 301 Moved Permanently “永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。”
	* 302 Found “临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。”
	* 303 See Other “该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。”
	* 304 Not Modified “该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。”
	* 307 Temporary Redirect “临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。”
	* 400 Bad Request “该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。”
	* 401 Unauthorized “该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。”
	* 403 Forbidden “该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。”
	* 404 Not Found “该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。” 
	* 500 Internal Server Error “该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。”
	* 503 Service Unavailable “该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。”
* 13.通信数据转发程序
	* “代理。代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。”
	* “网关。网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。”
	* “隧道。隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。”
* 14.“4 种 HTTP 首部字段类型”
	* “通用首部字段（General Header Fields）请求报文和响应报文两方都会使用的首部。”
	* “请求首部字段（Request Header Fields）从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。”
	* “响应首部字段（Response Header Fields）从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。”
	* “实体首部字段（Entity Header Fields）针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。”
* 15.HTTP/1.1 首部字段
	* 通用首部字段
		* “Cache-Control通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。”
			*  “public 指令。当指定使用 public 指令时，则明确表明其他用户也可利用缓存。”
			*  “private指令。当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。”
			*  “no-cache指令。使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。”
			*  “no-store 指令。当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。”
			*  “s-maxage 指令。s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。”
			*  “max-age指令。当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。”
			*  “min-fresh指令。min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。”
			*  “max-stale 指令。使用 max-stale 可指示缓存资源，即使过期也照常接收。”
			*  “only-if-cached 指令。使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。”
			*  “must-revalidate 指令。使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。”
			*  “proxy-revalidate 指令。proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。”
			*  no-transform 指令。“使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。”
		* Connection 首部字段具备如下两个作用。
			* 控制不再转发给代理的首部字段。“在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。”
			* 管理持久连接。“HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。”
		* “Datte首部字段,Date表明创建HTTP报文的日期和时间。”
		* “Pragma首部字段。Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。”
		* “Trailer首部字段。Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。”
		* “Transfer-Encoding首部字段 。Transfer-Encoding 规定了传输报文主体时采用的编码方式。”
		* “Upgrade首部字段。Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。”
		* “Via首部字段。Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。”
		* “Warning首部字段。HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。”
			* “110	Response is stale（响应已过期）代理返回已过期的资源
			* 111	Revalidation failed（再验证失败）代理再验证资源有效性时失败（服务器无法到达等原因）
			* 112	Disconnection operation（断开连接操作）代理与互联网连接被故意切断
			* 113	Heuristic expiration（试探性过期）响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）
			* 199	Miscellaneous warning（杂项警告）任意的警告内容
			* 214	Transformation applied（使用了转换）代理对内容编码或媒体类型等执行了某些处理时
			* 299	Miscellaneous persistent warning（持久杂项警告）任意的警告内容”
	* 	请求首部字段
		* Accept首部字段。“Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。”
		* Accept-Charset首部字段。“Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。”
		* Accept-Encoding首部字段。“Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。”
		* Accept-Language首部字段。“首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。”
		* Authorization首部字段。“首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。”
		* Expect首部字段。“客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。”
		* From首部字段。“首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。”
		* Host首部字段。“首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。”
		* If-Match首部字段。“形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。”
		* If-Modified-Since首部字段。“首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。”
		* If-None-Match首部字段。“首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。”
		* If-Range首部字段。“首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。”
		* If-Unmodified-Since首部字段。“首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。”
		* Max-Forwards首部字段。“通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。”
		* Proxy-Authorization首部字段。“接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。”
		* “Range首部字段。对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。”
		* Referer首部字段。“首部字段 Referer 会告知服务器请求的原始资源的 URI。”
		* “TE首部字段。首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。”
		* User-Agent首部字段。“首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。”
	* 响应首部字段
		* Accept-Ranges首部字段。“首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。”
		* Age首部字段。“首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。”
		* ETag首部字段。“首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。”
		* Location首部字段。“使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。”
		* “Proxy-Authenticate首部字段。首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。”
		* Retry-After首部字段。“首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。”
		* Server首部字段。“首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。”
		* Vary首部字段。“首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。”
		* WWW-Authenticate首部字段。“首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。”
	* 实体首部字段
		* Allow首部字段。“首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。”
		* Content-Encoding首部字段。“首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。”
		* Content-Language首部字段。“首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。”
		* Content-Length首部字段。“首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。”
		* Content-Location首部字段。“首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。”
		* Content-MD5首部字段。“首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。”
		* Content-Range首部字段。“针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。”
		* Content-Type首部字段。“首部字段 Content-Type 说明了实体主体内对象的媒体类型。”
		* Expires首部字段。“首部字段 Expires 会将资源失效的日期告知客户端。”
		* Last-Modified首部字段。“首部字段 Last-Modified 指明资源最终修改的时间。”
	* 为 Cookie 服务的首部字段
		* Set-Cookie首部字段。“开始状态管理所使用的Cookie信息”，属于响应首部字段。
			* “expires 属性。Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。”
			* “path 属性。Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。”
			* “domain 属性。通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。”
			* “secure 属性。Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。”
			* “HttpOnly 属性。Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。”
		* Cookie首部字段。“服务器接收到的Cookie信息”，属于请求首部字段。
			* Cookie首部字段。“首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。”
	* 其他首部字段
		* X-Frame-Options首部字段。“首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。”
			* “DENY ：拒绝
			* SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。”
		* “X-XSS-Protection首部字段。首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。”
			* 0 ：将 XSS 过滤设置成无效状态
			* 1 ：将 XSS 过滤设置成有效状态
		* “DNT首部字段。首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。”
			* 0 ：同意被追踪
			* 1 ：拒绝被追踪
		* “P3P首部字段。首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。”
* 16.HTTPS
	* “HTTP+ 加密 + 认证 + 完整性保护 =HTTPS”
	* “HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。”
	* “使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。”（公钥进行加密，收到数据的一方使用自己的私钥将加密的数据解密。客户端使用公钥加密数据，服务器使用私钥解密。）
	* “HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。”
* 17.HTTPS通信步骤  
	* “步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
	* 步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
	* 步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
	* 步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。
	* “步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。
	* 步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
	* 步骤 7：客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
	* 步骤 8： 服务器同样发送 Change Cipher Spec 报文。
	* 步骤 9： 服务器同样发送 Finished 报文。
	* 步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。
	* 步骤 11： 应用层协议通信，即发送 HTTP 响应。
	* “步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。”
* 18.“Cookie 来管理 Session”
	* 步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。
	* 步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。
	* “步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。”