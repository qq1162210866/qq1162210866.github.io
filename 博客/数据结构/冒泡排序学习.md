## 概念

​	冒泡排序是非常基础的排序算法之一，也很容易理解。过程简单来说就是：每次比较相邻的两个元素，如果前一个元素大于后一个元素就交换这两个元素的位置（不一定大于，小于也可以）。一直重复这个操作，知道数组中所有的元素排序正确后，即所有的元素都不需要交换位置。

​	也可以看看动图去理解。动图这里放上一个链接，菜鸟教程的：[菜鸟教程冒泡排序](https://www.runoob.com/w3cnote/bubble-sort.html)![冒泡算法动图链接](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

## 实现

​	实现起来也是比较简单的：代码如下：

```java
public static void bubbleSort1(int[] arr) {
    int length = arr.length;
    for (int i = 0; i < length - 1; i++) {
        for (int j = 0; j < length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) BaseSort.swap(arr, j, j + 1);
        }
    }
}
```

## 优化

​	当然，这个算法还有一些可以优化的点，但是对于算法的总体效果来说，作用不大，当作一个了解吧。

### 优化进入排序的条件

​	通过一些特殊的例子，我们可以看到，某些情况下，当数组内没有进行交换后，循环还是会继续，这个时候其实可以中断循环，这个优化的思路就是这样：当发现某次循环后元素没有进行交换，就退出循环，因为当前数组已经有序了。需要增加一个变量记录当前循环是否交换变量。具体代码如下：

```java
public static void bubbleSort2(int[] arr) {
    boolean swaped = true;
    int length = arr.length;
    for (int i = 0; i < length - 1; i++) {
        //如果没有发生交换，代表当前数组有序，直接返回即可
        if (!swaped) break;
        swaped = false;
        for (int j = 0; j < length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                BaseSort.swap(arr, j, j + 1);
                swaped = true;
            }
        }
    }
}
```

### 记录最近一次交换的数组下标

​	如果在一次循环中，数组前几次排序进行了交换，但是后面没有交换位置，其实我们这里可以在下一次循环时，只循环到最后一次交换的下标，因为后面的元素没有交换过，代表已经有序了。这个优化的思路就是如此。这里也可以结合前一个优化，都添加进来。具体实现代码如下：

```java
public static void bubbleSort3(int[] arr) {
    /**
     *  当前循环是否交换
     */
    boolean swaped = true;
    /**
     * 当前循环的最后一个index
     */
    int lastIndex = arr.length - 1;
    /**
     * 最后交换的数组下标
     */
    int swapedIndex = -1;
    while (swaped) {
        swaped = false;
        //因为第一次的循环，交换的index只会到arr.length - 2,所以这里用小于
        for (int i = 0; i < lastIndex; i++) {
            if (arr[i] > arr[i + 1]) {
                BaseSort.swap(arr, i, i + 1);
                swaped = true;
                swapedIndex = i;
            }
        }
        lastIndex = swapedIndex;
    }

}
```

​	注释写的也比较清楚了，这里就不再详细讲解了。

## 题目

​	力扣上面其实也有相关的题，可以练手。下面就写两道题。

* [把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

​	思路不是很容易想到，最主要的就是想明白排序的依据，即决定数组元素位置的依据。规则已经写在题目中了。剩下就没有什么需要注意的了。送上代码，使用的是冒泡，效率不是很高。

```java
package leetcode.offer;

/**
 * offer45.java
 * Description: 把数组排成最小的数
 *
 * @author Peng Shiquan
 * @date 2021/8/17
 */
public class offer45 {
    public static void main(String[] args) {
        int[] nums = new int[]{2, 1};
        String result = new offer45().minNumber(nums);
        System.err.println(result);
    }

    public String minNumber(int[] nums) {
        int length = nums.length;

        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length - 1 - i; j++) {
                String tmp1 = nums[j] + "";
                String tmp2 = nums[j + 1] + "";
              //排序的依据，即题目里面的意思。tmp1+tmp2>tmp2+tmp1  tmp1">"tmp2
                if (Long.parseLong(tmp1 + tmp2) > Long.parseLong(tmp2 + tmp1)) {
                    int tmp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = tmp;
                }
            }
        }
        StringBuilder stringBuilder = new StringBuilder();
        for (int num : nums) {
            stringBuilder.append(num);
        }
        return stringBuilder.toString();
    }

}
```

* [移动零](https://leetcode-cn.com/problems/move-zeroes/)

​	这个思路就比较简单了，因为冒泡排序不会影响数组中原有元素的位置顺序，所以直接冒泡即可。代码如下：

```java
package leetcode;

/**
 * LeetCode283.java
 * Description: 移动零
 *
 * @author Peng Shiquan
 * @date 2021/8/17
 */
public class LeetCode283 {
    public static void main(String[] args) {
        int[] nums = new int[]{0, 1, 0, 3, 12};
        new LeetCode283().moveZeroes(nums);
        for (int num : nums) {
            System.err.print(num + ",");
        }
    }

    public void moveZeroes(int[] nums) {
        int length = nums.length;
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length - 1 - i; j++) {
                if (nums[j] == 0) {
                    int tmp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = tmp;
                }
            }
        }
    }
}
```