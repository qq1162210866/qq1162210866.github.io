树化(){
for(循环遍历所有的节点){
    将当前节点左右树置为空
    if(根节点为空){
        将当前节点置为根节点，颜色为黑色
    }else{
        取出当前节点的hash值和key
        for(死循环){
            判断当前节点hash值和根节点的大小，大于根节点返回1，小于返回-1，等于则进行复杂判断，总之不会返回0
            根据dir是否大于0，将当前p节点（第一次为根节点）的左节点或者右节点复制给p
            if(p左右节点为空){
                将p节点置为x节点的父节点
                将x节点置为p节点的左节点或者右节点
                平衡插入x节点，返回根节点();                
            }

        }

    }
    
}
确保给出的根节点是正确的
}

平衡插入(){

    x:要插入的节点
    root:该红黑树的根节点
    xp:x节点的父节点
    xpp:xp节点的父节点
    xppl:xpp的左节点
    xppr:xpp节点的右节点

    将x节点颜色置为红色
    for(死循环){
        if(xp为空){
            将x节点置为黑色
            返回x节点
        }else if(如果xp为黑色或者xpp为空){
            返回root
        }
        if(xp等于xpp的左子树){
            if(xppr不为空并且xppr为红色){
                将xppr、xp置为黑色
                将xpp置为红色
                将xpp复制给x，再次循环
            }else{
                if(x为xp的右子树){
                    左旋转
                }

            }
        }
    }
}

左旋转(){
    p:要旋转树的中间节点
    root:整树的根节点
    r:p节点的右子树
    pp:p节点的父节点
    rl:r节点的左节点

    if(p不为空并且r也不为空){
        if(r存在左节点){
            将r的左节点赋值给p的右节点
            将p赋值给rl的父节点
        }
        if(p没有父节点){
            
        }
    }
    返回根节点

}   