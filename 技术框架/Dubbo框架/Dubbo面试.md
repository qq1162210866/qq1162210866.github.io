https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/

### 使用Dubbo中遇到的问题

* dubbo版本的问题

2.75会有一些很奇怪的问题，有一些BUG，我们直接升级了

因为我们使用dubbo最开始使用的是公司整合包，版本比较老，单独服务需要单独设置版本，发现无法统一设置版本，后来通过将公司整合包中的dubbo版本升级后，才能使用注解的方式统一指定dubbo服务的版本。

* dubbo旧服务无法下线的问题

https://github.com/apache/dubbo/issues/3785



服务宕机的时候，该节点由于是持久节点会永远存在，而且当服务再次重启的时候会将重新注册一个新节点。这样就导致 ZooKeeper 中存在额外失效的节点，且该节点还无法自然消除（除非手动调用 ZooKeeper 删除节点方法）

* dubbo超时的问题

可以自己测试一下，为什么当时没有超时。可以设置超时时间 超时是起效的，有一些重试的手段，需要设置为0.消费者的超时优先于提供者的超时

* 为什么使用dubbo

Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说
Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵
活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这
在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵
活性，具体情况具体考虑。

可以谈一下http和springcloud和dubbo



* 经常失败的服务会使用mock进行服务降级，本地返回一个数据。









Dubbo 是一款高性能、轻量级的开源 RPC 框架，提供服务自动注册、自动发
现等高效服务治理方案， 可以和 Spring 框架无缝集成。

透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，
没有任何API侵入。
软负载均衡及容错机制：可在内网替代 F5 等硬件负载均衡器，降低成本，减少
单点。
服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询
服务提供者的IP地址，并且能够平滑添加或删除服务提供者。



服务容器Container负责启动，加载，运行服务提供者。
服务提供者Provider在启动时，向注册中心注册自己提供的服务。
服务消费者Consumer在启动时，向注册中心订阅自己所需的服务。
注册中心Registry返回服务提供者地址列表给消费者，如果有变更，注册中心
将基于长连接推送变更数据给消费者。
服务消费者Consumer，从提供者地址列表中，基于软负载均衡算法，选一台
提供者进行调用，如果调用失败，再选另一台调用。
服务消费者Consumer和提供者Provider，在内存中累计调用次数和调用时
间，定时每分钟发送一次统计数据到监控中心Monitor。



Multicast 注册中心：Multicast 注册中心不需要任何中心节点，只要广播地
址，就能进行服务注册和发现,基于网络中组播传输实现。
Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用
Zookeeper 的 watch 机制实现数据变更。
Redis 注册中心：基于 Redis 实现，采用 key/map 存储，key 存储服务名和类
型，map 中 key 存储服务 url，value 服务过期时间。基于 Redis 的发布/订阅模式
通知数据变更。
Simple 注册中心。



启动 Dubbo 时，消费者会从 Zookeeper 拉取注册的生产者的地址
接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。



Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截
面碰撞率高，调用次数越多，分布越均匀。
RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累
积的问题。
LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请
求。
ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同
一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者
的剧烈变动。



Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读
操作，但重试会带来更长延迟。
Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等
性的写操作，比如新增记录。
Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志
等操作。
Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消
息通知操作。
Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时
性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并
行数。
Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 。



但是实际测试过程中发现配置无效，使用xml和注解均是，只有继续升级才能生效



Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用dubbo协议。
RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的Common-Collections 包，Java 序列化存在安全漏洞。
WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集
成和跨语言调用。
HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。
Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。
Memcache：基于 Memcache实现的 RPC 协议。
Redis：基于 Redis 实现的RPC协议。





实现失效踢出是什么原理

临时节点会在回话结束后自动删除

详细见zookeeper相关原理

