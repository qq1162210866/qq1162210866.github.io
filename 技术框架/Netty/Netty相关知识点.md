## NIO和BIO和AIO的区别

* 所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。

​	Linux对于IO的区分：

* 阻塞IO模型：应用进程等待数据准备好，拷贝完后，处理数据。
* 非阻塞IO模型：如果数据没有准备好，返回一个错误，数据准备好后，拷贝完毕后，处理数据。
* IO复用模型：Linux提供select/poll，可以检测多个通道数据是否就绪，当就绪后，调用回调函数。
* 信号驱动IO模型：调用一个信号处理函数，系统做其他事情，当数据准备就绪时，生成一个信号，通过信号回调通知程序读取数据。
* 异步IO：告知系统启动某个操作，让内核在完成操作后通知程序。和信号驱动的区别就是，拷贝过程中，异步IO也不会阻塞。

### BIO相关知识点

​	一般有一个独立线程负责监听客户端的连接，如果接收到客户端的请求，为每一个客户端的请求创建一个线程进行处理，处理完成后，通过输出流将返回信息返回给客户端。

​	还有就是通过线程池和同步队列实现的伪异步的IO通信框架。将套接字封装成一个Task，让后交给线程池处理。这样线程池可大可小，不会导致资源耗尽。

​	但是这样如果有一方接收速度较慢，另一方就会被阻塞。

### NIO相关知识点

#### 一些基础概念

​	Netty是一个高性能、异步事件驱动的NIO框架，所有的IO操作都是异步非阻塞的。

* 缓冲区buffer。缓冲区是一个对象，包含要写入或者要读出的数据。BIO中是直接操作Stream，但是NIO是直接操作buffer。缓冲区类似于字节数组。
* 通道Channel。通道类似于一个自来水管，可以通过它读取和写入数据。网络数据通过通道读取和写入，并且通道是双向的。
* 多路复用器Selector。Selector会不断轮询注册其上的Channel，如果某个Channel有TCP连接、读或者写事件，这个Channel就会处于就绪状态，会被Selector轮询出来，进行后续的IO操作。

#### 具体流程

​	NIO可以监听多个通道，通过将通道注册到多路复用器上，如果某个通道有连接、读或者写事件，Selector会通过关键字获取Channel，将通道的消息写入buffer中，再进行后续的IO操作。

### AIO相关知识点

​	AIO就是异步IO，程序启动后，不在原地等待程序执行结果，等到数据到了后，并且拷贝完毕后，异步通知原有程序，进行后续的数据处理。

## Netty相关知识点

 ### Netty基础概念

* 因为jdk自带的ByteBuffer只有一个指针用于读写操作，使用起来不是很方便，所以netty中的ByteBuf对其进行了优化。ByteBuf采用两个指针，读操作一个，写操作一个。数据的写入会导致写指针增加，读操作回导致读指针增加。但是读指针不能操过写指针，要不然会报错。调用discardReadBytes方法可以释放已经读过的区域。ByteBuf如果写入字节大于能写入字节，会进行动态扩展。
  * discardable会将读过的字节清楚，将读指针和写指针向前移动。
  * clear会将指针变为初始位置，并不会清除缓存区的内容。
  * mark会将指针备份，rest会将指针恢复到备份到位置。读写指针都有这个方法。
  * ByteBuf有很多查找字节的方法。
* Channel：数据传输通道,Netty对NIO中ServerSocketChannel和SocketChannel进行抽象和功能封装。每个Channel都对应一个物理链接。
* ChannelPipeline和ChannelHandler类似于过滤器，数据在ChannelPipeline中流转，ChannelHandler则对这些数据进行处理。底层的Channel触发事件，由EventLoop调用ChannelPipeline，将消息传输到ChannelPipeline中，再依次被各个Handler处理。
  * Netty中的启动类会为每个Channel自动创建pipeline，获取pipeline然后将handler加入即可。
  * ChannelPipeline支持运行时动态添加或者删除Handler。
  * ChannelPipeline是线程安全的。使用的是synchronized关键字实现。
* EventLoop和EventLoopGroup：EventLoop是一个IO线程，但是除了负责读写外，还处理系统Task、定时任务。EventLoopGroup是个线程池，主要放置Accpetor线程或者IO线程。
* Future：代表异步操作的结果，一般与Channel操作有关。
* Promise ：是可写的Future，Netty通过Promise对Future进行扩展，用于设置IO操作的结果。

​	Netty有三种线程模型：

* Reactor单线程模型：所有的IO操作都在同一个NIO线程上面完成，包括接受TCP连接信息，当链路建立后，将ByteBuf发送给Handler，进行消息解码。小容量可以使用，高并发不适合。
* Reactor多线程模型：有一个单独的Acceptor线程监听服务端，接受客户端的请求，IO操作读或者写则由NIO线程池复杂，线程池包含一个队列和N个可用的线程，由这些线程复杂解码、处理。一个NIO线程可以处理多个链路，但是一个链路只对应一个线程，这样可以防止并发导致出现问题。单独的Acceptor线程在某些情况下可能会出现性能问题，如：认证情况下。
* 主从Reactor多线程模型：服务端用于接受客户端的连接也是一个独立的线程池，Acceptor仅仅用于客户端的登录、握手、安全认证。然后将Channel注册到IO线程池，让后续的IO线程对数据进行处理。

### Netty具体流程

​	首先声明一个Channel，然后将这个通道注册到Selector，也就是BossGroup里面。当有客户端进行TCP连接时，把连接信息封装成 NioSocketChannel 注册到 WorkerGroup 线程中的 Selector。当 WorkerGroup 线程中的 Selector 监听到自己感兴趣的 IO 事件后，就调用 Handler 进行处理。

### Netty的线程模型



## 其他相关知识点

* 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。
* 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。

* Java中默认是大端模式。和TCP中的传输一致。

* 在操作系统层面上的零拷贝是指避免在用户态与内核态之间来回拷贝数据的技术。在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.

* Netty的零拷贝完全是在用户态(Java层面)的，更多是数据操作的优化。主要有五点：

  * Netty的接收和发送ByteBuffer使用直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。
  * Netty的文件传输调用FileRegion包装的transferTo方法，可以直接将文件缓冲区的数据发送到目标Channel，避免通过循环write方式导致的内存拷贝问题。
  * Netty提供CompositeByteBuf类, 可以将多个ByteBuf合并为一个逻辑上的ByteBuf, 避免了各个ByteBuf之间的拷贝。
  * 通过wrap操作, 我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象, 进而避免拷贝操作。
  * ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf, 避免内存的拷贝。






## 面试的问题

* 介绍一下netty的线程模型

​	说到netty的线程模型需要先说一下nio和aio的区别，NIO是内核通知应用可以读写，然后应用去进行读写操作，AIO不太一样，应用知识操作数据，对于读写操作由内核来完成，看起来像是异步的，就是应用要读写后立即返回。netty的线程模型就是基于reactor的。有很多线程模型，单线程模型、多线程模型、主从线程模型。单线程就是建立连接和读写操作都是一个线程，相当于一个线程干全部的活。弊端很明显，大量并发下，会导致系统的吞吐量降低。多线程模型就是一个 线程只用来建立连接，后面还有很多的线程用来处理读写操作，有点像boss和员工，boss找活干，员工来干活。netty中两个线程组就是这个名字。多线程其实已经满足我们项目的需要了，但是有些情况还是不能满足，像需要认证的情况，因为建立连接的线程还是一个，认证操作也比较耗时。就又了主从模型，还是一个线程建立连接，建立后将其交给boss线程组，这些线程主要进行认证这些比较耗时的操作，完成后，读写操作仍然交给后续的worker线程组。

* 